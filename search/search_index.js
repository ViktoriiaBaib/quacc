var __index = {"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p><code>quacc</code> (pronounced \"quack\" \ud83e\udd86) is a flexible platform for high-throughput computational materials science and quantum chemistry built for the exascale era, maintained by the Rosen Research Group at Princeton University.</p> <ul> <li> <p><code>quacc</code> makes it possible to easily write complex workflows that can be run anywhere, anyhow. By anywhere, we mean locally, HPC, the cloud, or any combination thereof. By anyhow, we mean via one of several modern workflow management solutions</p> </li> <li> <p><code>quacc</code> leverages community resources. It is built around the Atomic Simulation Environment and much of the software infrastructure powering the Materials Project.</p> </li> <li> <p><code>quacc</code> gives you the freedom of choice. Through a single, unified interface to several supported workflow management solutions, <code>quacc</code> lets you use what best suits your unique computing needs.</p> </li> <li> <p><code>quacc</code> has pre-made recipes for the following packages: DFTB+, Gaussian, GULP, NewtonNet, ORCA, Psi4, Q-Chem, tblite, and VASP. It's simple to add your favorite!</p> </li> </ul> <p></p>"},{"location":"about/changelog.html","title":"Changelog","text":"CHANGELOG.md<pre><code># Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/), and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [0.3.5]\n\n### Added\n\n- Added a new `VibThermoSchema` that merges the `VibSchema` and `ThermoSchema` as a convenience\n\n### Changed\n\n- The output of recies no longer automatically removes blank lists/dicts/sets to maintain a consistent schema.\n- The tblite `freq_job` and lj `freq_job` now use `VibThermoSchema` as the output\n- Changed default `SCRATCH_DIR` from `Path.cwd() / \".scratch\"` to `Path(\"~/.scratch\")`\n\n## [0.3.4]\n\n### Added\n\n- Added a new documentation section for worked examples on HPC.\n\n### Changed\n\n- Updated the minimum required versions for Pymatgen and emmet-core to reflect Pydantic 2 update.\n- Added `symprec=1e-8` to the default parameters of VASP relaxation jobs.\n- VASP bulk recipes now use \"BulkSet\" as the default preset instead of `None`.\n- VASP slab recipes now use \"SlabSet\" as the default preset instead of `None`.\n\n## [0.3.3]\n\n### Fixed\n\n- Fixed pip version conflict when installing Covalent dependencies.\n\n## [0.3.2]\n\n### Changed\n\n- Migration to Pydantic 2 is complete, along with the corresponding dependencies.\n\n## [0.3.1]\n\n### Changed\n\n- Pydantic field type validation has been improved.\n- Moved `quacc.utils.atoms`/`.slabs`/`.defects` into `quacc.atoms.core`/`.slabs`/`.defects`\n- Moved `quacc.custodian` to `quacc.calculators.custodian`\n- Moved `quacc.utils.thermo.ideal_gas` to `quacc.builders.thermo.build_ideal_gas`\n- Renamed `quacc.schemas.ase.summarize_thermo` to `quacc.schemas.ase.summarize_ideal_gas_thermo`\n\n## [0.3.0]\n\n### Changed\n\n- Changed default `SCRATCH_DIR` from `/tmp` to `Path.cwd() / .scratch`\n- Refactored decorator handling to be more concise\n- Renamed `[optimizers]` extras to `[sella]`\n- Moved `quacc.utils.wflows` into `quacc.wflow.decorators` and `quacc.wflow.prefect`\n- Moved `quacc.utils.db` into `quacc.wflow.db`\n- Moved `quacc.utils.calc` to `quacc.runners.calc`\n- Moved `quacc.presets` to `quacc.calculators.presets`\n\n### Fixed\n\n- Fixed parsing of `RESULTS_DIR` and `SCRATCH_DIR` paths when they contain `~`\n- Symlinks are no longer created if `RESULTS_DIR == SCRATCH_DIR` since this is redundant\n- If `RESULTS_DIR` or `SCRATCH_DIR` are not present, they will be automatically made\n\n## [0.2.8]\n\n### Changed\n\n- Decorators are now applied at import time rather than at function-call time.\n\n### Fixed\n\n- Fixed compatability with FireWorks.\n- Fixed I/O issue on Windows and NFS filesystems where Sella optimizations would crash.\n\n## [0.2.7]\n\n### Added\n\n- Added a `freq_job` recipe in Q-Chem (@samblau)\n- Added support for TRICs in Sella calculations (@samblau)\n\n### Changed\n\n- Refactored all recipes to prevent code duplication\n- Set `LREAL = False` in VASP `BulkSet.yaml`\n\n## [0.2.6]\n\n### Added\n\n- Add support for `Path` objects everywhere possible.\n\n### Changed\n\n- Charge and spin multiplicity are now required arguments in molecular DFT calculators.\n- Slab recipes now use `make_slabs_from_bulk` instead of `make_max_slabs_from_bulk`\n- Use the `logging` module when warnings do not need to be immediately addressed.\n- Functions are no longer used as kwargs in recipes to help with (de)serialization in certain workflow engines.\n\n### Removed\n\n- Removed `make_max_slabs_from_bulk` function.\n\n## [0.2.5]\n\n### Added\n\n- Added support for the Redun workflow engine.\n- Added a simple CLI for (un)setting YAML config parameters.\n\n### Changed\n\n- Internal refactoring of the `Vasp` calculator.\n\n### Removed\n\n- Removed the demonstration Jobflow EMT slab recipe.\n\n## [0.2.4]\n\n### Changed\n\n- Updated VASP co-pilot rules and `BulkSet.yaml` in accordance with recent MP benchmarking (#849).\n- Moved `fetch_atoms` to `quacc.schemas`.\n\n### Fixed\n\n- VASP: Fixed a scenario where SIGMA was set to 0.05 if the user provided SIGMA &gt; 0.05. This was supposed to happen when ISMEAR = 0 but was previously done when ISMEAR = -5, which is not influenced by SIGMA.\n- Fixed `mp_relax_flow` to use a `#!Python @flow` decorator instead of `#!Python @job`\n- Fixed the Q-Chem Quasi-IRC job to run as one `#!Python @job` instead of two.\n\n## [0.2.3]\n\n### Added\n\n- Added new defect EMT workflows (@rwexler)\n- Added new defect utilities (@rwexler)\n- Added a custom Q-Chem calculator based on Pymatgen and Custodian. (@samblau)\n- Added Q-chem core recipes. (@samblau)\n- Added the ability to pass option `run_kwargs` to the `.run()` method of the ASE optimizers.\n\n### Changed\n\n- Removed the need to call `ct.dispatch` when launching Covalent workflows.\n- Renamed `quacc.util` to `quacc.utils`\n- Refactored and standardized the NewtonNet recipes to match the other recipes\n\n### Fixed\n\n- The `WORKFLOW_ENGINE` setting can now be set dynamically, as expected.\n\n## [0.2.2]\n\n### Changed\n\n- Changed package handling in `pyproject.toml` to better handle pip installs.\n\n## [0.2.1]\n\n### Added\n\n- Added NewtonNet recipes and better sella support (@kumaranu)\n\n### Changed\n\n- Standardized `relax_cell` to be `False` by default for all recipes.\n- Update the default `SIGMA` and `ISMEAR` in `MPScanSet` to match the new values to be used in Atomate2.\n\n### Fixed\n\n- Fixed a bug on Windows where the trajectory file would not be closed after a relaxation, causing permission errors.\n\n### Removed\n\n- Removed atomate2 as a dependency.\n- Removed experimental Prefect support.\n\n## [0.2.0]\n\n### Added\n\n- Added a quacc global setting, `WORKFLOW_ENGINE`, to set the workflow manager.\n- Added support for the new `covalent-hpc-plugin` in `pyproject.toml`.\n\n### Changed\n\n- Quacc recipes are now decorated with generic `#!Python @job`, `#!Python @subflow`, or `#!Python @flow` decorators to be workflow engine-agnostic.\n- Covalent is now an optional dependency to allow the base `quacc` package to be dependency-light.\n- Default VASP pseudopotentials changed to `setups_pbe54.yaml`.\n- Changed `quacc.recipes.emt.jobflow` and `quacc.recipes.emt.prefect` to `quacc.recipes.emt._jobflow` and `quacc.recipes.emt._prefect`\n\n### Fixed\n\n- Set `LMAXMIX` based on the `Z` value, not the s/p/d/f-block type.\n- Do not set automatically `LMAXTAU` to 8 for f-containing elements in `Vasp` calculator.\n\n### Removed\n\n- Removed `quacc.recipes.emt.parsl` since it is now obsolete.\n- Removed `quacc config` command-line option.\n\n## [0.1.3]\n\n### Added\n\n- Added a `PRIMARY_STORE` quacc setting that, when specified, will automatically store all results in the specified Maggma store.\n\n### Changed\n\n- The trajectory is now stored in `quacc.schemas.cclib.summarize_run`.\n- By default, results are now stored in a fixed `RESULTS_DIR`, which defaults to the current working directory.\n\n### Fixed\n\n- Fix path-related issues when running in local multi-threaded mode.\n- Psi4 recipes now use `uks` for unrestricted calculations instead of `uhf`.\n\n## [0.1.2]\n\n### Added\n\n- Added support for Prefect.\n- Added `quacc.wflow` module.\n\n### Changed\n\n- Made slab-related kwargs more consistent, such as by changing `slab_relax_electron`/`slab_relax_app` to just `slab_relax` regardless of workflow manager.\n\n## [0.1.1]\n\n### Added\n\n- Added this `CHANGELOG.md` file.\n- Added the `quacc.recipes.emt.parsl` module.\n- Added a CLI for `quacc` along with a `quacc config` option to configure Covalent appropriately upon install.\n- Added generic type hints for schemas.\n- Added a `CREATE_UNIQUE_WORKDIR` global setting to have quacc automatically make a unique working directory for each calculation.\n- Added `CHECK_CONVERGENCE` to global settings.\n\n### Changed\n\n- The `quacc` directory is now found in a `src` basefolder.\n- All recipes now support the `Atoms` object being passed in as an `AtomsSchema`.\n- The `slab_relax_job` kwarg in `recipes.emt.slabs` and `recipes.vasp.slabs` workflows can no longer be set to `None`, as there are few situations where this would be desired.\n- Class-based recipes have been converted to functions since they don't save state or have inheritance.\n\n### Docs\n\n- Switched the docs from Furo to Material for MkDocs.\n- Expanded upon Parsl documentation.\n- Modified tutorials and added example configs for Slurm.\n\n### Fixed\n\n- Temporary directories are cleaned up after the run is completed.\n\n### Removed\n\n- Removed `quacc.recipes.vasp.jobflow` module to prioritize Covalent and Parsl.\n\n## [0.1.0]\n\nSee https://github.com/quantum-accelerators/quacc/releases/tag/v0.1.0 for more details.\n\n## [0.0.6]\n\nSee https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.6 for more details.\n\n## [0.0.5]\n\nSee https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.5 for more details.\n\n## [0.0.4]\n\nSee https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.4 for more details.\n\n## [0.0.3]\n\nSee https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.3 for more details.\n\n## [0.0.2]\n\nSee https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.2 for more details.\n\n## [0.0.1]\n\nSee https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.1 for more details.\n</code></pre>"},{"location":"about/conduct.html","title":"Code of Conduct","text":""},{"location":"about/conduct.html#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"about/conduct.html#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"about/conduct.html#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"about/conduct.html#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"about/conduct.html#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"about/conduct.html#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"about/conduct.html#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"about/conduct.html#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"about/conduct.html#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"about/conduct.html#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"about/conduct.html#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"about/contributors.html","title":"People","text":""},{"location":"about/contributors.html#developers","title":"Developers","text":"<p>Quacc was designed and developed by Andrew S. Rosen.</p>"},{"location":"about/contributors.html#contributors","title":"Contributors","text":"<p>Additional contributions were made by the individuals listed here. Their contributions are summarized below.</p> <p>Note</p> <p>Don't see your name and want to update the list? Submit a PR and update this documentation page!</p> <ul> <li>@samblau: Custom Q-Chem calculator, Q-Chem core and TS recipes.</li> <li>@kumaranu: NewtonNet core and TS recipes.</li> <li>@rwexler: Defect utilities and EMT defect recipe.</li> <li>@ViktoriiaBaib: Initial testing of quacc.</li> </ul>"},{"location":"about/contributors.html#inspiration","title":"Inspiration","text":"<p>Quacc was originally inspired by Atomate2, developed by Alex Ganose.</p>"},{"location":"about/faq.html","title":"FAQ","text":"<p>Q: How do I pronounce <code>quacc</code>?</p> <p>A: Like the sound a duck makes: \"quack!\"</p> <p>Q: What's the philosophy behind quacc?</p> <p>A: This is a big question. I'll explain with some points that were on my mind when I made it:</p> <ol> <li> <p>Everyone's computing needs are different, which means not everyone is going to want to use the same workflow engine. This has historically hindered the widespread adoption of prior computational materials science libraries and makes it difficult to share workflows with others. quacc supports several workflow engines out-of-the-box using largely the same syntax, and you can pick your favorite (or use none at all).</p> </li> <li> <p>We should leverage tools that are widely used in the community. Python packages like ASE and Pymatgen are staples in the computational materials science community. Rather than reinvent the wheel, quacc takes advantage of what is already out there and \u2014 crucially \u2014 makes them play nicely together.</p> </li> <li> <p>Developers should be able to focus on the science, not the workflow architecturee. Many similar packages have the science closely intertwined with the workflow logic. This makes it difficult to write new workflows without learning the intricacies of the workflow stack. quacc solely relies on the use of function decorators that make it easy to transform typical functions into ones that are workflow-ready.</p> </li> <li> <p>An overeliance on classes and inheritance can be confusing at the expense of conciseneess. I love classes, but in a computational materials science library, too much class inheritance can make it difficult to track down what parameters are getting set where. Students are also less familiar with classes and may have a difficult time in understanding how they work. The recipes in quacc take a more direct and familiar functional programming approach.</p> </li> <li> <p>And last but not least, I'm opinionated. quacc represents choices that I think make the most sense for my group and me. Hopefully they make sense for you too.</p> </li> </ol> <p>Q: Which workflow management system should I use?</p> <p>A: Good question! Check out the Workflow Engines Overview Guide for a comparison of several common options to see which might be best for you.</p> <p>Q: Why is quacc better than <code>InsertMyFavoriteCode</code>?</p> <p>A: Better is all in the eye of the beholder. If you are happy with the tools you are using, my goal is not to convince you to switch. That said, if you find that writing high-throughput computational workflows has a huge learning curve or simply takes too much time away from your science, then quacc may be for you.</p> <p>Q: Do you have any tips for writing new workflows?</p> <p>A: When developing new workflows, I strongly recommend writing an initial draft based on a low-cost ASE calculator like <code>EMT</code> or <code>LJ</code>, which will allow you to test on your local machine with fast turnaround. Also try to keep things modular. Trying to do too much in one function can make it difficult to debug.</p> <p>Q: How is quacc different than just using the Atomic Simulation Environment (ASE)</p> <p>A: quacc is designed to supercharge ASE for the efficient design of high-throughput workflows. Quacc makes it possible to easily design complex ASE workflows that can be run on heterogeneous compute environments with modern workflow managers, such as Covalent and Parsl. Quacc also makes it possible to combine ASE with the powerful Materials Project software stack, such as Custodian for on-the-fly error handling. For the database enthusiasts, quacc is interoperable with Maggma to store calculation results in a readily queryable format like MongoDB.</p> <p>Q: How is quacc different than Atomate2?</p> <p>A: Atomate2 is a fantastic code that can be used to run libraries of computational materials science workflows. Quacc was originally inspired by Atomate2 and can be thought of as a \"sister code\" to it. That said, there are several important differences.</p> <ul> <li> <p>In Atomate2, workflows are built around the Materials Project software stack and can be cumbersome to interface with the Atomic Simulation Environment (ASE). In contrast, quacc was built around ASE from the ground up while still making it possible to leverage much of the software underlying the Materials Project. Since quacc is built around ASE, it is also trivial to add new recipes based on any code that has an existing ASE Calculator even if it is not in quacc yet.</p> </li> <li> <p>Atomate2 is built around Jobflow. Quacc is largely workflow engine-agnostic and has out-of-the-box support for numerous workflow codes, including but not limited to Jobflow.</p> </li> <li> <p>Atomate2 is often used as a database-first approach to materials science workflows. Quacc is fully compatible with the use of databases but only emphasizes their use for experts, with the goal of reducing the barrier to getting started.</p> </li> <li> <p>Atomate2 is developed and supported by the Materials Project team at Lawrence Berkeley National Laboratory. Quacc is developed and maintained by the Rosen Research Group at Princeton University.</p> </li> </ul> <p>Despite these differences, quacc and Atomate2 are largely interoperable! Feel free to stitch together workflows from both codes as you see fit using Jobflow!</p> <p>Q: I want to contribute a new recipe to quacc, but it will require additional dependencies. Is that a problem?</p> <p>A: Absolutely not a problem! Simply make your dependencies optional in the <code>pyproject.toml</code> file and use a <code>monty.dev.requires</code> decorator to ensure your recipes and tests only run if your necessary dependencies are installed. Refer to quacc.recipes.tblite.core and the <code>[tblite]</code> extras in the <code>pyproject.toml</code> file for an example.</p>"},{"location":"about/license.html","title":"License","text":"LICENSE.md<pre><code>BSD 3-Clause License\n\nCopyright (c) 2023, Andrew S. Rosen.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n- Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n- Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n- Neither the name of the copyright holder nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n</code></pre>"},{"location":"dev/_internal.html","title":"internal","text":"<p>To upload to PyPI:</p> <pre><code>pip install -e .\npython -m build\ntwine check dist/*\ntwine upload dist/*\n</code></pre>"},{"location":"dev/contributing.html","title":"Contributing","text":"<p>We welcome all contributions, big or small (provided they come with unit tests!). Here are some general guidelines and tips. Note that it is never too early to open a PR if you're looking for input or feedback!</p> <p>Note</p> <p>Thank you for reading this page! If you need additional incentive to contribute to quacc, we plan to eventually submit a manuscript based on this code. If you contribute to quacc in a significant way (e.g. adding a new recipe or module), you will be contacted to opt-in for authorship once a draft is written. Regardless, all contributors are acknowledged in the About section of the documentation.</p>"},{"location":"dev/contributing.html#general-tips","title":"General Tips","text":"<p>When developing new recipes, it is often helpful to start from an existing example. In general, we recommend referring to <code>quacc.recipes.emt</code> as a starting point.</p>"},{"location":"dev/contributing.html#steps-to-contribute","title":"Steps to Contribute","text":"<p>To contribute to quacc, we recommend doing the following:</p> <ul> <li> <p>Fork the repository to your personal GitHub account.</p> </li> <li> <p>Clone this forked repository to your local machine, e.g. via <code>git clone &lt;repo url&gt;.git</code>.</p> </li> <li> <p>In the newly downloaded <code>quacc</code> base directory, run <code>pip install -e .[dev]</code> to install quacc in editable mode and with the development dependencies. If you need to strictly match the versions of dependencies used in the GitHub actions test suite, you can find <code>requirements.txt</code> files in the <code>tests</code> directory.</p> </li> <li> <p>Commit your changes and push them to your personal forked repository in a new branch.</p> </li> <li> <p>Create a pull request (PR) to merge your changes into the main quacc repository.</p> </li> </ul> <p>For reproducibility purposes, we strongly recommend installing quacc in a fresh virtual environment.</p>"},{"location":"dev/contributing.html#guidelines","title":"Guidelines","text":""},{"location":"dev/contributing.html#general","title":"General","text":"<p>Please abide by the following guidelines when contributing code to quacc:</p> <ul> <li> <p>All changes should have associated unit tests that pass. Code coverage should be maintained.</p> </li> <li> <p>All code should include type hints and have internally consistent documentation for the inputs and outputs.</p> </li> <li> <p>Only define multi-step workflows if they go beyond simply stitching together existing functions or if they are widely used in other recipes. Otherwise, just define the individual functions.</p> </li> <li> <p>Ensure that the code remains flexible for the user whenever possible.</p> </li> <li> <p>Where appropriate, you should use the \"internal\" geometry optimizers for a given code rather than the ASE optimizers.</p> </li> <li> <p>Use absolute paths where possible and avoid using <code>os.chdir</code>. This helps ensure that quacc can be run in a multi-threading mode.</p> </li> <li> <p><code>gzip</code> large test files to save space.</p> </li> </ul>"},{"location":"dev/contributing.html#new-recipes","title":"New Recipes","text":"<p>If contributing new recipes, please abide by the following guidelines:</p> <ul> <li> <p>Please mimic one of the other recipes as a general template for internal consistency.</p> </li> <li> <p>Ensure that the first positional argument accepts <code>Atoms | dict</code> like all the other recipes.</p> </li> <li> <p>Decorate your individual compute jobs with a <code>@job</code> decorator or your flow with a <code>@flow</code> decorator and name them accordingly.</p> </li> </ul>"},{"location":"dev/contributing.html#style","title":"Style","text":"<p>In general, please try to keep the code style consistent when possible, particularly:</p> <ol> <li> <p>Use NumPy-style Docstrings.</p> </li> <li> <p>Address any relevant style issues raised by the \"Deepsource: Python,\" if present.</p> </li> <li> <p>All Python code should be formatted with isort, black, and ruff, although this will be corrected automatically when merged.</p> </li> </ol>"},{"location":"dev/contributing.html#unit-tests","title":"Unit Tests","text":"<p>All changes you make to quacc should be accompanied by unit tests and should not break existing tests. To run the full test suite, run <code>pytest .</code> from the <code>quacc/tests</code> directory. Each PR will report the coverage once your tests pass, but if you'd like to generate a coverage report locally, you can use pytest-cov, such as by doing <code>pytest --cov=quacc .</code> in the <code>tests</code> directory.</p> <p>If you are adding recipes based on a code that can be readily installed via <code>pip</code> or <code>conda</code> (e.g. tblite, DFTB+, Psi4), then you can run these codes directly in the test suite. Preferably, you should use a small molecule or solid and cheap method so the unit tests run quickly. If the recipes you're adding are proprietary or not available via <code>pip</code> or <code>conda</code> (e.g. Gaussian, GULP), then you will need to monkeypatch certain functions to change their behavior during testing.</p>"},{"location":"dev/docs.html","title":"Documentation","text":"<p>To install the dependencies to build the documentation, run <code>pip install -e .[docs]</code>.</p> <p>The quacc documentation is built using Material for MkDocs. To build the documentation locally (e.g. to evaluate changes), run <code>mkdocs serve</code> in the base directory and open the URL shown in the terminal.</p>"},{"location":"install/codes.html","title":"Calculator Setup","text":"<p>Tip</p> <p>Just getting started? Try using the EMT or LJ recipes before worrying about setting up one of the calculators below.</p> <p>Here, we outline how to ensure that quacc can run the quantum chemistry package of your choosing. You only need to follow the instructions for the code(s) you intend to use.</p>"},{"location":"install/codes.html#dftb","title":"DFTB+","text":"<p>If you plan to use DFTB+ with quacc, you will need to install the code as follows:</p> <pre><code>conda install -c conda-forge dftbplus\n</code></pre>"},{"location":"install/codes.html#emt","title":"EMT","text":"<p>No setup needed!</p>"},{"location":"install/codes.html#gaussian","title":"Gaussian","text":"<p>As noted in the ASE documentation, you will need to define an environment variable named <code>ASE_GAUSSIAN_COMMAND</code>. It should be formatted as follows:</p> <pre><code>export ASE_GAUSSIAN_COMMAND=\"/path/to/my/gaussian_executable Gaussian.com &gt; Gaussian.log\"\n</code></pre>"},{"location":"install/codes.html#gulp","title":"GULP","text":"<p>As noted in the ASE documentation, you must set the environment variables <code>GULP_LIB</code> and <code>ASE_GULP_COMMAND</code> as follows:</p> <pre><code>export GULP_LIB=\"/path/to/my/gulp-#.#.#/Libraries\"\nexport ASE_GULP_COMMAND=\"/path/to/my/gulp-#.#.#/Src/gulp &lt; gulp.gin &gt; gulp.got\"\n</code></pre>"},{"location":"install/codes.html#lennard-jones","title":"Lennard Jones","text":"<p>No setup needed!</p>"},{"location":"install/codes.html#newtonnet","title":"NewtonNet","text":"<p>If you plan to use NewtonNet with Quacc, you will need to install it prior to use. This can be done as follows:</p> <pre><code>pip install git+https://github.com/ericyuan00000/NewtonNet.git\npip install quacc[newtonnet,sella]\n</code></pre>"},{"location":"install/codes.html#orca","title":"ORCA","text":"<p>To use quacc with ORCA, you will need to define the <code>ORCA_CMD</code> setting to be the full, absolute path to your ORCA executable. This can be done as described in the section on \"Modifying Quacc Settings\", such as by defining the following environment variable:</p> <pre><code>export QUACC_ORCA_CMD=\"/path/to/my/orca/orca\"\n</code></pre>"},{"location":"install/codes.html#psi4","title":"Psi4","text":"<p>If you plan to use Psi4 with quacc, you will need to install it prior to use. This can be done as described in the Psi4 installation guide.</p>"},{"location":"install/codes.html#q-chem","title":"Q-Chem","text":"<p>If you plan to use Q-Chem with Quacc, you will need to install <code>openbabel</code> and <code>sella</code> (recommended) prior to use. This can be done as follows:</p> <pre><code>conda install -c conda-forge openbabel\npip install quacc[sella]\n</code></pre>"},{"location":"install/codes.html#tblite","title":"tblite","text":"<p>If you plan to use tblite with quacc, you will need to install the tblite interface with ASE support.</p> <pre><code>pip install quacc[tblite]\n</code></pre>"},{"location":"install/codes.html#vasp","title":"VASP","text":"<p>To use VASP with quacc, you will need to do the following, as described in greater detail in the ASE documentation:</p> <ul> <li>Define the <code>VASP_PP_PATH</code> environment variable that points to your pseudopotential library. We recommend including this in your <code>~/.bashrc</code> file since this rarely changes.</li> <li>If you wish to use vdW functionals, define the <code>ASE_VASP_VDW</code> environment variable to point to the <code>vdw_kernel.bindat</code> file distributed with VASP. We recommend including this in your <code>~/.bashrc</code> file since this rarely changes.</li> </ul> <p>To run VASP with Custodian (which is the default behavior), you will also need to modify the relevant quacc configuration settings, most notably:</p> <ul> <li>Define the <code>VASP_PARALLEL_CMD</code> quacc setting that tells Custodian how to parallelize VASP, such as by defining an environment variable <code>QUACC_VASP_PARALLEL_CMD=\"srun -N 2 --ntasks-per-node 24\"</code>. Note, the VASP executables are not included in this environment variable.</li> </ul>"},{"location":"install/install.html","title":"Installation","text":""},{"location":"install/install.html#pre-requisites","title":"Pre-Requisites","text":"<p>Note</p> <p>If you are on a Windows machine, we recommend using the Windows Subsystem for Linux (WSL) to benefit from all the features of quacc.</p> <ol> <li>Install Python, preferably in conjunction with an environment manager. For instance, download and run the Miniconda installer</li> <li>When asked to add Miniconda to your <code>PATH</code>, select yes</li> <li>Create a fresh Python environment by running <code>conda create -n quacc python=3.10</code></li> <li>Activate this environment via <code>conda activate quacc</code></li> </ol>"},{"location":"install/install.html#installing-quacc","title":"Installing quacc","text":"<p>In your newly activated conda environment, run the following commands to install quacc. Note that you will need to install quacc on all machines where you plan to run calculations.</p> <p>For the latest PyPI release:</p> <pre><code># Install development version of ASE\npip install --no-cache-dir https://gitlab.com/ase/ase/-/archive/master/ase-master.zip\n\n# Install quacc\npip install quacc\n</code></pre> <p>For the development version:</p> <pre><code># Install development version of ASE\npip install --no-cache-dir https://gitlab.com/ase/ase/-/archive/master/ase-master.zip\n\n# Install development version of quacc\npip install git+https://github.com/quantum-accelerators/quacc.git\n</code></pre>"},{"location":"install/wflow_engines.html","title":"Workflow Engine Setup","text":"<p>Using a workflow engine is a crucial component for scaling up quacc calculations in a high-throughput setting. We describe the necessary installation steps here for the workflow manager of your choosing.</p> <p>Tip</p> <p>For a comparison of the different compatible workflow engines, refer to the Workflow Engines Overview section.</p> Parsl \u2b50Covalent \u2b50PrefectRedunJobflow <p>Installation</p> <p>To install Parsl, run the following:</p> <pre><code>pip install quacc[parsl]\n</code></pre> <p>Parsl has many configuration options, which we will cover later in the documentation.</p> <p>Installation</p> <p>To install Covalent, run</p> <pre><code>pip install quacc[covalent]\n</code></pre> <p>Starting the Server</p> <p>Covalent uses a server to dispatch and store calculation details and results. To start the server, simply run <code>covalent start</code> in your terminal. It will return a URL (usually http://localhost:48008) that you can use to access the Covalent dashboard, which is shown below.</p> <p></p> <p>Tip</p> <p>Once you start scaling up your calculations, we recommend hosting the Covalent server on a dedicated machine or using Covalent Cloud. Refer to the Covalent Deployment Guide for details.</p> <p>Note</p> <p>If you are using Perlmutter at NERSC, you will need to adjust the Covalent configuration directory because the home directory does not support file locking:</p> ~/.bashrc<pre><code>export COVALENT_CONFIG_DIR=\"$SCRATCH/.config/covalent\"\n</code></pre> <p>To install Prefect, run the following:</p> <pre><code>pip install quacc[prefect]\n</code></pre> <p>To use quacc with Prefect Cloud (recommended):</p> <ol> <li>Make an account on Prefect Cloud</li> <li>Make an API Key and (optionally) store it in a <code>PREFECT_API_KEY</code> environment variable (e.g. in your <code>~/.bashrc</code>)</li> <li>Run <code>prefect cloud login</code> from the command-line and enter your API key (or use the browser, if possible)</li> </ol> <p>Additional configuration parameters can be modified, as described in the Prefect documentation.</p> <p>Installation</p> <p>To install Redun, run the following:</p> <pre><code>pip install quacc[redun]\n</code></pre> <p>Installation</p> <p>To install Jobflow with support for FireWorks, run the following:</p> <pre><code>pip install quacc[jobflow]\n</code></pre> <p>MongoDB Setup</p> <p>Jobflow and FireWorks both require the use of a database (most commonly a MongoDB instance) to store calculation results.</p> <p>Note</p> <p>If it is not possible to use MongoDB, you can use a variety of other data store options available within the maggma package, including a <code>MontyStore</code> that solely relies on the local filesystem.</p> <p>Jobflow DB Setup</p> <p>If you plan to use Jobflow to write your workflows, you will need to make a <code>jobflow.yaml</code> file. This file will generally be formatted like the example below. Fill in the fields with the appropriate values for your MongoDB cluster, which is where all your calculation inputs and outputs will be stored.</p> jobflow.yaml<pre><code>JOB_STORE:\n  docs_store:\n    type: MongoStore\n    host: &lt;host name&gt;\n    port: 27017\n    username: &lt;username&gt;\n    password: &lt;password&gt;\n    database: &lt;database name&gt;\n    collection_name: &lt;collection name&gt;\n</code></pre> <p>Note</p> <p>If you are using a URI (as is common with MongoDB Atlas), then you will instead have a <code>jobflow.yaml</code> file that looks like the example below. Here, you will put the full URI in the <code>host</code> field. The <code>username</code> and <code>password</code> are part of the URI and so should not be included elsewhere in the YAML file.</p> jobflow.yaml<pre><code>JOB_STORE:\n  docs_store:\n    type: MongoStore\n    host: &lt;URI&gt;\n    port: 27017\n    database: &lt;database name&gt;\n    collection_name: &lt;collection name&gt;\n</code></pre> <p>You will then need to define a <code>JOBFLOW_CONFIG_FILE</code> environment variable pointing to the file you made. For instance, in your <code>~/.bashrc</code> file, add the following line:</p> <pre><code>export JOBFLOW_CONFIG_FILE=\"/path/to/my/jobflow.yaml\"\n</code></pre> <p>FireWorks DB Setup</p> <p>If you plan to use FireWorks to dispatch your Jobflow workflows, you will also need to make a few configuration files: <code>FW_config.yaml</code>, <code>my_fworker.yaml</code>, <code>my_launchpad.yaml</code>, and <code>my_qadapter.yaml</code>. To begin, make a directory called <code>fw_config</code> where you will store the four files described in greater detail below. The directory structure will look like the following:</p> <pre><code>fw_config\n\u251c\u2500\u2500 FW_config.yaml\n\u251c\u2500\u2500 my_fworker.yaml\n\u251c\u2500\u2500 my_launchpad.yaml\n\u2514\u2500\u2500 my_qadapter.yaml\n</code></pre> <p>FW Config File</p> <p>For the <code>FW_config.yaml</code>, you can use the following template. Make sure to update the path to the <code>fw_config</code> folder where the file resides.</p> FW_config.yaml<pre><code>CONFIG_FILE_DIR: &lt;/path/to/fw_config&gt;\nQUEUE_UPDATE_INTERVAL: 2\n</code></pre> <p>You will also need to define a <code>FW_CONFIG_FILE</code> environment variable pointing to the <code>FW_config.yaml</code> file you made. For instance, in your <code>~/.bashrc</code> file, add the following line:</p> <pre><code>export FW_CONFIG_FILE=\"/path/to/config/fw_config/FW_config.yaml\"\n</code></pre> <p>FWorker</p> <p>For the <code>my_fworker.yaml</code>, you can use the following template. You do not need to make any modifications.</p> my_fworker.yaml<pre><code>name: quacc_fworker\ncategory: \"\"\nquery: \"{}\"\n</code></pre> <p>Launchpad</p> <p>For the <code>my_launchpad.yaml</code>, you can use the following template. Replace the entries in <code>&lt;&gt;</code> with the appropriate values for your Mongo database.</p> my_launchpad.yaml<pre><code>host: &lt;host name&gt;\nport: 27017\nname: &lt;database name&gt;\nusername: &lt;username&gt;\npassword: &lt;password&gt;\nlogdir: null\nIstrm_lvl: DEBUG\nuser_indices: []\nwf_user_indices: []\n</code></pre> <p>Note</p> <p>If you are accessing your MongoDB via a URI (e.g. as with MongoDB Atlas), then you will use the following <code>my_launchpad.yaml</code> template instead.</p> my_launchpad.yaml<pre><code>host: &lt;URI&gt;\nport: 27017\nname: &lt;database name&gt;\nuri_store: true\nlogdir: null\nIstrm_lvl: DEBUG\nuser_indices: []\nwf_user_indices: []\n</code></pre> <p>QAdapter</p> <p>Assuming you plan to use a queuing system for your compute jobs, you will need to make a <code>my_qadapter.yaml</code> file. For this, you will need to follow the instructions in the FireWorks documentation for your specific job scheduling system. An example <code>my_qadapter.yaml</code> file is shown below for Slurm.</p> my_qadapter.yaml<pre><code>_fw_name: CommonAdapter\n_fw_q_type: SLURM\nrocket_launch: rlaunch -w /path/to/fw_config/my_fworker.yaml singleshot\nnodes: 2\nwalltime: 00:30:00\naccount: &lt;account&gt;\njob_name: quacc_firework\nqos: regular\npre_rocket: |\nmodule load MyModuleName\nexport MyEnvVar=MyEnvValue\n</code></pre> <p>In the above example, you would need to change the path in the <code>rocket_launch</code> field to the correct path to your <code>my_fworker.yaml</code>. The nodes, walltime, account, and qos are the corresponding parameters for your queuing system. Finally, anything in the <code>pre_rocket</code> field will be executed before the job begins running. It is a good place to load modules and set environment variables. A representative example has been provided above.</p> <p>Database Initialization</p> <p>Warning</p> <p>Running <code>lpad reset</code> will clear your FireWorks launchpad, so only use this command if you are a new user.</p> <p>To check that FireWorks can connect to your database, run <code>lpad reset</code> if this is your first time using FireWorks.</p>"},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>quacc<ul> <li>atoms<ul> <li>core</li> <li>defects</li> <li>slabs</li> </ul> </li> <li>builders<ul> <li>thermo</li> </ul> </li> <li>calculators<ul> <li>custodian<ul> <li>qchem</li> <li>vasp</li> </ul> </li> <li>qchem</li> <li>vasp</li> </ul> </li> <li>recipes<ul> <li>dftb<ul> <li>core</li> </ul> </li> <li>emt<ul> <li>core</li> <li>defects</li> <li>slabs</li> </ul> </li> <li>gaussian<ul> <li>core</li> </ul> </li> <li>gulp<ul> <li>core</li> </ul> </li> <li>lj<ul> <li>core</li> </ul> </li> <li>newtonnet<ul> <li>core</li> <li>ts</li> </ul> </li> <li>orca<ul> <li>core</li> </ul> </li> <li>psi4<ul> <li>core</li> </ul> </li> <li>qchem<ul> <li>core</li> <li>ts</li> </ul> </li> <li>tblite<ul> <li>core</li> </ul> </li> <li>vasp<ul> <li>core</li> <li>mp</li> <li>qmof</li> <li>slabs</li> </ul> </li> </ul> </li> <li>runners<ul> <li>calc</li> <li>prep</li> </ul> </li> <li>schemas<ul> <li>ase</li> <li>atoms</li> <li>cclib</li> <li>vasp</li> </ul> </li> <li>utils<ul> <li>dicts</li> <li>files</li> </ul> </li> <li>wflow<ul> <li>db</li> <li>decorators</li> <li>prefect</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/quacc/atoms/core.html","title":"core","text":"<p>Utility functions for dealing with Atoms</p>"},{"location":"reference/quacc/atoms/core.html#quacc.atoms.core.check_charge_and_spin","title":"check_charge_and_spin","text":"<pre><code>check_charge_and_spin(\n    atoms, charge=None, spin_multiplicity=None\n)\n</code></pre> <p>Check the validity of a given <code>charge</code> and <code>multiplicity</code>. If they are <code>None</code>, then set the charge and/or spin multiplicity of a molecule using the following routine, raising a <code>ValueError</code> if there is an incompatibility.</p> <p>Charges:</p> <ol> <li> <p>If <code>charge</code> is specified, that is the charge.</p> </li> <li> <p>If <code>atoms.charge</code> is present, that is the charge.</p> </li> <li> <p>If <code>atoms.has(\"initial_charges\")</code>, then <code>atoms.get_initial_charges.sum()</code> is the charge.</p> </li> <li> <p>If <code>spin_multiplicity</code> is set, set the charge to the smallest physically possible value.</p> </li> <li> <p>Otherwise, set to 0.</p> </li> </ol> <p>Spin multiplicity:</p> <ol> <li> <p>If <code>spin_multiplicity</code> is specified, that is the spin multiplicity.</p> </li> <li> <p>If <code>atoms.spin_multiplicity</code> is present, that is the spin multiplicity.</p> </li> <li> <p>If <code>atoms.has(\"initial_magmoms\")</code>, then <code>np.abs(atoms.get_initial_magnetic_moments().sum())+1</code> is the spin multiplicity.</p> </li> <li> <p>If none of the above, use Pymatgen to identify the lowest physically possible spin multiplicity given the number of electrons and the charge, if set.</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>charge</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Molecular charge</p> </li> <li> <code>spin_multiplicity</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Molecular multiplicity</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>(charge, multiplicity)</code>         \u2013          </li> </ul> Source code in <code>quacc/atoms/core.py</code> <pre><code>def check_charge_and_spin(\n    atoms: Atoms,\n    charge: int | None = None,\n    spin_multiplicity: int | None = None,\n) -&gt; tuple[int, int]:\n    \"\"\"\n    Check the validity of a given `charge` and `multiplicity`. If they are `None`, then\n    set the charge and/or spin multiplicity of a molecule using the following routine,\n    raising a `ValueError` if there is an incompatibility.\n\n    Charges:\n\n    1. If `charge` is specified, that is the charge.\n\n    2. If `atoms.charge` is present, that is the charge.\n\n    3. If `atoms.has(\"initial_charges\")`, then\n    `atoms.get_initial_charges.sum()` is the charge.\n\n    4. If `spin_multiplicity` is set, set the charge to the smallest physically\n    possible value.\n\n    5. Otherwise, set to 0.\n\n    Spin multiplicity:\n\n    1. If `spin_multiplicity` is specified, that is the spin multiplicity.\n\n    2. If `atoms.spin_multiplicity` is present, that is the spin multiplicity.\n\n    3. If `atoms.has(\"initial_magmoms\")`, then\n    `np.abs(atoms.get_initial_magnetic_moments().sum())+1` is the spin\n    multiplicity.\n\n    4. If none of the above, use Pymatgen to identify the lowest physically\n    possible spin multiplicity given the number of electrons and the charge, if\n    set.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Molecular charge\n    spin_multiplicity\n        Molecular multiplicity\n\n    Returns\n    -------\n    charge, multiplicity\n\n    \"\"\"\n\n    charge = (\n        charge\n        if charge is not None\n        else atoms.charge\n        if getattr(atoms, \"charge\", None)\n        else round(atoms.get_initial_charges().sum())\n        if atoms.has(\"initial_charges\")\n        else None\n    )\n\n    spin_multiplicity = (\n        spin_multiplicity\n        if spin_multiplicity is not None\n        else atoms.spin_multiplicity\n        if getattr(atoms, \"spin_multiplicity\", None)\n        else round(np.abs(atoms.get_initial_magnetic_moments().sum()) + 1)\n        if atoms.has(\"initial_magmoms\")\n        else None\n    )\n\n    if charge is None and spin_multiplicity is not None:\n        charge = 0\n\n    try:\n        mol = AseAtomsAdaptor.get_molecule(atoms)\n        if charge is not None:\n            if spin_multiplicity is not None:\n                mol.set_charge_and_spin(charge, spin_multiplicity)\n            else:\n                mol.set_charge_and_spin(charge)\n    except ValueError:\n        mol = AseAtomsAdaptor.get_molecule(atoms, charge_spin_check=False)\n        nelectrons = mol.nelectrons - charge if charge else mol.nelectrons\n        default_spin_multiplicity = 1 if nelectrons % 2 == 0 else 2\n        mol.set_charge_and_spin(\n            charge if charge is not None else mol.charge,\n            spin_multiplicity\n            if spin_multiplicity is not None\n            else default_spin_multiplicity,\n        )\n    if (mol.nelectrons + mol.spin_multiplicity) % 2 != 1:\n        raise ValueError(\n            f\"Charge of {mol.charge} and spin multiplicity of {mol.spin_multiplicity} is\"\n            \" not possible for this molecule.\"\n        )\n    logger.info(\n        f\"Setting charge to {mol.charge} and spin multiplicity to {mol.spin_multiplicity}\"\n    )\n\n    return mol.charge, mol.spin_multiplicity\n</code></pre>"},{"location":"reference/quacc/atoms/core.html#quacc.atoms.core.check_is_metal","title":"check_is_metal","text":"<pre><code>check_is_metal(atoms)\n</code></pre> <p>Checks if a structure is a likely metal.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True if the structure is likely a metal; False otherwise</p> </li> </ul> Source code in <code>quacc/atoms/core.py</code> <pre><code>def check_is_metal(atoms: Atoms) -&gt; bool:\n    \"\"\"\n    Checks if a structure is a likely metal.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n\n    Returns\n    -------\n    bool\n        True if the structure is likely a metal; False otherwise\n    \"\"\"\n    if atoms.pbc.any():\n        struct = AseAtomsAdaptor.get_structure(atoms)\n    else:\n        struct = AseAtomsAdaptor.get_molecule(atoms)\n\n    return all(k.is_metal for k in struct.composition)\n</code></pre>"},{"location":"reference/quacc/atoms/core.html#quacc.atoms.core.copy_atoms","title":"copy_atoms","text":"<pre><code>copy_atoms(atoms)\n</code></pre> <p>Simple function to copy an atoms object to prevent mutability.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>atoms</code>         \u2013          <p>Atoms object</p> </li> </ul> Source code in <code>quacc/atoms/core.py</code> <pre><code>def copy_atoms(atoms: Atoms) -&gt; Atoms:\n    \"\"\"\n    Simple function to copy an atoms object to prevent mutability.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n\n    Returns\n    -------\n    atoms\n        Atoms object\n    \"\"\"\n    try:\n        atoms = deepcopy(atoms)\n    except Exception:\n        # Needed because of ASE issue #1084\n        calc = atoms.calc\n        atoms = atoms.copy()\n        atoms.calc = calc\n\n    return atoms\n</code></pre>"},{"location":"reference/quacc/atoms/core.html#quacc.atoms.core.get_atoms_id","title":"get_atoms_id","text":"<pre><code>get_atoms_id(atoms)\n</code></pre> <p>Returns a unique ID for the Atoms object. Note: The .info dict and calculator is excluded from the hash generation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>md5hash</code>         \u2013          <p>MD5 hash of the Atoms object</p> </li> </ul> Source code in <code>quacc/atoms/core.py</code> <pre><code>def get_atoms_id(atoms: Atoms) -&gt; str:\n    \"\"\"\n    Returns a unique ID for the Atoms object. Note: The .info dict and\n    calculator is excluded from the hash generation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n\n    Returns\n    -------\n    md5hash\n        MD5 hash of the Atoms object\n    \"\"\"\n\n    atoms = copy_atoms(atoms)\n    atoms.info = {}\n    atoms.calc = None\n    encoded_atoms = encode(atoms)\n    # This is a hack to avoid int32/int64 and float32/float64 differences\n    # between machines.\n    encoded_atoms = (\n        encoded_atoms.replace(\"int64\", \"int\")\n        .replace(\"int32\", \"int\")\n        .replace(\"float64\", \"float\")\n        .replace(\"float32\", \"float\")\n    )\n\n    return hashlib.md5(encoded_atoms.encode(\"utf-8\")).hexdigest()\n</code></pre>"},{"location":"reference/quacc/atoms/defects.html","title":"defects","text":"<p>Utility functions for dealing with defects</p>"},{"location":"reference/quacc/atoms/defects.html#quacc.atoms.defects.make_defects_from_bulk","title":"make_defects_from_bulk","text":"<pre><code>make_defects_from_bulk(\n    atoms,\n    defect_gen=VacancyGenerator,\n    defect_charge=0,\n    sc_mat=None,\n    min_atoms=80,\n    max_atoms=240,\n    min_length=10.0,\n    force_diagonal=False,\n    **defect_gen_kwargs\n)\n</code></pre> <p>Function to make defects from a bulk atoms object.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>bulk atoms</p> </li> <li> <code>defect_gen</code>             (<code>AntiSiteGenerator | ChargeInterstitialGenerator | InterstitialGenerator | SubstitutionGenerator | VacancyGenerator | VoronoiInterstitialGenerator</code>, default:                 <code>VacancyGenerator</code> )         \u2013          <p>defect generator</p> </li> <li> <code>sc_mat</code>             (<code>NDArray | None</code>, default:                 <code>None</code> )         \u2013          <p>supercell matrix</p> </li> <li> <code>min_atoms</code>             (<code>int</code>, default:                 <code>80</code> )         \u2013          <p>minimum number of atoms in supercell</p> </li> <li> <code>max_atoms</code>             (<code>int</code>, default:                 <code>240</code> )         \u2013          <p>maximum number of atoms in supercell</p> </li> <li> <code>min_length</code>             (<code>float</code>, default:                 <code>10.0</code> )         \u2013          <p>minimum length of supercell</p> </li> <li> <code>force_diagonal</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>force supercell to be diagonal</p> </li> <li> <code>defect_charge</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>charge state of defect</p> </li> <li> <code>**defect_gen_kwargs</code>         \u2013          <p>keyword arguments to pass to the pymatgen.analysis.defects.generators get_defects() method</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Atoms]</code>         \u2013          <p>All generated defects</p> </li> </ul> Source code in <code>quacc/atoms/defects.py</code> <pre><code>def make_defects_from_bulk(\n    atoms: Atoms,\n    defect_gen: (\n        AntiSiteGenerator\n        | ChargeInterstitialGenerator\n        | InterstitialGenerator\n        | SubstitutionGenerator\n        | VacancyGenerator\n        | VoronoiInterstitialGenerator\n    ) = VacancyGenerator,\n    defect_charge: int = 0,\n    sc_mat: NDArray | None = None,\n    min_atoms: int = 80,\n    max_atoms: int = 240,\n    min_length: float = 10.0,\n    force_diagonal: bool = False,\n    **defect_gen_kwargs,\n) -&gt; list[Atoms]:\n    \"\"\"\n    Function to make defects from a bulk atoms object.\n\n    Parameters\n    ----------\n    atoms\n        bulk atoms\n    defect_gen\n        defect generator\n    sc_mat\n        supercell matrix\n    min_atoms\n        minimum number of atoms in supercell\n    max_atoms\n        maximum number of atoms in supercell\n    min_length\n        minimum length of supercell\n    force_diagonal\n        force supercell to be diagonal\n    defect_charge\n        charge state of defect\n    **defect_gen_kwargs\n        keyword arguments to pass to the pymatgen.analysis.defects.generators\n        get_defects() method\n\n    Returns\n    -------\n    list[Atoms]\n        All generated defects\n    \"\"\"\n\n    # Use pymatgen-analysis-defects and ShakeNBreak to generate defects\n    struct = AseAtomsAdaptor.get_structure(atoms)\n\n    # Make all the defects\n    defects = defect_gen().get_defects(struct, **defect_gen_kwargs)\n    final_defects = []\n    for defect in defects:\n        defect.user_charges = [defect_charge]\n\n        # Generate the supercell for a defect\n        defect_supercell = defect.get_supercell_structure(\n            sc_mat=sc_mat,\n            dummy_species=DummySpecies(),\n            min_atoms=min_atoms,\n            max_atoms=max_atoms,\n            min_length=min_length,\n            force_diagonal=force_diagonal,\n        )\n\n        # Generate DefectEntry object from Defect object\n        defect_entry = _get_defect_entry_from_defect(\n            defect=defect,\n            defect_supercell=defect_supercell,\n            defect_charge=defect_charge,\n        )\n\n        # Instantiate class to apply rattle and bond distortion to all defects\n        Dist = Distortions([defect_entry])\n\n        # Apply rattle and bond distortion to all defects\n        defect_dict, distortion_metadata = Dist.apply_distortions()\n        defect_symbol = next(iter(distortion_metadata[\"defects\"].keys()))\n        distortion_dict = defect_dict[defect_symbol][\"charges\"][defect_charge][\n            \"structures\"\n        ][\"distortions\"]\n\n        # Make atoms objects and store defect stats\n        for distortions, defect_struct in distortion_dict.items():\n            final_defect = AseAtomsAdaptor.get_atoms(defect_struct)\n            defect_stats = {\n                \"defect_symbol\": defect_symbol,\n                \"defect_charge\": defect_charge,\n                \"distortions\": distortions,\n                \"bulk\": atoms,\n                \"defect\": defect,\n            }\n            final_defect.info[\"defect_stats\"] = defect_stats\n            final_defects.append(final_defect)\n    return final_defects\n</code></pre>"},{"location":"reference/quacc/atoms/slabs.html","title":"slabs","text":"<p>Utility functions for dealing with slabs</p>"},{"location":"reference/quacc/atoms/slabs.html#quacc.atoms.slabs.flip_atoms","title":"flip_atoms","text":"<pre><code>flip_atoms(atoms, return_struct=False)\n</code></pre> <p>Convenience function for vertically flipping periodic atoms or structures</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | Structure | Slab</code>)         \u2013          <p>Atoms/.Structure to flip</p> </li> <li> <code>return_struct</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>True if a Pymatgen structure object should be returned. False if an ASE atoms object should be returned</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms | Structure | Slab</code>         \u2013          <p>Inverted slab</p> </li> </ul> Source code in <code>quacc/atoms/slabs.py</code> <pre><code>def flip_atoms(\n    atoms: Atoms | Structure | Slab, return_struct: bool = False\n) -&gt; Atoms | Structure | Slab:\n    \"\"\"\n    Convenience function for vertically flipping periodic atoms or structures\n\n    Parameters\n    ----------\n    atoms\n        Atoms/.Structure to flip\n    return_struct\n        True if a Pymatgen structure object should be returned. False if an ASE\n        atoms object should be returned\n\n    Returns\n    -------\n    Atoms | Structure | Slab\n        Inverted slab\n    \"\"\"\n\n    if isinstance(atoms, Atoms):\n        new_atoms = copy_atoms(atoms)\n    else:\n        new_atoms = AseAtomsAdaptor.get_atoms(atoms)\n\n    new_atoms.rotate(180, \"x\")\n    new_atoms.wrap()\n\n    if return_struct:\n        new_atoms = AseAtomsAdaptor.get_structure(new_atoms)\n\n    return new_atoms\n</code></pre>"},{"location":"reference/quacc/atoms/slabs.html#quacc.atoms.slabs.get_surface_energy","title":"get_surface_energy","text":"<pre><code>get_surface_energy(bulk, slab, bulk_energy, slab_energy)\n</code></pre> <p>Calculate the surface energy to form a given surface slab from a bulk structure. For asymmetric slabs, this is better thought of as the cleavage energy.</p> <p>Parameters:</p> <ul> <li> <code>bulk</code>             (<code>Atoms</code>)         \u2013          <p>The bulk structure.</p> </li> <li> <code>slab</code>             (<code>Atoms</code>)         \u2013          <p>The slab structure.</p> </li> <li> <code>bulk_energy</code>             (<code>float</code>)         \u2013          <p>The total energy of the bulk structure.</p> </li> <li> <code>slab_energy</code>             (<code>float</code>)         \u2013          <p>The total energy of the slab structure.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>floating</code>         \u2013          <p>The surface energy in eV/A^2.</p> </li> </ul> Source code in <code>quacc/atoms/slabs.py</code> <pre><code>def get_surface_energy(\n    bulk: Atoms, slab: Atoms, bulk_energy: float, slab_energy: float\n) -&gt; np.floating:\n    \"\"\"\n    Calculate the surface energy to form a given surface slab from a bulk\n    structure. For asymmetric slabs, this is better thought of as the cleavage\n    energy.\n\n    Parameters\n    -----------\n    bulk\n        The bulk structure.\n    slab\n        The slab structure.\n    bulk_energy\n        The total energy of the bulk structure.\n    slab_energy\n        The total energy of the slab structure.\n\n    Returns\n    -------\n    np.floating\n        The surface energy in eV/A^2.\n    \"\"\"\n\n    alpha = len(slab) / len(bulk)\n    cell = slab.get_cell()\n    A = np.linalg.norm(np.cross(cell[0], cell[1]))\n    return (slab_energy - alpha * bulk_energy) / (2 * A)\n</code></pre>"},{"location":"reference/quacc/atoms/slabs.html#quacc.atoms.slabs.make_adsorbate_structures","title":"make_adsorbate_structures","text":"<pre><code>make_adsorbate_structures(\n    atoms,\n    adsorbate,\n    min_distance=2.0,\n    modes=None,\n    allowed_surface_symbols=None,\n    allowed_surface_indices=None,\n    ads_site_finder_kwargs=None,\n    find_ads_sites_kwargs=None,\n)\n</code></pre> <p>Add a single adsorbate to a structure for every requested adsorption mode</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>The atoms to add adsorbates to.</p> </li> <li> <code>adsorbate</code>             (<code>Atoms</code>)         \u2013          <p>The adsorbate to add. Note: It will be placed on the surface in the exact input orientation provided by the user (the adsorption mode is along the c axis and the coordinating atom is the one in the -z direction).</p> </li> <li> <code>min_distance</code>             (<code>float</code>, default:                 <code>2.0</code> )         \u2013          <p>The (minimum) distance to set between the adsorbate and the surface site.</p> </li> <li> <code>modes</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>The adsorption mode(s) to consider. Options include: \"ontop\", \"bridge\", \"hollow\", \"subsurface\".</p> </li> <li> <code>allowed_surface_symbols</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>The symbols of surface atoms to consider. If None, will use all surface atoms. Note: This method could be improved for bridge/hollow sites.</p> </li> <li> <code>allowed_surface_indices</code>             (<code>list[int] | None</code>, default:                 <code>None</code> )         \u2013          <p>The indices of surface atoms to consider. If None, will use all surface atoms. Generally used if a specific site is to be excluded from the set. Note: This method could be improved for bridge/hollow sites.</p> </li> <li> <code>ads_site_finder_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>The keyword arguments to pass to the AdsorbateSiteFinder().</p> </li> <li> <code>find_ads_sites_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>The keyword arguments to pass to AdsorbateSiteFinder.find_adsorption_sites().</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Atoms]</code>         \u2013          <p>The structures with adsorbates</p> </li> </ul> Source code in <code>quacc/atoms/slabs.py</code> <pre><code>def make_adsorbate_structures(\n    atoms: Atoms,\n    adsorbate: Atoms,\n    min_distance: float = 2.0,\n    modes: list[str] | None = None,\n    allowed_surface_symbols: list[str] | None = None,\n    allowed_surface_indices: list[int] | None = None,\n    ads_site_finder_kwargs: dict | None = None,\n    find_ads_sites_kwargs: dict | None = None,\n) -&gt; list[Atoms]:\n    \"\"\"\n    Add a single adsorbate to a structure for every requested adsorption mode\n\n    Parameters\n    ----------\n    atoms\n        The atoms to add adsorbates to.\n    adsorbate\n        The adsorbate to add. Note: It will be placed on the surface in the\n        exact input orientation provided by the user (the adsorption mode is\n        along the c axis and the coordinating atom is the one in the -z\n        direction).\n    min_distance\n        The (minimum) distance to set between the adsorbate and the surface\n        site.\n    modes\n        The adsorption mode(s) to consider. Options include: \"ontop\", \"bridge\",\n        \"hollow\", \"subsurface\".\n    allowed_surface_symbols\n        The symbols of surface atoms to consider. If None, will use all surface\n        atoms. Note: This method could be improved for bridge/hollow sites.\n    allowed_surface_indices\n        The indices of surface atoms to consider. If None, will use all surface\n        atoms. Generally used if a specific site is to be excluded from the set.\n        Note: This method could be improved for bridge/hollow sites.\n    ads_site_finder_kwargs\n        The keyword arguments to pass to the AdsorbateSiteFinder().\n    find_ads_sites_kwargs\n        The keyword arguments to pass to\n        AdsorbateSiteFinder.find_adsorption_sites().\n\n    Returns\n    --------\n    list[Atoms]\n        The structures with adsorbates\n\n    \"\"\"\n    atoms = copy_atoms(atoms)\n\n    if modes is None:\n        modes = [\"ontop\", \"bridge\", \"hollow\"]\n\n    ads_site_finder_kwargs = ads_site_finder_kwargs or {}\n    find_ads_sites_kwargs = find_ads_sites_kwargs or {}\n\n    # Check for double-used parameters\n    if min_distance and \"distance\" in find_ads_sites_kwargs:\n        msg = \"Cannot specify both min_distance and find_ads_sites_kwargs['distance']\"\n        raise ValueError(msg)\n    if modes and \"positions\" in find_ads_sites_kwargs:\n        msg = \"Cannot specify both modes and find_ads_sites_kwargs['positions']\"\n        raise ValueError(msg)\n    find_ads_sites_kwargs[\"distance\"] = min_distance\n    find_ads_sites_kwargs[\"positions\"] = [mode.lower() for mode in modes]\n\n    # Check the provided surface indices are reasonable\n    atom_indices = [atom.index for atom in atoms]\n    if allowed_surface_indices and any(\n        idx not in atom_indices for idx in allowed_surface_indices\n    ):\n        msg = \"All indices in allowed_surface_indices must be in atoms.\"\n        raise ValueError(msg, allowed_surface_indices, atom_indices)\n\n    # Add 0.0 initial magmoms to atoms/adsorbate if needed\n    if atoms.has(\"initial_magmoms\") and not adsorbate.has(\"initial_magmoms\"):\n        adsorbate.set_initial_magnetic_moments([0.0] * len(adsorbate))\n    if adsorbate.has(\"initial_magmoms\") and not atoms.has(\"initial_magmoms\"):\n        atoms.set_initial_magnetic_moments([0.0] * len(atoms))\n\n    # Make a Pymatgen structure and molecule\n    struct = AseAtomsAdaptor.get_structure(atoms)\n    mol = AseAtomsAdaptor.get_molecule(adsorbate, charge_spin_check=False)\n\n    # Get the adsorption sites\n    ads_finder = AdsorbateSiteFinder(struct, **ads_site_finder_kwargs)\n    ads_sites = ads_finder.find_adsorption_sites(**find_ads_sites_kwargs)\n\n    # Find and add the adsorbates\n    new_atoms = []\n    for mode, ads_coords in ads_sites.items():\n        # Check if mode is in desired list\n        if mode not in modes:\n            continue\n\n        for ads_coord in ads_coords:\n            # Place adsorbate\n            struct_with_adsorbate = ads_finder.add_adsorbate(mol, ads_coord)\n\n            # Convert back to Atoms object\n            atoms_with_adsorbate = AseAtomsAdaptor.get_atoms(struct_with_adsorbate)\n\n            # Get distance matrix between adsorbate binding atom and surface\n            d = atoms_with_adsorbate.get_all_distances(mic=True)[\n                0 : len(atoms), len(atoms) :\n            ]\n\n            # Find closest surface atoms\n            min_d = np.min(d)\n            surface_atom_indices = np.where(\n                (d &gt;= min_d - min_d * 0.1) &amp; (d &lt;= min_d + min_d * 0.1)\n            )[0]\n\n            surface_atom_symbols = atoms_with_adsorbate[\n                surface_atom_indices\n            ].get_chemical_symbols()\n\n            # Check if surface binding site is not in the specified user list.\n            # If so, skip this one\n            if allowed_surface_symbols and all(\n                surface_atom_symbol not in allowed_surface_symbols\n                for surface_atom_symbol in surface_atom_symbols\n            ):\n                continue\n\n            if allowed_surface_indices and all(\n                surface_atom_idx not in allowed_surface_indices\n                for surface_atom_idx in surface_atom_indices\n            ):\n                continue\n\n            # Store adsorbate info\n            atoms_with_adsorbate.info = atoms.info.copy()\n            ads_stats = {\n                \"adsorbate\": adsorbate,\n                \"initial_mode\": mode,\n                \"surface_atoms_symbols\": surface_atom_symbols,\n                \"surface_atoms_indices\": surface_atom_indices,\n            }\n            if atoms_with_adsorbate.info.get(\"adsorbates\", None) is None:\n                atoms_with_adsorbate.info[\"adsorbates\"] = [ads_stats]\n            else:\n                atoms_with_adsorbate.info[\"adsorbates\"].extend([ads_stats])\n\n            # Add slab+adsorbate to list\n            new_atoms.append(atoms_with_adsorbate)\n\n    return new_atoms\n</code></pre>"},{"location":"reference/quacc/atoms/slabs.html#quacc.atoms.slabs.make_slabs_from_bulk","title":"make_slabs_from_bulk","text":"<pre><code>make_slabs_from_bulk(\n    atoms,\n    max_index=1,\n    min_slab_size=10.0,\n    min_length_width=8.0,\n    min_vacuum_size=20.0,\n    z_fix=2.0,\n    flip_asymmetric=True,\n    allowed_surface_symbols=None,\n    **slabgen_kwargs\n)\n</code></pre> <p>Function to make slabs from a bulk atoms object.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>bulk atoms</p> </li> <li> <code>max_index</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Maximum Miller index for slab generation</p> </li> <li> <code>min_slab_size</code>             (<code>float</code>, default:                 <code>10.0</code> )         \u2013          <p>Minimum slab size (depth) in angstroms</p> </li> <li> <code>min_length_width</code>             (<code>float</code>, default:                 <code>8.0</code> )         \u2013          <p>Minimum length and width of the slab in angstroms</p> </li> <li> <code>min_vacuum_size</code>             (<code>float</code>, default:                 <code>20.0</code> )         \u2013          <p>Minimum vacuum size in angstroms</p> </li> <li> <code>z_fix</code>             (<code>float | None</code>, default:                 <code>2.0</code> )         \u2013          <p>Distance (in angstroms) from top of slab for which atoms should be fixed</p> </li> <li> <code>flip_asymmetric</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If an asymmetric surface should be flipped and added to the list</p> </li> <li> <code>allowed_surface_symbols</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>List of chemical symbols that must be present on the surface of the slab otherwise the slab will be discarded, e.g. [\"Cu\", \"Ni\"]</p> </li> <li> <code>**slabgen_kwargs</code>         \u2013          <p><code>generate_all_slabs</code> function</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Atoms]</code>         \u2013          <p>All generated slabs</p> </li> </ul> Source code in <code>quacc/atoms/slabs.py</code> <pre><code>def make_slabs_from_bulk(\n    atoms: Atoms,\n    max_index: int = 1,\n    min_slab_size: float = 10.0,\n    min_length_width: float = 8.0,\n    min_vacuum_size: float = 20.0,\n    z_fix: float | None = 2.0,\n    flip_asymmetric: bool = True,\n    allowed_surface_symbols: list[str] | None = None,\n    **slabgen_kwargs,\n) -&gt; list[Atoms]:\n    \"\"\"\n    Function to make slabs from a bulk atoms object.\n\n    Parameters\n    ----------\n    atoms\n        bulk atoms\n    max_index\n        Maximum Miller index for slab generation\n    min_slab_size\n        Minimum slab size (depth) in angstroms\n    min_length_width\n        Minimum length and width of the slab in angstroms\n    min_vacuum_size\n        Minimum vacuum size in angstroms\n    z_fix\n        Distance (in angstroms) from top of slab for which atoms should be fixed\n    flip_asymmetric\n        If an asymmetric surface should be flipped and added to the list\n    allowed_surface_symbols\n        List of chemical symbols that must be present on the surface of the slab\n        otherwise the slab will be discarded, e.g. [\"Cu\", \"Ni\"]\n    **slabgen_kwargs: keyword arguments to pass to the pymatgen\n        `generate_all_slabs` function\n\n    Returns\n    -------\n    list[Atoms]\n        All generated slabs\n    \"\"\"\n\n    # Note: This will not work properly for 2D structures. See Oxana/Martin's\n    # code for adjustments for 2D:\n    # https://github.com/oxana-a/atomate/blob/ads_wf/atomate/vasp/firetasks/adsorption_tasks.py\n\n    # Use pymatgen to generate slabs\n    struct = AseAtomsAdaptor.get_structure(atoms)\n\n    # Make all the slabs\n    slabs = generate_all_slabs(\n        struct,\n        max_index,\n        min_slab_size,\n        min_vacuum_size,\n        center_slab=True,\n        **slabgen_kwargs,\n    )\n\n    # If the two terminations are not equivalent, make new slab by inverting the\n    # original slab and add it to the list\n    if flip_asymmetric:\n        new_slabs = []\n        for slab in slabs:\n            if not slab.is_symmetric():\n                # Flip the slab and its oriented unit cell\n                new_slab = flip_atoms(slab, return_struct=True)  # type: Slab\n                new_oriented_unit_cell = flip_atoms(\n                    slab.oriented_unit_cell, return_struct=True\n                )  # type: Slab\n\n                # Reconstruct the full slab object, noting the new shift and\n                # oriented unit cell\n                new_slab = Slab(\n                    new_slab.lattice,\n                    new_slab.species,\n                    coords=new_slab.frac_coords,\n                    miller_index=slab.miller_index,\n                    oriented_unit_cell=new_oriented_unit_cell,\n                    shift=-slab.shift,\n                    scale_factor=slab.scale_factor,\n                    site_properties=new_slab.site_properties,\n                )\n\n                # It looks better to center the inverted slab so we do that\n                # here.\n                new_slab = center_slab(new_slab)\n\n                # Add the new slab to the list\n                new_slabs.append(new_slab)\n\n        slabs.extend(new_slabs)\n\n    # For each slab, make sure the lengths and widths are large enough and fix\n    # atoms z_fix away from the top of the slab.\n    slabs_with_props = []\n    for slab in slabs:\n        # Make sure desired atoms are on surface\n        if allowed_surface_symbols:\n            # Find atoms at surface\n            surf_sites = AdsorbateSiteFinder(slab.copy()).surface_sites\n            surface_species = [s.specie.symbol for s in surf_sites]\n\n        if allowed_surface_symbols and all(\n            allowed_surface_atom not in surface_species\n            for allowed_surface_atom in allowed_surface_symbols\n        ):\n            continue\n\n        # Supercell creation (if necessary)\n        a_factor = round(np.ceil(min_length_width / slab.lattice.abc[0]))\n        b_factor = round(np.ceil(min_length_width / slab.lattice.abc[1]))\n        slab.make_supercell([a_factor, b_factor, 1])\n\n        # Add constraints. Note: This does not actually add an adsorbate\n        if z_fix:\n            sel_dyn = AdsorbateSiteFinder(\n                slab.copy(), selective_dynamics=True, height=z_fix\n            ).slab.site_properties[\"selective_dynamics\"]\n            slab.add_site_property(\"selective_dynamics\", sel_dyn)\n\n        # Add slab to list\n        slabs_with_props.append(slab)\n\n    final_slabs = []\n    if not slabs_with_props:\n        return final_slabs\n\n    # Make atoms objects and store slab stats\n    for slab_with_props in slabs_with_props:\n        final_slab = AseAtomsAdaptor.get_atoms(slab_with_props)\n        slab_stats = {\n            \"bulk\": atoms,\n            \"miller_index\": slab_with_props.miller_index,\n            \"shift\": round(slab_with_props.shift, 3),\n            \"scale_factor\": slab_with_props.scale_factor,\n        }\n        final_slab.info[\"slab_stats\"] = slab_stats\n        final_slabs.append(final_slab)\n\n    return final_slabs\n</code></pre>"},{"location":"reference/quacc/builders/thermo.html","title":"thermo","text":"<p>Utility functions for thermochemistry</p>"},{"location":"reference/quacc/builders/thermo.html#quacc.builders.thermo.build_ideal_gas","title":"build_ideal_gas","text":"<pre><code>build_ideal_gas(\n    atoms, vib_freqs, energy=0.0, spin_multiplicity=None\n)\n</code></pre> <p>Create an IdealGasThermo object for a molecule from a given vibrational analysis. This is for free gases only and will not be valid for solids or adsorbates on surfaces. Any imaginary vibrational modes after the 3N-5/3N-6 cut will simply be ignored.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>The Atoms object associated with the vibrational analysis.</p> </li> <li> <code>vib_freqs</code>             (<code>list[float | complex]</code>)         \u2013          <p>The list of vibrations to use in cm^-1, typically obtained from Vibrations.get_frequencies().</p> </li> <li> <code>energy</code>             (<code>float</code>, default:                 <code>0.0</code> )         \u2013          <p>Potential energy in eV. If 0 eV, then the thermochemical correction is computed.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The spin multiplicity (2S+1). If None, this will be determined automatically from the attached magnetic moments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>IdealGasThermo object</code>         \u2013          </li> </ul> Source code in <code>quacc/builders/thermo.py</code> <pre><code>def build_ideal_gas(\n    atoms: Atoms,\n    vib_freqs: list[float | complex],\n    energy: float = 0.0,\n    spin_multiplicity: int | None = None,\n) -&gt; IdealGasThermo:\n    \"\"\"\n    Create an IdealGasThermo object for a molecule from a given vibrational\n    analysis. This is for free gases only and will not be valid for solids or\n    adsorbates on surfaces. Any imaginary vibrational modes after the 3N-5/3N-6\n    cut will simply be ignored.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object associated with the vibrational analysis.\n    vib_freqs\n        The list of vibrations to use in cm^-1, typically obtained from\n        Vibrations.get_frequencies().\n    energy\n        Potential energy in eV. If 0 eV, then the thermochemical correction is\n        computed.\n    spin_multiplicity\n        The spin multiplicity (2S+1). If None, this will be determined\n        automatically from the attached magnetic moments.\n\n    Returns\n    -------\n    IdealGasThermo object\n    \"\"\"\n\n    # Switch off PBC since this is only for molecules\n    atoms.set_pbc(False)\n\n    # Ensure all negative modes are made complex\n    for i, f in enumerate(vib_freqs):\n        if not isinstance(f, complex) and f &lt; 0:\n            vib_freqs[i] = complex(0 - f * 1j)\n\n    # Convert vibrational frequencies to energies\n    vib_energies = [f * units.invcm for f in vib_freqs]\n\n    # Get the spin from the Atoms object.\n    if spin_multiplicity:\n        spin = (spin_multiplicity - 1) / 2\n    elif (\n        getattr(atoms, \"calc\", None) is not None\n        and getattr(atoms.calc, \"results\", None) is not None\n        and atoms.calc.results.get(\"magmom\", None) is not None\n    ):\n        spin = round(atoms.calc.results[\"magmom\"]) / 2\n    elif (\n        getattr(atoms, \"calc\", None) is not None\n        and getattr(atoms.calc, \"results\", None) is not None\n        and atoms.calc.results.get(\"magmoms\", None) is not None\n    ):\n        spin = round(np.sum(atoms.calc.results[\"magmoms\"])) / 2\n    elif atoms.has(\"initial_magmoms\"):\n        spin = round(np.sum(atoms.get_initial_magnetic_moments())) / 2\n    else:\n        spin = 0\n\n    # Get symmetry for later use\n    natoms = len(atoms)\n    metadata = atoms_to_metadata(atoms)\n\n    # Get the geometry\n    if natoms == 1:\n        geometry = \"monatomic\"\n    elif metadata[\"symmetry\"][\"linear\"]:\n        geometry = \"linear\"\n    else:\n        geometry = \"nonlinear\"\n\n    return IdealGasThermo(\n        vib_energies,\n        geometry,\n        potentialenergy=energy,\n        atoms=atoms,\n        symmetrynumber=metadata[\"symmetry\"][\"rotation_number\"],\n        spin=spin,\n        ignore_imag_modes=True,\n    )\n</code></pre>"},{"location":"reference/quacc/calculators/qchem.html","title":"qchem","text":"<p>A Q-Chem calculator built on Pymatgen and Custodian functionality</p>"},{"location":"reference/quacc/calculators/qchem.html#quacc.calculators.qchem.QChem","title":"QChem","text":"<pre><code>QChem(\n    atoms,\n    charge=0,\n    spin_multiplicity=1,\n    method=None,\n    basis_set=\"def2-tzvpd\",\n    job_type=\"force\",\n    scf_algorithm=\"diis\",\n    cores=1,\n    qchem_input_params=None,\n    **fileiocalculator_kwargs\n)\n</code></pre> <p>             Bases: <code>FileIOCalculator</code></p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>The Atoms object to be used for the calculation.</p> </li> <li> <code>cores</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Number of cores to use for the Q-Chem calculation.</p> </li> <li> <code>charge</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>The total charge of the molecular system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>The spin multiplicity of the molecular system.</p> </li> <li> <code>qchem_input_params</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of Q-Chem input parameters to be passed to pymatgen.io.qchem.sets.DictSet.</p> </li> <li> <code>**fileiocalculator_kwargs</code>         \u2013          <p>Additional arguments to be passed to ase.calculators.calculator.FileIOCalculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>         \u2013          <p>The ASE Atoms object with attached Q-Chem calculator. In calc.results, the following properties are set:</p> <ul> <li>energy: electronic energy in eV</li> <li>forces: forces in eV/A</li> <li>hessian: Hessian in native Q-Chem units</li> <li>entropy: total enthalpy in eV</li> <li>enthalpy: total entropy in eV/K</li> <li>qc_output: Output from <code>pymatgen.io.qchem.outputs.QCOutput.data</code></li> <li>qc_input: Input from <code>pymatgen.io.qchem.inputs.QCInput.as_dict()</code></li> <li>custodian: custodian.json file metadata</li> </ul> </li> </ul> Source code in <code>quacc/calculators/qchem.py</code> <pre><code>def __init__(\n    self,\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    method: str | None = None,\n    basis_set: str = \"def2-tzvpd\",\n    job_type: str = \"force\",\n    scf_algorithm: str = \"diis\",\n    cores: int = 1,\n    qchem_input_params: dict | None = None,\n    **fileiocalculator_kwargs,\n):\n    # Assign variables to self\n    self.atoms = atoms\n    self.cores = cores\n    self.charge = charge\n    self.spin_multiplicity = spin_multiplicity\n    self.job_type = job_type\n    self.basis_set = basis_set\n    self.scf_algorithm = scf_algorithm\n    self.qchem_input_params = qchem_input_params or {}\n    self.fileiocalculator_kwargs = fileiocalculator_kwargs\n\n    # Sanity checks\n    if \"directory\" in self.fileiocalculator_kwargs:\n        raise NotImplementedError(\"The directory kwarg is not supported.\")\n\n    if \"overwrite_inputs\" not in self.qchem_input_params:\n        self.qchem_input_params[\"overwrite_inputs\"] = {}\n\n    if self.qchem_input_params.get(\"smd_solvent\") and self.qchem_input_params.get(\n        \"pcm_dielectric\"\n    ):\n        raise ValueError(\"PCM and SMD cannot be employed simultaneously.\")\n\n    if \"rem\" not in self.qchem_input_params[\"overwrite_inputs\"]:\n        self.qchem_input_params[\"overwrite_inputs\"][\"rem\"] = {}\n    if (\n        method\n        and \"method\" not in self.qchem_input_params[\"overwrite_inputs\"][\"rem\"]\n    ):\n        self.qchem_input_params[\"overwrite_inputs\"][\"rem\"][\"method\"] = method\n\n    # We will save the parameters that have been passed to the Q-Chem\n    # calculator via FileIOCalculator's self.default_parameters\n    self.default_parameters = {\n        \"cores\": self.cores,\n        \"charge\": self.charge,\n        \"spin_multiplicity\": self.spin_multiplicity,\n        \"scf_algorithm\": self.scf_algorithm,\n        \"basis_set\": self.basis_set,\n    }\n\n    if method:\n        self.default_parameters[\"method\"] = method\n\n    # We also want to save the contents of self.qchem_input_params. However,\n    # the overwrite_inputs key will have a corresponding value which is\n    # either an empty dictionary or a nested dict of dicts, requiring a bit\n    # of careful unwrapping.\n    for key in self.qchem_input_params:\n        if key == \"overwrite_inputs\":\n            for subkey in self.qchem_input_params[key]:\n                for subsubkey in self.qchem_input_params[key][subkey]:\n                    self.default_parameters[\n                        f\"overwrite_{subkey}_{subsubkey}\"\n                    ] = self.qchem_input_params[key][subkey][subsubkey]\n        else:\n            self.default_parameters[key] = self.qchem_input_params[key]\n\n    # Get Q-Chem executable command\n    self.command = self._manage_environment()\n\n    # Instantiate previous orbital coefficients\n    self.prev_orbital_coeffs = None\n\n    # Instantiate the calculator\n    FileIOCalculator.__init__(\n        self,\n        restart=None,\n        ignore_bad_restart_file=FileIOCalculator._deprecated,\n        label=None,\n        atoms=self.atoms,\n        **self.fileiocalculator_kwargs,\n    )\n</code></pre>"},{"location":"reference/quacc/calculators/vasp.html","title":"vasp","text":"<p>A wrapper around ASE's Vasp calculator that makes it better suited for high-throughput DFT.</p>"},{"location":"reference/quacc/calculators/vasp.html#quacc.calculators.vasp.Vasp","title":"Vasp","text":"<pre><code>Vasp(\n    input_atoms,\n    preset=None,\n    use_custodian=None,\n    incar_copilot=None,\n    copy_magmoms=None,\n    preset_mag_default=None,\n    mag_cutoff=None,\n    elemental_magmoms=None,\n    auto_kpts=None,\n    auto_dipole=None,\n    **kwargs\n)\n</code></pre> <p>             Bases: <code>Vasp</code></p> <p>This is a wrapper around the ASE Vasp calculator that adjusts INCAR parameters on-the-fly, allows for ASE to run VASP via Custodian, and supports several automatic k-point generation schemes from Pymatgen.</p> <p>Parameters:</p> <ul> <li> <code>input_atoms</code>             (<code>Atoms</code>)         \u2013          <p>The input Atoms object to be used for the calculation.</p> </li> <li> <code>preset</code>             (<code>None | str</code>, default:                 <code>None</code> )         \u2013          <p>The name of a YAML file containing a list of INCAR parameters to use as a \"preset\" for the calculator. quacc will automatically look in the <code>VASP_PRESET_DIR</code> (default: quacc/calculators/presets/vasp) for the file, such that preset=\"BulkSet\" is supported, for instance. The .yaml extension is not necessary. Any user-supplied calculator **kwargs will override any corresponding preset values.</p> </li> <li> <code>use_custodian</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to use Custodian to run VASP. Default is True in settings.</p> </li> <li> <code>incar_copilot</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>If True, the INCAR parameters will be adjusted if they go against the VASP manual. Default is True in settings.</p> </li> <li> <code>copy_magmoms</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>If True, any pre-existing <code>atoms.get_magnetic_moments()</code> will be set in <code>atoms.set_initial_magnetic_moments()</code>. Set this to False if you want to use a preset's magnetic moments every time.</p> </li> <li> <code>preset_mag_default</code>             (<code>float | None</code>, default:                 <code>None</code> )         \u2013          <p>Default magmom value for sites without one explicitly specified in the preset. Only used if a preset is specified with an elemental_mags_dict key-value pair. Default is 1.0 in settings.</p> </li> <li> <code>mag_cutoff</code>             (<code>None | float</code>, default:                 <code>None</code> )         \u2013          <p>Set all initial magmoms to 0 if all have a magnitude below this value. Default is 0.05 in settings.</p> </li> <li> <code>elemental_magmoms</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>A dictionary of elemental initial magnetic moments to pass to quacc.runners.prep.set_magmoms, e.g. <code>{\"Fe\": 5, \"Ni\": 4}</code>.</p> </li> <li> <code>auto_kpts</code>             (<code>dict[Literal['line_density', 'kppvol', 'kppa'], float] | dict[Literal['length_densities'], list[float]] | None</code>, default:                 <code>None</code> )         \u2013          <p>An automatic k-point generation scheme from Pymatgen. Options include:</p> <ul> <li> <p>{\"line_density\": float}. This will call   <code>pymatgen.symmetry.bandstructure.HighSymmKpath</code>     with <code>path_type=\"latimer_munro\"</code>. The <code>line_density</code> value will be     set in the <code>.get_kpoints</code> attribute.</p> </li> <li> <p>{\"kppvol\": float}. This will call   <code>pymatgen.io.vasp.inputs.Kpoints.automatic_density_by_vol</code>     with the given value for <code>kppvol</code>.</p> </li> <li> <p>{\"kppa\": float}. This will call   <code>pymatgen.io.vasp.inputs.Kpoints.automatic_density</code>     with the given value for <code>kppa</code>.</p> </li> <li> <p>{\"length_densities\": [float, float, float]}. This will call   <code>pymatgen.io.vasp.inputs.Kpoints.automatic_density_by_lengths</code>     with the given value for <code>length_densities</code>.</p> </li> </ul> <p>If multiple options are specified, the most dense k-point scheme will be chosen.</p> </li> <li> <code>auto_dipole</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>If True, will automatically set dipole moment correction parameters based on the center of mass (in the c dimension by default).</p> </li> <li> <code>**kwargs</code>         \u2013          <p>Additional arguments to be passed to the VASP calculator, e.g. <code>xc='PBE'</code>, <code>encut=520</code>. Takes all valid ASE calculator arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>         \u2013          <p>The ASE Atoms object with attached VASP calculator.</p> </li> </ul> Source code in <code>quacc/calculators/vasp.py</code> <pre><code>def __init__(\n    self,\n    input_atoms: Atoms,\n    preset: None | str = None,\n    use_custodian: bool | None = None,\n    incar_copilot: bool | None = None,\n    copy_magmoms: bool | None = None,\n    preset_mag_default: float | None = None,\n    mag_cutoff: None | float = None,\n    elemental_magmoms: dict | None = None,\n    auto_kpts: dict[Literal[\"line_density\", \"kppvol\", \"kppa\"], float]\n    | dict[Literal[\"length_densities\"], list[float]]\n    | None = None,\n    auto_dipole: bool | None = None,\n    **kwargs,\n):\n    # Set defaults\n    use_custodian = (\n        SETTINGS.VASP_USE_CUSTODIAN if use_custodian is None else use_custodian\n    )\n    incar_copilot = (\n        SETTINGS.VASP_INCAR_COPILOT if incar_copilot is None else incar_copilot\n    )\n    copy_magmoms = (\n        SETTINGS.VASP_COPY_MAGMOMS if copy_magmoms is None else copy_magmoms\n    )\n    preset_mag_default = (\n        SETTINGS.VASP_PRESET_MAG_DEFAULT\n        if preset_mag_default is None\n        else preset_mag_default\n    )\n    mag_cutoff = SETTINGS.VASP_MAG_CUTOFF if mag_cutoff is None else mag_cutoff\n\n    # Assign variables to self\n    self.input_atoms = input_atoms\n    self.preset = preset\n    self.use_custodian = use_custodian\n    self.incar_copilot = incar_copilot\n    self.copy_magmoms = copy_magmoms\n    self.preset_mag_default = preset_mag_default\n    self.mag_cutoff = mag_cutoff\n    self.elemental_magmoms = elemental_magmoms\n    self.auto_kpts = auto_kpts\n    self.auto_dipole = auto_dipole\n    self.kwargs = kwargs\n\n    # Check constraints\n    if (\n        use_custodian\n        and input_atoms.constraints\n        and not all(isinstance(c, FixAtoms) for c in input_atoms.constraints)\n    ):\n        msg = \"Atoms object has a constraint that is not compatible with Custodian. Set use_custodian = False.\"\n        raise ValueError(msg)\n\n    # Get VASP executable command, if necessary, and specify child\n    # environment variables\n    command = self._manage_environment()\n\n    # Get user-defined preset parameters for the calculator\n    if preset:\n        calc_preset = load_vasp_yaml_calc(Path(SETTINGS.VASP_PRESET_DIR, preset))[\n            \"inputs\"\n        ]\n    else:\n        calc_preset = {}\n\n    # Collect all the calculator parameters and prioritize the kwargs in the\n    # case of duplicates.\n    self.user_calc_params = calc_preset | kwargs\n    none_keys = [k for k, v in self.user_calc_params.items() if v is None]\n    for none_key in none_keys:\n        del self.user_calc_params[none_key]\n\n    # Allow the user to use setups='mysetups.yaml' to load in a custom\n    # setups from a YAML file\n    if (\n        isinstance(self.user_calc_params.get(\"setups\"), str)\n        and self.user_calc_params[\"setups\"] not in ase_setups.setups_defaults\n    ):\n        self.user_calc_params[\"setups\"] = load_vasp_yaml_calc(\n            Path(SETTINGS.VASP_PRESET_DIR, self.user_calc_params[\"setups\"])\n        )[\"inputs\"][\"setups\"]\n\n    # Handle special arguments in the user calc parameters that ASE does not\n    # natively support\n    if (\n        self.user_calc_params.get(\"elemental_magmoms\")\n        and self.elemental_magmoms is None\n    ):\n        self.elemental_magmoms = self.user_calc_params[\"elemental_magmoms\"]\n    if self.user_calc_params.get(\"auto_kpts\") and self.auto_kpts is None:\n        self.auto_kpts = self.user_calc_params[\"auto_kpts\"]\n    if self.user_calc_params.get(\"auto_dipole\") and self.auto_dipole is None:\n        self.auto_dipole = self.user_calc_params[\"auto_dipole\"]\n    for k in [\"elemental_magmoms\", \"auto_kpts\", \"auto_dipole\"]:\n        self.user_calc_params.pop(k, None)\n\n    # Make automatic k-point mesh\n    if self.auto_kpts and not self.user_calc_params.get(\"kpts\"):\n        self._convert_auto_kpts()\n\n    # Add dipole corrections if requested\n    if self.auto_dipole:\n        self._set_auto_dipole()\n\n    # Set magnetic moments\n    set_magmoms(\n        input_atoms,\n        elemental_mags_dict=self.elemental_magmoms,\n        copy_magmoms=copy_magmoms,\n        elemental_mags_default=preset_mag_default,\n        mag_cutoff=mag_cutoff,\n    )\n\n    # Handle INCAR swaps as needed\n    if incar_copilot:\n        self._calc_swaps()\n\n    # Remove unused INCAR flags\n    self._remove_unused_flags()\n\n    # Instantiate the calculator!\n    super().__init__(atoms=input_atoms, command=command, **self.user_calc_params)\n</code></pre>"},{"location":"reference/quacc/calculators/vasp.html#quacc.calculators.vasp.load_vasp_yaml_calc","title":"load_vasp_yaml_calc","text":"<pre><code>load_vasp_yaml_calc(yaml_path)\n</code></pre> <p>Loads a YAML file containing calculator settings. Used for VASP calculations and can read quacc-formatted YAMLs that are of the following format: <pre><code>inputs:\n  xc: pbe\n  algo: all\n  setups:\n    Cu: Cu_pv\n  elemental_magmoms:\n    Fe: 5\n    Cu: 1\n</code></pre> where <code>inputs</code> is a dictionary of ASE-style input parameters, <code>setups</code> is a dictionary of ASE-style pseudopotentials, and and <code>elemental_magmoms</code> is a dictionary of element-wise initial magmoms.</p> <p>Parameters:</p> <ul> <li> <code>yaml_path</code>             (<code>str | Path</code>)         \u2013          <p>Path to the YAML file. This function will look in the <code>VASP_PRESET_DIR</code> (default: quacc/calculators/presets/vasp) for the file, thereby assuming that <code>yaml_path</code> is a relative path within that folder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>The calculator configuration (i.e. settings).</p> </li> </ul> Source code in <code>quacc/calculators/vasp.py</code> <pre><code>def load_vasp_yaml_calc(yaml_path: str | Path) -&gt; dict:\n    \"\"\"\n    Loads a YAML file containing calculator settings. Used for VASP calculations\n    and can read quacc-formatted YAMLs that are of the following format:\n    ```yaml\n    inputs:\n      xc: pbe\n      algo: all\n      setups:\n        Cu: Cu_pv\n      elemental_magmoms:\n        Fe: 5\n        Cu: 1\n    ```\n    where `inputs` is a dictionary of ASE-style input parameters, `setups` is a\n    dictionary of ASE-style pseudopotentials, and and `elemental_magmoms` is a\n    dictionary of element-wise initial magmoms.\n\n    Parameters\n    ----------\n    yaml_path\n        Path to the YAML file. This function will look in the `VASP_PRESET_DIR`\n        (default: quacc/calculators/presets/vasp) for the file, thereby assuming\n        that `yaml_path` is a relative path within that folder.\n    Returns\n    -------\n\n    dict\n        The calculator configuration (i.e. settings).\n    \"\"\"\n\n    config = load_yaml_calc(yaml_path)\n\n    # Allow for either \"Cu_pv\" and \"_pv\" style setups\n    if \"inputs\" in config:\n        config[\"inputs\"] = {\n            k.lower(): v.lower() if isinstance(v, str) else v\n            for k, v in config[\"inputs\"].items()\n        }\n        for k, v in config[\"inputs\"].get(\"setups\", {}).items():\n            if k in v:\n                config[\"inputs\"][\"setups\"][k] = v.split(k)[-1]\n\n    return config\n</code></pre>"},{"location":"reference/quacc/calculators/custodian/qchem.html","title":"qchem","text":"<p>Custodian handlers for QChem</p>"},{"location":"reference/quacc/calculators/custodian/qchem.html#quacc.calculators.custodian.qchem.run_custodian","title":"run_custodian","text":"<pre><code>run_custodian(\n    qchem_cores=1,\n    qchem_cmd=None,\n    qchem_local_scratch=None,\n    qchem_use_error_handlers=None,\n    qchem_custodian_max_errors=None,\n    qchem_nbo_exe=None,\n)\n</code></pre> <p>Function to run QChem Custodian</p> <p>Parameters:</p> <ul> <li> <code>qchem_cores</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Number of cores to use for the Q-Chem calculation.</p> </li> <li> <code>qchem_cmd</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Q-Chem command. Defaults to \"qchem\" in settings.</p> </li> <li> <code>qchem_local_scratch</code>             (<code>str | Path | None</code>, default:                 <code>None</code> )         \u2013          <p>Compute-node local scratch directory in which Q-Chem should perform IO. Defaults to /tmp in settings.</p> </li> <li> <code>qchem_use_error_handlers</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether or not to employ error handlers. Defaults to True in settings.</p> </li> <li> <code>qchem_custodian_max_errors</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Maximum number of errors to allow before stopping the run. Defaults to 5 in settings.</p> </li> <li> <code>qchem_nbo_exe</code>             (<code>str | Path | None</code>, default:                 <code>None</code> )         \u2013          <p>The full path to the NBO executable.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>quacc/calculators/custodian/qchem.py</code> <pre><code>@requires(\n    ob,\n    \"Openbabel must be installed. Try conda install -c conda-forge openbabel\",\n)\ndef run_custodian(\n    qchem_cores: int = 1,\n    qchem_cmd: str | None = None,\n    qchem_local_scratch: str | Path | None = None,\n    qchem_use_error_handlers: bool | None = None,\n    qchem_custodian_max_errors: int | None = None,\n    qchem_nbo_exe: str | Path | None = None,\n) -&gt; None:\n    \"\"\"\n    Function to run QChem Custodian\n\n    Parameters\n    ----------\n    qchem_cores\n        Number of cores to use for the Q-Chem calculation.\n    qchem_cmd\n        Q-Chem command. Defaults to \"qchem\" in settings.\n    qchem_local_scratch\n        Compute-node local scratch directory in which Q-Chem should perform IO.\n        Defaults to /tmp in settings.\n    qchem_use_error_handlers\n        Whether or not to employ error handlers. Defaults to True in settings.\n    qchem_custodian_max_errors\n        Maximum number of errors to allow before stopping the run. Defaults to 5\n        in settings.\n    qchem_nbo_exe\n        The full path to the NBO executable.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # Adapted from atomate.qchem.firetasks.run_calc\n    from custodian import Custodian\n    from custodian.qchem.handlers import QChemErrorHandler\n    from custodian.qchem.jobs import QCJob\n\n    # Set defaults\n    qchem_cmd = SETTINGS.QCHEM_CMD if qchem_cmd is None else qchem_cmd\n    qchem_local_scratch = (\n        SETTINGS.QCHEM_LOCAL_SCRATCH\n        if qchem_local_scratch is None\n        else qchem_local_scratch\n    )\n    qchem_use_error_handlers = (\n        SETTINGS.QCHEM_USE_ERROR_HANDLERS\n        if qchem_use_error_handlers is None\n        else qchem_use_error_handlers\n    )\n    qchem_custodian_max_errors = (\n        SETTINGS.QCHEM_CUSTODIAN_MAX_ERRORS\n        if qchem_custodian_max_errors is None\n        else qchem_custodian_max_errors\n    )\n    qchem_nbo_exe = SETTINGS.QCHEM_NBO_EXE if qchem_nbo_exe is None else qchem_nbo_exe\n\n    # Error handlers for Q-Chem\n    handlers = [QChemErrorHandler()] if qchem_use_error_handlers else []\n\n    # Run Q-Chem\n    jobs = [\n        QCJob(\n            qchem_command=qchem_cmd,\n            max_cores=qchem_cores,\n            calc_loc=str(qchem_local_scratch),\n            nboexe=str(qchem_nbo_exe),\n        )\n    ]\n\n    c = Custodian(\n        handlers,\n        jobs,\n        max_errors=qchem_custodian_max_errors,\n    )\n\n    c.run()\n</code></pre>"},{"location":"reference/quacc/calculators/custodian/vasp.html","title":"vasp","text":"<p>Custodian handlers for VASP</p>"},{"location":"reference/quacc/calculators/custodian/vasp.html#quacc.calculators.custodian.vasp.run_custodian","title":"run_custodian","text":"<pre><code>run_custodian(\n    vasp_parallel_cmd=None,\n    vasp_cmd=None,\n    vasp_gamma_cmd=None,\n    vasp_custodian_max_errors=None,\n    vasp_custodian_wall_time=None,\n    vtst_fixes=None,\n    vasp_custodian_handlers=None,\n    vasp_custodian_validators=None,\n    scratch_dir=None,\n    vasp_job_kwargs=None,\n    custodian_kwargs=None,\n)\n</code></pre> <p>Function to run VASP Custodian</p> <p>Parameters:</p> <ul> <li> <code>vasp_parallel_cmd</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>VASP parallel command, e.g. \"srun -N 2 --ntasks-per-node=24\". Defaults to the $VASP_PARALLEL_CMD environment variable in settings.</p> </li> <li> <code>vasp_cmd</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>VASP command. Defaults to \"vasp_std\" in settings.</p> </li> <li> <code>vasp_gamma_cmd</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>VASP gamma command. Defaults to \"vasp_gam\" in settings.</p> </li> <li> <code>vasp_custodian_max_errors</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Maximum number of errors to allow before stopping the run. Defaults to 5 in settings.</p> </li> <li> <code>vasp_custodian_wall_time</code>             (<code>float | None</code>, default:                 <code>None</code> )         \u2013          <p>Maximum wall time to allow before creating a STOPCAR. Defaults to infinity in settings.</p> </li> <li> <code>vtst_fixes</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to apply VTST input swaps. Defaults to False in settings.</p> </li> <li> <code>vasp_custodian_handlers</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>List of handlers to use in Custodian. See settings for list.</p> </li> <li> <code>vasp_custodian_validators</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>List of validators to use in Custodian. See settings for list.</p> </li> <li> <code>scratch_dir</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Scratch directory to use. Defaults to None.</p> </li> <li> <code>vasp_job_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Keyword arguments to pass to the Custodian VaspJob. Defaults to None.</p> </li> <li> <code>custodian_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Any remaining keyword arguments to pass to Custodian. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>quacc/calculators/custodian/vasp.py</code> <pre><code>def run_custodian(\n    vasp_parallel_cmd: str | None = None,\n    vasp_cmd: str | None = None,\n    vasp_gamma_cmd: str | None = None,\n    vasp_custodian_max_errors: int | None = None,\n    vasp_custodian_wall_time: float | None = None,\n    vtst_fixes: bool | None = None,\n    vasp_custodian_handlers: list[str] | None = None,\n    vasp_custodian_validators: list[str] | None = None,\n    scratch_dir: str | None = None,\n    vasp_job_kwargs: dict | None = None,\n    custodian_kwargs: dict | None = None,\n) -&gt; None:\n    \"\"\"\n    Function to run VASP Custodian\n\n    Parameters\n    ----------\n    vasp_parallel_cmd\n        VASP parallel command, e.g. \"srun -N 2 --ntasks-per-node=24\". Defaults\n        to the $VASP_PARALLEL_CMD environment variable in settings.\n    vasp_cmd\n        VASP command. Defaults to \"vasp_std\" in settings.\n    vasp_gamma_cmd\n        VASP gamma command. Defaults to \"vasp_gam\" in settings.\n    vasp_custodian_max_errors\n        Maximum number of errors to allow before stopping the run. Defaults to 5\n        in settings.\n    vasp_custodian_wall_time\n        Maximum wall time to allow before creating a STOPCAR. Defaults to\n        infinity in settings.\n    vtst_fixes\n        Whether to apply VTST input swaps. Defaults to False in settings.\n    vasp_custodian_handlers\n        List of handlers to use in Custodian. See settings for list.\n    vasp_custodian_validators\n        List of validators to use in Custodian. See settings for list.\n    scratch_dir\n        Scratch directory to use. Defaults to None.\n    vasp_job_kwargs\n        Keyword arguments to pass to the Custodian VaspJob. Defaults to None.\n    custodian_kwargs\n        Any remaining keyword arguments to pass to Custodian. Defaults to None.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # Adapted from atomate2.vasp.run.run_vasp\n\n    # Set defaults\n    vasp_parallel_cmd = os.path.expandvars(\n        SETTINGS.VASP_PARALLEL_CMD if vasp_parallel_cmd is None else vasp_parallel_cmd\n    )\n    vasp_cmd = SETTINGS.VASP_CMD if vasp_cmd is None else vasp_cmd\n    vasp_gamma_cmd = (\n        SETTINGS.VASP_GAMMA_CMD if vasp_gamma_cmd is None else vasp_gamma_cmd\n    )\n    vasp_custodian_max_errors = (\n        SETTINGS.VASP_CUSTODIAN_MAX_ERRORS\n        if vasp_custodian_max_errors is None\n        else vasp_custodian_max_errors\n    )\n    vasp_custodian_wall_time = (\n        SETTINGS.VASP_CUSTODIAN_WALL_TIME\n        if vasp_custodian_wall_time is None\n        else vasp_custodian_wall_time\n    )\n    vtst_fixes = SETTINGS.VASP_CUSTODIAN_VTST if vtst_fixes is None else vtst_fixes\n    vasp_custodian_handlers = (\n        SETTINGS.VASP_CUSTODIAN_HANDLERS\n        if vasp_custodian_handlers is None\n        else vasp_custodian_handlers\n    )\n    vasp_custodian_validators = (\n        SETTINGS.VASP_CUSTODIAN_VALIDATORS\n        if vasp_custodian_validators is None\n        else vasp_custodian_validators\n    )\n\n    # Handlers for VASP\n    handlers = []\n    handlers_dict = {\n        \"VaspErrorHandler\": VaspErrorHandler(vtst_fixes=vtst_fixes),\n        \"FrozenJobErrorHandler\": FrozenJobErrorHandler(),\n        \"IncorrectSmearingHandler\": IncorrectSmearingHandler(),\n        \"LargeSigmaHandler\": LargeSigmaHandler(),\n        \"MeshSymmetryErrorHandler\": MeshSymmetryErrorHandler(),\n        \"NonConvergingErrorHandler\": NonConvergingErrorHandler(),\n        \"PositiveEnergyErrorHandler\": PositiveEnergyErrorHandler(),\n        \"PotimErrorHandler\": PotimErrorHandler(),\n        \"StdErrHandler\": StdErrHandler(),\n        \"UnconvergedErrorHandler\": UnconvergedErrorHandler(),\n        \"WalltimeHandler\": WalltimeHandler(),\n        \"ScanMetalHandler\": ScanMetalHandler(),\n    }\n    validators_dict = {\n        \"VaspFilesValidator\": VaspFilesValidator(),\n        \"VasprunXMLValidator\": VasprunXMLValidator(),\n    }\n\n    handlers = []\n    for handler_flag in vasp_custodian_handlers:\n        if handler_flag not in handlers_dict:\n            msg = f\"Unknown VASP error handler: {handler_flag}\"\n            raise ValueError(msg)\n        handlers.append(handlers_dict[handler_flag])\n\n    validators = []\n    for validator_flag in vasp_custodian_validators:\n        if validator_flag not in validators_dict:\n            msg = f\"Unknown VASP validator: {validator_flag}\"\n            raise ValueError(msg)\n        validators.append(validators_dict[validator_flag])\n\n    # Populate settings\n    full_vasp_cmd = f\"{vasp_parallel_cmd} {vasp_cmd}\"\n    full_vasp_gamma_cmd = f\"{vasp_parallel_cmd} {vasp_gamma_cmd}\"\n\n    # Run VASP\n    vasp_job_kwargs = {} if vasp_job_kwargs is None else vasp_job_kwargs\n    custodian_kwargs = {} if custodian_kwargs is None else custodian_kwargs\n    split_vasp_cmd = shlex.split(full_vasp_cmd)\n    split_vasp_gamma_cmd = shlex.split(full_vasp_gamma_cmd)\n    vasp_job_kwargs[\"gamma_vasp_cmd\"] = split_vasp_gamma_cmd\n\n    # Run with Custodian\n    jobs = [VaspJob(split_vasp_cmd, **vasp_job_kwargs)]\n\n    if vasp_custodian_wall_time:\n        handlers = [\n            *list(handlers),\n            WalltimeHandler(wall_time=vasp_custodian_wall_time),\n        ]\n\n    c = Custodian(\n        handlers,\n        jobs,\n        validators=validators,\n        max_errors=vasp_custodian_max_errors,\n        scratch_dir=scratch_dir,\n        **custodian_kwargs,\n    )\n\n    c.run()\n</code></pre>"},{"location":"reference/quacc/recipes/dftb/core.html","title":"core","text":"<p>Core recipes for DFTB+</p>"},{"location":"reference/quacc/recipes/dftb/core.html#quacc.recipes.dftb.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms,\n    method=\"GFN2-xTB\",\n    kpts=None,\n    relax_cell=False,\n    calc_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Carry out a structure relaxation.</p> Note <p>Calculator Defaults:</p> <pre><code>{\n    \"Hamiltonian_\": \"xTB\" if \"xtb\" in method.lower() else \"DFTB\",\n    \"Hamiltonian_Method\": method if \"xtb\" in method.lower() else None,\n    \"kpts\": kpts,\n    \"Driver_\": \"GeometryOptimization\",\n    \"Driver_LatticeOpt\": \"Yes\" if relax_cell else \"No\",\n    \"Driver_AppendGeometries\": \"Yes\",\n    \"Driver_MaxSteps\": 2000,\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>method</code>             (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'DFTB']</code>, default:                 <code>'GFN2-xTB'</code> )         \u2013          <p>Method to use.</p> </li> <li> <code>kpts</code>             (<code>tuple | list[tuple] | dict | None</code>, default:                 <code>None</code> )         \u2013          <p>k-point grid to use.</p> </li> <li> <code>relax_cell</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to relax the unit cell shape/volume in addition to the positions.</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. Set a value to <code>None</code> to remove a pre-existing key entirely.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results, specified in quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/dftb/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms | dict,\n    method: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"DFTB\"] = \"GFN2-xTB\",\n    kpts: tuple | list[tuple] | dict | None = None,\n    relax_cell: bool = False,\n    calc_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a structure relaxation.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\n            \"Hamiltonian_\": \"xTB\" if \"xtb\" in method.lower() else \"DFTB\",\n            \"Hamiltonian_Method\": method if \"xtb\" in method.lower() else None,\n            \"kpts\": kpts,\n            \"Driver_\": \"GeometryOptimization\",\n            \"Driver_LatticeOpt\": \"Yes\" if relax_cell else \"No\",\n            \"Driver_AppendGeometries\": \"Yes\",\n            \"Driver_MaxSteps\": 2000,\n        }\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    method\n        Method to use.\n    kpts\n        k-point grid to use.\n    relax_cell\n        Whether to relax the unit cell shape/volume in addition to the\n        positions.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator. Set a value to `None` to remove\n        a pre-existing key entirely. Set a value to `None` to remove a pre-existing key entirely.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results, specified in [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n\n    defaults = {\n        \"Hamiltonian_\": \"xTB\" if \"xtb\" in method.lower() else \"DFTB\",\n        \"Hamiltonian_Method\": method if \"xtb\" in method.lower() else None,\n        \"kpts\": kpts,\n        \"Driver_\": \"GeometryOptimization\",\n        \"Driver_LatticeOpt\": \"Yes\" if relax_cell else \"No\",\n        \"Driver_AppendGeometries\": \"Yes\",\n        \"Driver_MaxSteps\": 2000,\n    }\n\n    summary = _base_job(\n        atoms,\n        defaults=defaults,\n        calc_swaps=calc_swaps,\n        additional_fields={\"name\": \"DFTB+ Relax\"},\n        copy_files=copy_files,\n    )\n\n    if SETTINGS.CHECK_CONVERGENCE and not check_logfile(LOG_FILE, \"Geometry converged\"):\n        msg = \"Geometry did not converge\"\n        raise ValueError(msg)\n\n    return summary\n</code></pre>"},{"location":"reference/quacc/recipes/dftb/core.html#quacc.recipes.dftb.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms,\n    method=\"GFN2-xTB\",\n    kpts=None,\n    calc_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Carry out a single-point calculation.</p> Note <p>Calculator Defaults:</p> <pre><code>{\n    \"Hamiltonian_\": \"xTB\" if \"xtb\" in method.lower()\n    else \"DFTB\", \"Hamiltonian_Method\": method if \"xtb\" in method.lower()\n    else None, \"kpts\": kpts or ((1, 1, 1) if atoms.pbc.any() else None)\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>method</code>             (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'DFTB']</code>, default:                 <code>'GFN2-xTB'</code> )         \u2013          <p>Method to use.</p> </li> <li> <code>kpts</code>             (<code>tuple | list[tuple] | dict | None</code>, default:                 <code>None</code> )         \u2013          <p>k-point grid to use.</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. Set a value to <code>None</code> to remove a pre-existing key entirely.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results, specified in quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/dftb/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms | dict,\n    method: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"DFTB\"] = \"GFN2-xTB\",\n    kpts: tuple | list[tuple] | dict | None = None,\n    calc_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\n            \"Hamiltonian_\": \"xTB\" if \"xtb\" in method.lower()\n            else \"DFTB\", \"Hamiltonian_Method\": method if \"xtb\" in method.lower()\n            else None, \"kpts\": kpts or ((1, 1, 1) if atoms.pbc.any() else None)\n        }\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    method\n        Method to use.\n    kpts\n        k-point grid to use.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator. Set a value to `None` to remove\n        a pre-existing key entirely. Set a value to `None` to remove a pre-existing key entirely.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results, specified in [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n\n    defaults = {\n        \"Hamiltonian_\": \"xTB\" if \"xtb\" in method.lower() else \"DFTB\",\n        \"Hamiltonian_Method\": method if \"xtb\" in method.lower() else None,\n        \"kpts\": kpts,\n    }\n\n    summary = _base_job(\n        atoms,\n        defaults=defaults,\n        calc_swaps=calc_swaps,\n        additional_fields={\"name\": \"DFTB+ Static\"},\n        copy_files=copy_files,\n    )\n\n    if SETTINGS.CHECK_CONVERGENCE and check_logfile(LOG_FILE, \"SCC is NOT converged\"):\n        msg = \"SCC is not converged\"\n        raise ValueError(msg)\n\n    return summary\n</code></pre>"},{"location":"reference/quacc/recipes/emt/core.html","title":"core","text":"<p>Core recipes for EMT</p> <p>NOTE: This set of minimal recipes is mainly for demonstration purposes.</p>"},{"location":"reference/quacc/recipes/emt/core.html#quacc.recipes.emt.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms,\n    relax_cell=False,\n    calc_swaps=None,\n    opt_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Carry out a geometry optimization.</p> Note <p>Calculator Defaults:</p> <pre><code>{}\n</code></pre> <p>Optimizer Defaults:</p> <pre><code>{\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": FIRE}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>relax_cell</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to relax the cell</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the EMT calculator. Overrides the following defaults: <code>{}</code></p> </li> <li> <code>opt_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of swaps for quacc.runners.calc.run_ase_opt.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results, specified in quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>quacc/recipes/emt/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms | dict,\n    relax_cell: bool = False,\n    calc_swaps: dict | None = None,\n    opt_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; OptSchema:\n    \"\"\"\n    Carry out a geometry optimization.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {}\n        ```\n\n        Optimizer Defaults:\n\n        ```python\n        {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": FIRE}\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    relax_cell\n        Whether to relax the cell\n    calc_swaps\n        Dictionary of custom kwargs for the EMT calculator. Overrides the\n        following defaults: `{}`\n    opt_swaps\n        Dictionary of swaps for [quacc.runners.calc.run_ase_opt][].\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results, specified in [quacc.schemas.ase.summarize_opt_run][]\n    \"\"\"\n    atoms = fetch_atoms(atoms)\n    calc_swaps = calc_swaps or {}\n\n    opt_defaults = {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": FIRE}\n    opt_flags = merge_dicts(opt_defaults, opt_swaps)\n\n    atoms.calc = EMT(**calc_swaps)\n\n    dyn = run_ase_opt(atoms, relax_cell=relax_cell, copy_files=copy_files, **opt_flags)\n\n    return summarize_opt_run(dyn, additional_fields={\"name\": \"EMT Relax\"})\n</code></pre>"},{"location":"reference/quacc/recipes/emt/core.html#quacc.recipes.emt.core.static_job","title":"static_job","text":"<pre><code>static_job(atoms, calc_swaps=None, copy_files=None)\n</code></pre> <p>Carry out a static calculation.</p> Note <p>Calculator Defaults:</p> <pre><code>{}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the EMT calculator.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results, specified in quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/emt/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms | dict,\n    calc_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a static calculation.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {}\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    calc_swaps\n        Dictionary of custom kwargs for the EMT calculator.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results, specified in [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n    atoms = fetch_atoms(atoms)\n    calc_swaps = calc_swaps or {}\n\n    atoms.calc = EMT(**calc_swaps)\n    final_atoms = run_calc(atoms, copy_files=copy_files)\n\n    return summarize_run(\n        final_atoms,\n        input_atoms=atoms,\n        additional_fields={\"name\": \"EMT Static\"},\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/emt/defects.html","title":"defects","text":"<p>Defect recipes for EMT</p>"},{"location":"reference/quacc/recipes/emt/defects.html#quacc.recipes.emt.defects.bulk_to_defects_flow","title":"bulk_to_defects_flow","text":"<pre><code>bulk_to_defects_flow(\n    atoms,\n    defect_gen=VacancyGenerator,\n    defect_charge=0,\n    make_defects_kwargs=None,\n    run_static=True,\n    defect_relax_kwargs=None,\n    defect_static_kwargs=None,\n)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Defect generation</p> </li> <li> <p>Defect relaxations</p> </li> <li> <p>Defect statics (optional)</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object for the structure.</p> </li> <li> <code>defect_gen</code>             (<code>AntiSiteGenerator | ChargeInterstitialGenerator | InterstitialGenerator | SubstitutionGenerator | VacancyGenerator | VoronoiInterstitialGenerator</code>, default:                 <code>VacancyGenerator</code> )         \u2013          <p>Defect generator</p> </li> <li> <code>defect_charge</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>Charge state of the defect</p> </li> <li> <code>make_defects_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Keyword arguments to pass to quacc.atoms.defects.make_defects_from_bulk</p> </li> <li> <code>run_static</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to run the static calculation.</p> </li> <li> <code>defect_relax_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the relaxation calculation.</p> </li> <li> <code>defect_static_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the static calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[RunSchema | OptSchema]</code>         \u2013          <p>List of dictionary of results from quacc.schemas.ase.summarize_run or quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>quacc/recipes/emt/defects.py</code> <pre><code>@flow\ndef bulk_to_defects_flow(\n    atoms: Atoms | dict,\n    defect_gen: (\n        AntiSiteGenerator\n        | ChargeInterstitialGenerator\n        | InterstitialGenerator\n        | SubstitutionGenerator\n        | VacancyGenerator\n        | VoronoiInterstitialGenerator\n    ) = VacancyGenerator,\n    defect_charge: int = 0,\n    make_defects_kwargs: dict | None = None,\n    run_static: bool = True,\n    defect_relax_kwargs: dict | None = None,\n    defect_static_kwargs: dict | None = None,\n) -&gt; list[RunSchema | OptSchema]:\n    \"\"\"\n    Workflow consisting of:\n\n    1. Defect generation\n\n    2. Defect relaxations\n\n    3. Defect statics (optional)\n\n    Parameters\n    ----------\n    atoms\n        Atoms object for the structure.\n    defect_gen\n        Defect generator\n    defect_charge\n        Charge state of the defect\n    make_defects_kwargs\n        Keyword arguments to pass to [quacc.atoms.defects.make_defects_from_bulk][]\n    run_static\n        Whether to run the static calculation.\n    defect_relax_kwargs\n        Additional keyword arguments to pass to the relaxation calculation.\n    defect_static_kwargs\n        Additional keyword arguments to pass to the static calculation.\n\n    Returns\n    -------\n    list[RunSchema | OptSchema]\n        List of dictionary of results from [quacc.schemas.ase.summarize_run][] or\n        [quacc.schemas.ase.summarize_opt_run][]\n    \"\"\"\n    defect_relax_kwargs = defect_relax_kwargs or {}\n    defect_static_kwargs = defect_static_kwargs or {}\n    make_defects_kwargs = make_defects_kwargs or {}\n\n    if \"relax_cell\" not in defect_relax_kwargs:\n        defect_relax_kwargs[\"relax_cell\"] = False\n\n    @job\n    def _make_defects(atoms):\n        atoms = fetch_atoms(atoms)\n        return make_defects_from_bulk(\n            atoms,\n            defect_gen=defect_gen,\n            defect_charge=defect_charge,\n            **make_defects_kwargs,\n        )\n\n    @subflow\n    def _relax_distributed(defects):\n        return [relax_job(defect, **defect_relax_kwargs) for defect in defects]\n\n    @subflow\n    def _relax_and_static_distributed(defects):\n        return [\n            static_job(\n                relax_job(defect, **defect_relax_kwargs),\n                **defect_static_kwargs,\n            )\n            for defect in defects\n        ]\n\n    defects = _make_defects(atoms)\n\n    return (\n        _relax_and_static_distributed(defects)\n        if run_static\n        else _relax_distributed(defects)\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/emt/slabs.html","title":"slabs","text":"<p>Slab recipes for EMT</p>"},{"location":"reference/quacc/recipes/emt/slabs.html#quacc.recipes.emt.slabs.bulk_to_slabs_flow","title":"bulk_to_slabs_flow","text":"<pre><code>bulk_to_slabs_flow(\n    atoms,\n    make_slabs_kwargs=None,\n    run_static=True,\n    slab_relax_kwargs=None,\n    slab_static_kwargs=None,\n)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Slab generation</p> </li> <li> <p>Slab relaxations</p> </li> <li> <p>Slab statics (optional)</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>make_slabs_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to quacc.atoms.slabs.make_slabs_from_bulk</p> </li> <li> <code>run_static</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to run the static calculation.</p> </li> <li> <code>slab_relax_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the relaxation calculation.</p> </li> <li> <code>slab_static_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the static calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[RunSchema | OptSchema]</code>         \u2013          <p>RunSchema or OptSchema for each slab.</p> </li> </ul> Source code in <code>quacc/recipes/emt/slabs.py</code> <pre><code>@flow\ndef bulk_to_slabs_flow(\n    atoms: Atoms | dict,\n    make_slabs_kwargs: dict | None = None,\n    run_static: bool = True,\n    slab_relax_kwargs: dict | None = None,\n    slab_static_kwargs: dict | None = None,\n) -&gt; list[RunSchema | OptSchema]:\n    \"\"\"\n    Workflow consisting of:\n\n    1. Slab generation\n\n    2. Slab relaxations\n\n    3. Slab statics (optional)\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    make_slabs_kwargs\n        Additional keyword arguments to pass to\n        [quacc.atoms.slabs.make_slabs_from_bulk][]\n    run_static\n        Whether to run the static calculation.\n    slab_relax_kwargs\n        Additional keyword arguments to pass to the relaxation calculation.\n    slab_static_kwargs\n        Additional keyword arguments to pass to the static calculation.\n\n    Returns\n    -------\n    list[RunSchema | OptSchema]\n        [RunSchema][quacc.schemas.ase.summarize_run] or\n        [OptSchema][quacc.schemas.ase.summarize_opt_run] for each slab.\n    \"\"\"\n    slab_relax_kwargs = slab_relax_kwargs or {}\n    slab_static_kwargs = slab_static_kwargs or {}\n    make_slabs_kwargs = make_slabs_kwargs or {}\n\n    if \"relax_cell\" not in slab_relax_kwargs:\n        slab_relax_kwargs[\"relax_cell\"] = False\n\n    @job\n    def _make_slabs(atoms):\n        atoms = fetch_atoms(atoms)\n        return make_slabs_from_bulk(atoms, **make_slabs_kwargs)\n\n    @subflow\n    def _relax_distributed(slabs):\n        return [relax_job(slab, **slab_relax_kwargs) for slab in slabs]\n\n    @subflow\n    def _relax_and_static_distributed(slabs):\n        return [\n            static_job(\n                relax_job(slab, **slab_relax_kwargs),\n                **slab_static_kwargs,\n            )\n            for slab in slabs\n        ]\n\n    slabs = _make_slabs(atoms)\n\n    return (\n        _relax_and_static_distributed(slabs)\n        if run_static\n        else _relax_distributed(slabs)\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/gaussian/core.html","title":"core","text":"<p>Core recipes for Gaussian</p>"},{"location":"reference/quacc/recipes/gaussian/core.html#quacc.recipes.gaussian.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms,\n    charge,\n    spin_multiplicity,\n    xc=\"wb97x-d\",\n    basis=\"def2-tzvp\",\n    freq=False,\n    calc_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Carry out a geometry optimization.</p> Note <p>Calculator Defaults:</p> <pre><code>{\n    \"mem\": \"16GB\",\n    \"chk\": \"Gaussian.chk\",\n    \"nprocshared\": multiprocessing.cpu_count(),\n    \"xc\": xc,\n    \"basis\": basis,\n    \"charge\": charge,\n    \"mult\": spin_multiplicity,\n    \"opt\": \"\",\n    \"pop\": \"CM5\",\n    \"scf\": [\"maxcycle=250\", \"xqc\"],\n    \"integral\": \"ultrafine\",\n    \"nosymmetry\": \"\",\n    \"freq\": \"\" if freq else None,\n    \"ioplist\": [\"2/9=2000\"],\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>charge</code>             (<code>int</code>)         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>)         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>xc</code>             (<code>str</code>, default:                 <code>'wb97x-d'</code> )         \u2013          <p>Exchange-correlation functional</p> </li> <li> <code>basis</code>             (<code>str</code>, default:                 <code>'def2-tzvp'</code> )         \u2013          <p>Basis set</p> </li> <li> <code>freq</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If a frequency calculation should be carried out.</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. Set a value to <code>None</code> to remove a pre-existing key entirely.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cclibSchema</code>         \u2013          <p>Dictionary of results, as specified in quacc.schemas.cclib.cclib_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/gaussian/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    charge: int,\n    spin_multiplicity: int,\n    xc: str = \"wb97x-d\",\n    basis: str = \"def2-tzvp\",\n    freq: bool = False,\n    calc_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; cclibSchema:\n    \"\"\"\n    Carry out a geometry optimization.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\n            \"mem\": \"16GB\",\n            \"chk\": \"Gaussian.chk\",\n            \"nprocshared\": multiprocessing.cpu_count(),\n            \"xc\": xc,\n            \"basis\": basis,\n            \"charge\": charge,\n            \"mult\": spin_multiplicity,\n            \"opt\": \"\",\n            \"pop\": \"CM5\",\n            \"scf\": [\"maxcycle=250\", \"xqc\"],\n            \"integral\": \"ultrafine\",\n            \"nosymmetry\": \"\",\n            \"freq\": \"\" if freq else None,\n            \"ioplist\": [\"2/9=2000\"],\n        }\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    freq\n        If a frequency calculation should be carried out.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator. Set a value to `None` to remove\n        a pre-existing key entirely. Set a value to `None` to remove a pre-existing key entirely.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    cclibSchema\n        Dictionary of results, as specified in [quacc.schemas.cclib.cclib_summarize_run][]\n    \"\"\"\n\n    defaults = {\n        \"mem\": \"16GB\",\n        \"chk\": \"Gaussian.chk\",\n        \"nprocshared\": multiprocessing.cpu_count(),\n        \"xc\": xc,\n        \"basis\": basis,\n        \"charge\": charge,\n        \"mult\": spin_multiplicity,\n        \"opt\": \"\",\n        \"pop\": \"CM5\",\n        \"scf\": [\"maxcycle=250\", \"xqc\"],\n        \"integral\": \"ultrafine\",\n        \"nosymmetry\": \"\",\n        \"freq\": \"\" if freq else None,\n        \"ioplist\": [\"2/9=2000\"],  # ASE issue #660\n    }\n    return _base_job(\n        atoms,\n        charge=charge,\n        spin_multiplicity=spin_multiplicity,\n        defaults=defaults,\n        calc_swaps=calc_swaps,\n        additional_fields={\"name\": \"Gaussian Relax\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/gaussian/core.html#quacc.recipes.gaussian.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms,\n    charge,\n    spin_multiplicity,\n    xc=\"wb97x-d\",\n    basis=\"def2-tzvp\",\n    calc_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Carry out a single-point calculation.</p> Note <p>Calculator Defaults:</p> <pre><code>{\n    \"mem\": \"16GB\",\n    \"chk\": \"Gaussian.chk\",\n    \"nprocshared\": multiprocessing.cpu_count(),\n    \"xc\": xc,\n    \"basis\": basis,\n    \"charge\": charge,\n    \"mult\": spin_multiplicity,\n    \"sp\": \"\",\n    \"scf\": [\"maxcycle=250\", \"xqc\"],\n    \"integral\": \"ultrafine\",\n    \"nosymmetry\": \"\",\n    \"pop\": \"CM5\",\n    \"gfinput\": \"\",\n    \"ioplist\": [\"6/7=3\", \"2/9=2000\"],\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>charge</code>             (<code>int</code>)         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>)         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>xc</code>             (<code>str</code>, default:                 <code>'wb97x-d'</code> )         \u2013          <p>Exchange-correlation functional</p> </li> <li> <code>basis</code>             (<code>str</code>, default:                 <code>'def2-tzvp'</code> )         \u2013          <p>Basis set</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. Set a value to <code>None</code> to remove a pre-existing key entirely.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cclibSchema</code>         \u2013          <p>Dictionary of results, as specified in quacc.schemas.cclib.cclib_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/gaussian/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms | dict,\n    charge: int,\n    spin_multiplicity: int,\n    xc: str = \"wb97x-d\",\n    basis: str = \"def2-tzvp\",\n    calc_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; cclibSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\n            \"mem\": \"16GB\",\n            \"chk\": \"Gaussian.chk\",\n            \"nprocshared\": multiprocessing.cpu_count(),\n            \"xc\": xc,\n            \"basis\": basis,\n            \"charge\": charge,\n            \"mult\": spin_multiplicity,\n            \"sp\": \"\",\n            \"scf\": [\"maxcycle=250\", \"xqc\"],\n            \"integral\": \"ultrafine\",\n            \"nosymmetry\": \"\",\n            \"pop\": \"CM5\",\n            \"gfinput\": \"\",\n            \"ioplist\": [\"6/7=3\", \"2/9=2000\"],\n        }\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    calc_swaps\n        Dictionary of custom kwargs for the calculator. Set a value to `None` to remove\n        a pre-existing key entirely. Set a value to `None` to remove a pre-existing key entirely.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    cclibSchema\n        Dictionary of results, as specified in [quacc.schemas.cclib.cclib_summarize_run][]\n    \"\"\"\n\n    defaults = {\n        \"mem\": \"16GB\",\n        \"chk\": \"Gaussian.chk\",\n        \"nprocshared\": multiprocessing.cpu_count(),\n        \"xc\": xc,\n        \"basis\": basis,\n        \"charge\": charge,\n        \"mult\": spin_multiplicity,\n        \"sp\": \"\",\n        \"scf\": [\"maxcycle=250\", \"xqc\"],\n        \"integral\": \"ultrafine\",\n        \"nosymmetry\": \"\",\n        \"pop\": \"CM5\",\n        \"gfinput\": \"\",\n        \"ioplist\": [\"6/7=3\", \"2/9=2000\"],  # see ASE issue #660\n    }\n    return _base_job(\n        atoms,\n        charge=charge,\n        spin_multiplicity=spin_multiplicity,\n        defaults=defaults,\n        calc_swaps=calc_swaps,\n        additional_fields={\"name\": \"Gaussian Static\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/gulp/core.html","title":"core","text":"<p>Core recipes for GULP</p>"},{"location":"reference/quacc/recipes/gulp/core.html#quacc.recipes.gulp.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms,\n    use_gfnff=True,\n    library=None,\n    relax_cell=False,\n    keyword_swaps=None,\n    option_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Carry out a structure relaxation.</p> Note <p>Keyword Defaults:</p> <pre><code>{\n    \"opti\": True,\n    \"gfnff\": True if use_gfnff else None,\n    \"gwolf\": True if use_gfnff and atoms.pbc.any() else None,\n    \"conp\": True if relax_cell and atoms.pbc.any() else None,\n    \"conv\": None if relax_cell and atoms.pbc.any() else True,\n}\n</code></pre> <p>Option Defaults:</p> <pre><code>{\n    \"dump every gulp.res\": True,\n    f\"output cif {GEOM_FILE_PBC}\": True if atoms.pbc.any() else None,\n    f\"output xyz {GEOM_FILE_NOPBC}\": None if atoms.pbc.any() else True,\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>use_gfnff</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>True if (p)GFN-FF should be used; False if not.</p> </li> <li> <code>library</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Filename of the potential library file, if required.</p> </li> <li> <code>relax_cell</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>True if the volume should be relaxed; False if not.</p> </li> <li> <code>keyword_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom keyword swap kwargs for the calculator.</p> </li> <li> <code>option_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom option swap kwargs for the calculator.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/gulp/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms | dict,\n    use_gfnff: bool = True,\n    library: str | None = None,\n    relax_cell: bool = False,\n    keyword_swaps: dict | None = None,\n    option_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a structure relaxation.\n\n    ??? Note\n\n        Keyword Defaults:\n\n        ```python\n        {\n            \"opti\": True,\n            \"gfnff\": True if use_gfnff else None,\n            \"gwolf\": True if use_gfnff and atoms.pbc.any() else None,\n            \"conp\": True if relax_cell and atoms.pbc.any() else None,\n            \"conv\": None if relax_cell and atoms.pbc.any() else True,\n        }\n        ```\n\n        Option Defaults:\n\n        ```python\n        {\n            \"dump every gulp.res\": True,\n            f\"output cif {GEOM_FILE_PBC}\": True if atoms.pbc.any() else None,\n            f\"output xyz {GEOM_FILE_NOPBC}\": None if atoms.pbc.any() else True,\n        }\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    use_gfnff\n        True if (p)GFN-FF should be used; False if not.\n    library\n        Filename of the potential library file, if required.\n    relax_cell\n        True if the volume should be relaxed; False if not.\n    keyword_swaps\n        Dictionary of custom keyword swap kwargs for the calculator.\n    option_swaps\n        Dictionary of custom option swap kwargs for the calculator.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    dict\n        Dictionary of results from [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n\n    keyword_defaults = {\n        \"opti\": True,\n        \"gfnff\": True if use_gfnff else None,\n        \"gwolf\": True if use_gfnff else None,\n        \"conp\": True if relax_cell else None,\n        \"conv\": None if relax_cell else True,\n    }\n    option_defaults = {\"dump every gulp.res\": True}\n\n    return _base_job(\n        atoms,\n        library=library,\n        keyword_defaults=keyword_defaults,\n        option_defaults=option_defaults,\n        keyword_swaps=keyword_swaps,\n        option_swaps=option_swaps,\n        additional_fields={\"name\": \"GULP Relax\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/gulp/core.html#quacc.recipes.gulp.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms,\n    use_gfnff=True,\n    library=None,\n    keyword_swaps=None,\n    option_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Carry out a single-point calculation.</p> Note <p>Keyword Defaults:</p> <pre><code>{\n    \"gfnff\": True if use_gfnff else None,\n    \"gwolf\": True if use_gfnff and atoms.pbc.any() else None,\n}\n</code></pre> <p>Option Defaultss:</p> <pre><code>{\n    \"dump every gulp.res\": True,\n    f\"output cif {GEOM_FILE_PBC}\": True if atoms.pbc.any() else None,\n    f\"output xyz {GEOM_FILE_NOPBC}\": None if atoms.pbc.any() else True,\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>use_gfnff</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>True if (p)GFN-FF should be used; False if not.</p> </li> <li> <code>library</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Filename of the potential library file, if required.</p> </li> <li> <code>keyword_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom keyword swap kwargs for the calculator.</p> </li> <li> <code>option_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom option swap kwargs for the calculator.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/gulp/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms | dict,\n    use_gfnff: bool = True,\n    library: str | None = None,\n    keyword_swaps: dict | None = None,\n    option_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    ??? Note\n\n        Keyword Defaults:\n\n        ```python\n        {\n            \"gfnff\": True if use_gfnff else None,\n            \"gwolf\": True if use_gfnff and atoms.pbc.any() else None,\n        }\n        ```\n\n        Option Defaultss:\n\n        ```python\n        {\n            \"dump every gulp.res\": True,\n            f\"output cif {GEOM_FILE_PBC}\": True if atoms.pbc.any() else None,\n            f\"output xyz {GEOM_FILE_NOPBC}\": None if atoms.pbc.any() else True,\n        }\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    use_gfnff\n        True if (p)GFN-FF should be used; False if not.\n    library\n        Filename of the potential library file, if required.\n    keyword_swaps\n        Dictionary of custom keyword swap kwargs for the calculator.\n    option_swaps\n        Dictionary of custom option swap kwargs for the calculator.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n\n    keyword_defaults = {\n        \"gfnff\": True if use_gfnff else None,\n        \"gwolf\": True if use_gfnff else None,\n    }\n    option_defaults = {\"dump every gulp.res\": True}\n\n    return _base_job(\n        atoms,\n        library=library,\n        keyword_defaults=keyword_defaults,\n        option_defaults=option_defaults,\n        keyword_swaps=keyword_swaps,\n        option_swaps=option_swaps,\n        additional_fields={\"name\": \"GULP Static\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/lj/core.html","title":"core","text":"<p>Core recipes for Lennard-Jones Potential</p> <p>NOTE: This set of minimal recipes is mainly for demonstration purposes</p>"},{"location":"reference/quacc/recipes/lj/core.html#quacc.recipes.lj.core.freq_job","title":"freq_job","text":"<pre><code>freq_job(\n    atoms,\n    energy=0.0,\n    temperature=298.15,\n    pressure=1.0,\n    calc_swaps=None,\n    vib_kwargs=None,\n    copy_files=None,\n)\n</code></pre> <p>Run a frequency job and calculate thermochemistry.</p> Note <p>Calculator Defaults:</p> <pre><code>{}\n</code></pre> <p>Vibrations Defaults:</p> <pre><code>{}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>energy</code>             (<code>float</code>, default:                 <code>0.0</code> )         \u2013          <p>Potential energy in eV. If 0, then the output is just the correction.</p> </li> <li> <code>temperature</code>             (<code>float</code>, default:                 <code>298.15</code> )         \u2013          <p>Temperature in Kelvins.</p> </li> <li> <code>pressure</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Pressure in bar.</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>dictionary of custom kwargs for the LJ calculator.</p> </li> <li> <code>vib_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>dictionary of custom kwargs for the Vibrations object.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VibThermoSchema</code>         \u2013          <p>Dictionary of results, specified in quacc.schemas.ase.summarize_vib_and_thermo</p> </li> </ul> Source code in <code>quacc/recipes/lj/core.py</code> <pre><code>@job\ndef freq_job(\n    atoms: Atoms | dict,\n    energy: float = 0.0,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    calc_swaps: dict | None = None,\n    vib_kwargs: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; VibThermoSchema:\n    \"\"\"\n    Run a frequency job and calculate thermochemistry.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {}\n        ```\n\n        Vibrations Defaults:\n\n        ```python\n        {}\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    energy\n        Potential energy in eV. If 0, then the output is just the correction.\n    temperature\n        Temperature in Kelvins.\n    pressure\n        Pressure in bar.\n    calc_swaps\n        dictionary of custom kwargs for the LJ calculator.\n    vib_kwargs\n        dictionary of custom kwargs for the Vibrations object.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    VibThermoSchema\n        Dictionary of results, specified in [quacc.schemas.ase.summarize_vib_and_thermo][]\n    \"\"\"\n    atoms = fetch_atoms(atoms)\n    calc_swaps = calc_swaps or {}\n    vib_kwargs = vib_kwargs or {}\n\n    atoms.calc = LennardJones(**calc_swaps)\n    vibrations = run_ase_vib(atoms, vib_kwargs=vib_kwargs, copy_files=copy_files)\n    igt = build_ideal_gas(atoms, vibrations.get_frequencies(), energy=energy)\n\n    return summarize_vib_and_thermo(\n        vibrations,\n        igt,\n        temperature=temperature,\n        pressure=pressure,\n        additional_fields={\"name\": \"LJ Frequency and Thermo\"},\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/lj/core.html#quacc.recipes.lj.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms, calc_swaps=None, opt_swaps=None, copy_files=None\n)\n</code></pre> <p>Function to carry out a geometry optimization.</p> Note <p>Calculator Defaults:</p> <pre><code>{}\n</code></pre> <p>Optimizer Defaults:</p> <pre><code>{\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": FIRE}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the LJ calculator.</p> </li> <li> <code>opt_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of swaps for quacc.runners.calc.run_ase_opt.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results, specified in quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/lj/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms | dict,\n    calc_swaps: dict | None = None,\n    opt_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; OptSchema:\n    \"\"\"\n    Function to carry out a geometry optimization.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {}\n        ```\n\n        Optimizer Defaults:\n\n        ```python\n        {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": FIRE}\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    calc_swaps\n        Dictionary of custom kwargs for the LJ calculator.\n    opt_swaps\n        Dictionary of swaps for [quacc.runners.calc.run_ase_opt][].\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results, specified in [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n    atoms = fetch_atoms(atoms)\n    calc_swaps = calc_swaps or {}\n\n    opt_defaults = {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": FIRE}\n    opt_flags = merge_dicts(opt_defaults, opt_swaps)\n\n    atoms.calc = LennardJones(**calc_swaps)\n    dyn = run_ase_opt(atoms, copy_files=copy_files, **opt_flags)\n\n    return summarize_opt_run(dyn, additional_fields={\"name\": \"LJ Relax\"})\n</code></pre>"},{"location":"reference/quacc/recipes/lj/core.html#quacc.recipes.lj.core.static_job","title":"static_job","text":"<pre><code>static_job(atoms, calc_swaps=None, copy_files=None)\n</code></pre> <p>Function to carry out a static calculation.</p> Note <p>Calculator Defaults:</p> <pre><code>{}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the LJ calculator.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results, specified in quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/lj/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms | dict,\n    calc_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Function to carry out a static calculation.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {}\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    calc_swaps\n        Dictionary of custom kwargs for the LJ calculator.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results, specified in [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n    atoms = fetch_atoms(atoms)\n    calc_swaps = calc_swaps or {}\n\n    atoms.calc = LennardJones(**calc_swaps)\n    final_atoms = run_calc(atoms, copy_files=copy_files)\n\n    return summarize_run(\n        final_atoms, input_atoms=atoms, additional_fields={\"name\": \"LJ Static\"}\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/core.html","title":"core","text":"<p>Core recipes for the NewtonNet code</p>"},{"location":"reference/quacc/recipes/newtonnet/core.html#quacc.recipes.newtonnet.core.freq_job","title":"freq_job","text":"<pre><code>freq_job(\n    atoms,\n    temperature=298.15,\n    pressure=1.0,\n    calc_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Perform a frequency calculation using the given atoms object.</p> Note <p>Calculator Defaults:</p> <pre><code>{\n    \"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n    \"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>The atoms object representing the system.</p> </li> <li> <code>temperature</code>             (<code>float</code>, default:                 <code>298.15</code> )         \u2013          <p>The temperature for the thermodynamic analysis.</p> </li> <li> <code>pressure</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>The pressure for the thermodynamic analysis.</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional swaps for the calculator.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>FreqSchema</code>         \u2013          <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/newtonnet/core.py</code> <pre><code>@job\n@requires(NewtonNet, \"NewtonNet must be installed. Refer to the quacc documentation.\")\ndef freq_job(\n    atoms: Atoms | dict,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    calc_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; FreqSchema:\n    \"\"\"\n    Perform a frequency calculation using the given atoms object.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\n            \"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n            \"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n        }\n        ```\n\n    Parameters\n    ----------\n    atoms\n        The atoms object representing the system.\n    temperature\n        The temperature for the thermodynamic analysis.\n    pressure\n        The pressure for the thermodynamic analysis.\n    calc_swaps\n        Optional swaps for the calculator.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    FreqSchema\n        Dictionary of results\n    \"\"\"\n    atoms = fetch_atoms(atoms)\n\n    defaults = {\n        \"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n        \"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n    }\n    flags = merge_dicts(defaults, calc_swaps)\n\n    ml_calculator = NewtonNet(**flags)\n    atoms.calc = ml_calculator\n    final_atoms = run_calc(atoms, copy_files=copy_files)\n\n    summary = summarize_run(\n        final_atoms,\n        input_atoms=atoms,\n        additional_fields={\"name\": \"NewtonNet Hessian\"},\n    )\n    energy = summary[\"results\"][\"energy\"]\n    hessian = summary[\"results\"][\"hessian\"]\n\n    vib = VibrationsData(final_atoms, hessian)\n    summary[\"vib\"] = summarize_vib_run(\n        vib, additional_fields={\"name\": \"ASE Vibrations Analysis\"}\n    )\n\n    igt = build_ideal_gas(final_atoms, vib.get_frequencies(), energy=energy)\n    summary[\"thermo\"] = summarize_ideal_gas_thermo(\n        igt,\n        temperature=temperature,\n        pressure=pressure,\n        additional_fields={\"name\": \"ASE Thermo Analysis\"},\n    )\n\n    return summary\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/core.html#quacc.recipes.newtonnet.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms, calc_swaps=None, opt_swaps=None, copy_files=None\n)\n</code></pre> <p>Relax a structure.</p> Note <p>Calculator Defaults:</p> <pre><code>{\n    \"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n    \"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n}\n</code></pre> <p>Optimizer Defaults:</p> <pre><code>{\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": Sella or FIRE}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the newtonnet calculator.</p> </li> <li> <code>opt_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional swaps for the optimization parameters.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results, specified in quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>quacc/recipes/newtonnet/core.py</code> <pre><code>@job\n@requires(NewtonNet, \"NewtonNet must be installed. Refer to the quacc documentation.\")\ndef relax_job(\n    atoms: Atoms | dict,\n    calc_swaps: dict | None = None,\n    opt_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; OptSchema:\n    \"\"\"\n    Relax a structure.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\n            \"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n            \"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n        }\n        ```\n\n        Optimizer Defaults:\n\n        ```python\n        {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": Sella or FIRE}\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    calc_swaps\n        Dictionary of custom kwargs for the newtonnet calculator.\n    opt_swaps\n        Optional swaps for the optimization parameters.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results, specified in [quacc.schemas.ase.summarize_opt_run][]\n    \"\"\"\n    atoms = fetch_atoms(atoms)\n\n    defaults = {\n        \"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n        \"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n    }\n    opt_defaults = {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": Sella or FIRE}\n\n    flags = merge_dicts(defaults, calc_swaps)\n    opt_flags = merge_dicts(opt_defaults, opt_swaps)\n\n    atoms.calc = NewtonNet(**flags)\n    dyn = run_ase_opt(atoms, copy_files=copy_files, **opt_flags)\n\n    return _add_stdev_and_hess(\n        summarize_opt_run(dyn, additional_fields={\"name\": \"NewtonNet Relax\"})\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/core.html#quacc.recipes.newtonnet.core.static_job","title":"static_job","text":"<pre><code>static_job(atoms, calc_swaps=None, copy_files=None)\n</code></pre> <p>Carry out a single-point calculation.</p> Note <p>Calculator Defaults:</p> <pre><code>{\n    \"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n    \"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the newtonnet calculator.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results, specified in quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/newtonnet/core.py</code> <pre><code>@job\n@requires(NewtonNet, \"NewtonNet must be installed. Refer to the quacc documentation.\")\ndef static_job(\n    atoms: Atoms | dict,\n    calc_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\n            \"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n            \"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n        }\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    calc_swaps\n        Dictionary of custom kwargs for the newtonnet calculator.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results, specified in [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n    atoms = fetch_atoms(atoms)\n\n    defaults = {\n        \"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n        \"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n    }\n    flags = merge_dicts(defaults, calc_swaps)\n\n    atoms.calc = NewtonNet(**flags)\n    final_atoms = run_calc(atoms, copy_files=copy_files)\n\n    return summarize_run(\n        final_atoms,\n        input_atoms=atoms,\n        additional_fields={\"name\": \"NewtonNet Static\"},\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/ts.html","title":"ts","text":"<p>Transition state recipes for the NewtonNet code</p>"},{"location":"reference/quacc/recipes/newtonnet/ts.html#quacc.recipes.newtonnet.ts.irc_job","title":"irc_job","text":"<pre><code>irc_job(\n    atoms,\n    direction=\"forward\",\n    run_freq=True,\n    freq_job_kwargs=None,\n    calc_swaps=None,\n    opt_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Perform an intrinsic reaction coordinate (IRC) job using the given atoms object.</p> Note <p>Calculator Defaults:</p> <pre><code>{\n    \"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n    \"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n}\n</code></pre> <p>IRC Defaults:</p> <pre><code>{\n    \"fmax\": 0.01,\n    \"max_steps\": 1000,\n    \"optimizer\": IRC,\n    \"optimizer_kwargs\": {\n        \"dx\": 0.1,\n        \"eta\": 1e-4,\n        \"gamma\": 0.4,\n        \"keep_going\": True,\n    },\n    \"run_kwargs\": {\n        \"direction\": direction,\n    },\n}\n</code></pre> <p>Optimizer Defaults:</p> <pre><code>{}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>The atoms object representing the system.</p> </li> <li> <code>direction</code>             (<code>Literal['forward', 'reverse']</code>, default:                 <code>'forward'</code> )         \u2013          <p>The direction of the IRC calculation (\"forward\" or \"reverse\").</p> </li> <li> <code>run_freq</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to run the frequency analysis.</p> </li> <li> <code>freq_job_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Keyword arguments for the <code>freq_job</code>.</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional swaps for the calculator.</p> </li> <li> <code>opt_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional swaps for the optimization parameters.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>IRCSchema</code>         \u2013          <p>A dictionary containing the IRC summary and thermodynamic summary.</p> </li> </ul> Source code in <code>quacc/recipes/newtonnet/ts.py</code> <pre><code>@job\n@requires(NewtonNet, \"NewtonNet must be installed. Refer to the quacc documentation.\")\n@requires(Sella, \"Sella must be installed. Refer to the quacc documentation.\")\ndef irc_job(\n    atoms: Atoms | dict,\n    direction: Literal[\"forward\", \"reverse\"] = \"forward\",\n    run_freq: bool = True,\n    freq_job_kwargs: dict | None = None,\n    calc_swaps: dict | None = None,\n    opt_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; IRCSchema:\n    \"\"\"\n    Perform an intrinsic reaction coordinate (IRC) job using the given atoms\n    object.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\n            \"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n            \"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n        }\n        ```\n\n        IRC Defaults:\n\n        ```python\n        {\n            \"fmax\": 0.01,\n            \"max_steps\": 1000,\n            \"optimizer\": IRC,\n            \"optimizer_kwargs\": {\n                \"dx\": 0.1,\n                \"eta\": 1e-4,\n                \"gamma\": 0.4,\n                \"keep_going\": True,\n            },\n            \"run_kwargs\": {\n                \"direction\": direction,\n            },\n        }\n        ```\n\n        Optimizer Defaults:\n\n        ```python\n        {}\n        ```\n\n    Parameters\n    ----------\n    atoms\n        The atoms object representing the system.\n    direction\n        The direction of the IRC calculation (\"forward\" or \"reverse\").\n    run_freq\n        Whether to run the frequency analysis.\n    freq_job_kwargs\n        Keyword arguments for the `freq_job`.\n    calc_swaps\n        Optional swaps for the calculator.\n    opt_swaps\n        Optional swaps for the optimization parameters.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    IRCSchema\n        A dictionary containing the IRC summary and thermodynamic summary.\n    \"\"\"\n    atoms = fetch_atoms(atoms)\n    freq_job_kwargs = freq_job_kwargs or {}\n    default_settings = SETTINGS.copy()\n\n    defaults = {\n        \"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n        \"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n    }\n    opt_defaults = {\n        \"fmax\": 0.01,\n        \"max_steps\": 1000,\n        \"optimizer\": IRC,\n        \"optimizer_kwargs\": {\n            \"dx\": 0.1,\n            \"eta\": 1e-4,\n            \"gamma\": 0.4,\n            \"keep_going\": True,\n        },\n        \"run_kwargs\": {\n            \"direction\": direction,\n        },\n    }\n\n    flags = merge_dicts(defaults, calc_swaps)\n    opt_flags = merge_dicts(opt_defaults, opt_swaps)\n\n    # Define calculator\n    atoms.calc = NewtonNet(**flags)\n\n    # Run IRC\n    SETTINGS.CHECK_CONVERGENCE = False\n    dyn = run_ase_opt(atoms, copy_files=copy_files, **opt_flags)\n    opt_irc_summary = _add_stdev_and_hess(\n        summarize_opt_run(\n            dyn, additional_fields={\"name\": f\"NewtonNet IRC: {direction}\"}\n        )\n    )\n    SETTINGS.CHECK_CONVERGENCE = default_settings.CHECK_CONVERGENCE\n\n    # Run frequency job\n    freq_summary = (\n        freq_job.__wrapped__(opt_irc_summary, **freq_job_kwargs) if run_freq else None\n    )\n    opt_irc_summary[\"freq_job\"] = freq_summary\n\n    return opt_irc_summary\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/ts.html#quacc.recipes.newtonnet.ts.quasi_irc_job","title":"quasi_irc_job","text":"<pre><code>quasi_irc_job(\n    atoms,\n    direction=\"forward\",\n    run_freq=True,\n    irc_job_kwargs=None,\n    relax_job_kwargs=None,\n    freq_job_kwargs=None,\n    copy_files=None,\n)\n</code></pre> <p>Perform a quasi-IRC job using the given atoms object.</p> Note <p>IRC Defaults:</p> <pre><code>{\"max_steps\": 5}\n</code></pre> <p>Optimizer Defaults:</p> <pre><code>{}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>The atoms object representing the system.</p> </li> <li> <code>direction</code>             (<code>Literal['forward', 'reverse']</code>, default:                 <code>'forward'</code> )         \u2013          <p>The direction of the IRC calculation (\"forward\" or \"reverse\").</p> </li> <li> <code>run_freq</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to run the frequency analysis.</p> </li> <li> <code>irc_job_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Keyword arguments for <code>irc_job</code></p> </li> <li> <code>relax_job_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Keyword arguments for <code>relax_job</code></p> </li> <li> <code>freq_job_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Keyword arguments for <code>freq_job</code>.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>QuasiIRCSchema</code>         \u2013          <p>A dictionary containing the IRC summary, optimization summary, and thermodynamic summary.</p> </li> </ul> Source code in <code>quacc/recipes/newtonnet/ts.py</code> <pre><code>@job\n@requires(NewtonNet, \"NewtonNet must be installed. Refer to the quacc documentation.\")\n@requires(Sella, \"Sella must be installed. Refer to the quacc documentation.\")\ndef quasi_irc_job(\n    atoms: Atoms | dict,\n    direction: Literal[\"forward\", \"reverse\"] = \"forward\",\n    run_freq: bool = True,\n    irc_job_kwargs: dict | None = None,\n    relax_job_kwargs: dict | None = None,\n    freq_job_kwargs: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; QuasiIRCSchema:\n    \"\"\"\n    Perform a quasi-IRC job using the given atoms object.\n\n    ??? Note\n\n        IRC Defaults:\n\n        ```python\n        {\"max_steps\": 5}\n        ```\n\n        Optimizer Defaults:\n\n        ```python\n        {}\n        ```\n\n    Parameters\n    ----------\n    atoms\n        The atoms object representing the system.\n    direction\n        The direction of the IRC calculation (\"forward\" or \"reverse\").\n    run_freq\n        Whether to run the frequency analysis.\n    irc_job_kwargs\n        Keyword arguments for `irc_job`\n    relax_job_kwargs\n        Keyword arguments for `relax_job`\n    freq_job_kwargs\n        Keyword arguments for `freq_job`.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    QuasiIRCSchema\n        A dictionary containing the IRC summary, optimization summary, and\n        thermodynamic summary.\n    \"\"\"\n    relax_job_kwargs = relax_job_kwargs or {}\n    freq_job_kwargs = freq_job_kwargs or {}\n\n    irc_job_defaults = {\"calc_swaps\": {\"max_steps\": 5}}\n    irc_job_kwargs = merge_dicts(irc_job_defaults, irc_job_kwargs)\n\n    # Run IRC\n    irc_summary = irc_job.__wrapped__(\n        atoms,\n        direction=direction,\n        run_freq=False,\n        copy_files=copy_files,\n        **irc_job_kwargs,\n    )\n\n    # Run opt\n    relax_summary = relax_job.__wrapped__(irc_summary, **relax_job_kwargs)\n\n    # Run frequency\n    freq_summary = (\n        freq_job.__wrapped__(relax_summary, **freq_job_kwargs) if run_freq else None\n    )\n    relax_summary[\"freq_job\"] = freq_summary\n    relax_summary[\"irc_job\"] = irc_summary\n\n    return relax_summary\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/ts.html#quacc.recipes.newtonnet.ts.ts_job","title":"ts_job","text":"<pre><code>ts_job(\n    atoms,\n    use_custom_hessian=False,\n    run_freq=True,\n    freq_job_kwargs=None,\n    calc_swaps=None,\n    opt_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Perform a transition state (TS) job using the given atoms object.</p> Note <p>Calculator Defaults:</p> <pre><code>{\n    \"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n    \"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n}\n</code></pre> <p>Optimizer Defaults:</p> <pre><code>{\n    \"fmax\": 0.01,\n    \"max_steps\": 1000,\n    \"optimizer\": Sella,\n    \"optimizer_kwargs\": {\"diag_every_n\": 0, \"order\": 1}\n    if use_custom_hessian\n    else {\"order\": 1},\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>The atoms object representing the system.</p> </li> <li> <code>use_custom_hessian</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to use a custom Hessian matrix.</p> </li> <li> <code>run_freq</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to run the frequency job.</p> </li> <li> <code>freq_job_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Keyword arguments to use for the <code>freq_job</code>.</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional swaps for the NewtonNet calculator.</p> </li> <li> <code>opt_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional swaps for the optimization parameters.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TSSchema</code>         \u2013          <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/newtonnet/ts.py</code> <pre><code>@job\n@requires(NewtonNet, \"NewtonNet must be installed. Refer to the quacc documentation.\")\n@requires(Sella, \"Sella must be installed. Refer to the quacc documentation.\")\ndef ts_job(\n    atoms: Atoms | dict,\n    use_custom_hessian: bool = False,\n    run_freq: bool = True,\n    freq_job_kwargs: dict | None = None,\n    calc_swaps: dict | None = None,\n    opt_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; TSSchema:\n    \"\"\"\n    Perform a transition state (TS) job using the given atoms object.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\n            \"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n            \"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n        }\n        ```\n\n        Optimizer Defaults:\n\n        ```python\n        {\n            \"fmax\": 0.01,\n            \"max_steps\": 1000,\n            \"optimizer\": Sella,\n            \"optimizer_kwargs\": {\"diag_every_n\": 0, \"order\": 1}\n            if use_custom_hessian\n            else {\"order\": 1},\n        }\n        ```\n\n    Parameters\n    ----------\n    atoms\n        The atoms object representing the system.\n    use_custom_hessian\n        Whether to use a custom Hessian matrix.\n    run_freq\n        Whether to run the frequency job.\n    freq_job_kwargs\n        Keyword arguments to use for the `freq_job`.\n    calc_swaps\n        Optional swaps for the NewtonNet calculator.\n    opt_swaps\n        Optional swaps for the optimization parameters.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    TSSchema\n        Dictionary of results\n    \"\"\"\n    atoms = fetch_atoms(atoms)\n    freq_job_kwargs = freq_job_kwargs or {}\n\n    defaults = {\n        \"model_path\": SETTINGS.NEWTONNET_MODEL_PATH,\n        \"settings_path\": SETTINGS.NEWTONNET_CONFIG_PATH,\n    }\n    opt_defaults = {\n        \"fmax\": 0.01,\n        \"max_steps\": 1000,\n        \"optimizer\": Sella,\n        \"optimizer_kwargs\": {\"diag_every_n\": 0, \"order\": 1}\n        if use_custom_hessian\n        else {\"order\": 1},\n    }\n\n    flags = merge_dicts(defaults, calc_swaps)\n    opt_flags = merge_dicts(opt_defaults, opt_swaps)\n\n    atoms.calc = NewtonNet(**flags)\n\n    if use_custom_hessian:\n        opt_flags[\"optimizer_kwargs\"][\"hessian_function\"] = _get_hessian\n\n    ml_calculator = NewtonNet(**flags)\n    atoms.calc = ml_calculator\n\n    # Run the TS optimization\n    dyn = run_ase_opt(atoms, copy_files=copy_files, **opt_flags)\n    opt_ts_summary = _add_stdev_and_hess(\n        summarize_opt_run(dyn, additional_fields={\"name\": \"NewtonNet TS\"})\n    )\n\n    # Run a frequency calculation\n    freq_summary = (\n        freq_job.__wrapped__(opt_ts_summary, **freq_job_kwargs) if run_freq else None\n    )\n    opt_ts_summary[\"freq_job\"] = freq_summary\n\n    return opt_ts_summary\n</code></pre>"},{"location":"reference/quacc/recipes/orca/core.html","title":"core","text":"<p>Core recipes for ORCA</p>"},{"location":"reference/quacc/recipes/orca/core.html#quacc.recipes.orca.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms,\n    charge,\n    spin_multiplicity,\n    xc=\"wb97x-d3bj\",\n    basis=\"def2-tzvp\",\n    run_freq=False,\n    input_swaps=None,\n    block_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Carry out a geometry optimization.</p> Note <p>Input Defaults:</p> <pre><code>{\n    xc: True,\n    basis: True,\n    \"opt\": True,\n    \"slowconv\": True,\n    \"normalprint\": True,\n    \"freq\": True if run_freq else None,\n    \"xyzfile\": True,\n}\n</code></pre> <p>Block Defaults:</p> <pre><code>(\n    {f\"%pal nprocs {multiprocessing.cpu_count()} end\": True}\n    if which(\"mpirun\")\n    else {}\n)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>charge</code>             (<code>int</code>)         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>)         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>xc</code>             (<code>str</code>, default:                 <code>'wb97x-d3bj'</code> )         \u2013          <p>Exchange-correlation functional</p> </li> <li> <code>basis</code>             (<code>str</code>, default:                 <code>'def2-tzvp'</code> )         \u2013          <p>Basis set</p> </li> <li> <code>run_freq</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If a frequency calculation should be carried out.</p> </li> <li> <code>input_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of orcasimpleinput swaps for the calculator. To enable new entries, set the value as True. To remove entries from the defaults, set the value as None.</p> </li> <li> <code>block_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of orcablock swaps for the calculator. To enable new entries, set the value as True. To remove entries from the defaults, set the value as None.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cclibSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.cclib.cclib_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/orca/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms | dict,\n    charge: int,\n    spin_multiplicity: int,\n    xc: str = \"wb97x-d3bj\",\n    basis: str = \"def2-tzvp\",\n    run_freq: bool = False,\n    input_swaps: dict | None = None,\n    block_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; cclibSchema:\n    \"\"\"\n    Carry out a geometry optimization.\n\n    ??? Note\n\n        Input Defaults:\n\n        ```python\n        {\n            xc: True,\n            basis: True,\n            \"opt\": True,\n            \"slowconv\": True,\n            \"normalprint\": True,\n            \"freq\": True if run_freq else None,\n            \"xyzfile\": True,\n        }\n        ```\n\n        Block Defaults:\n\n        ```python\n        (\n            {f\"%pal nprocs {multiprocessing.cpu_count()} end\": True}\n            if which(\"mpirun\")\n            else {}\n        )\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    run_freq\n        If a frequency calculation should be carried out.\n    input_swaps\n        Dictionary of orcasimpleinput swaps for the calculator. To enable new\n        entries, set the value as True. To remove entries from the defaults, set\n        the value as None.\n    block_swaps\n        Dictionary of orcablock swaps for the calculator. To enable new entries,\n        set the value as True. To remove entries from the defaults, set the\n        value as None.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    cclibSchema\n        Dictionary of results from [quacc.schemas.cclib.cclib_summarize_run][]\n    \"\"\"\n\n    default_inputs = {\n        xc: True,\n        basis: True,\n        \"opt\": True,\n        \"slowconv\": True,\n        \"normalprint\": True,\n        \"freq\": True if run_freq else None,\n        \"xyzfile\": True,\n    }\n    default_blocks = (\n        {f\"%pal nprocs {multiprocessing.cpu_count()} end\": True}\n        if which(\"mpirun\")\n        else {}\n    )\n\n    return _base_job(\n        atoms,\n        charge,\n        spin_multiplicity,\n        default_inputs=default_inputs,\n        default_blocks=default_blocks,\n        input_swaps=input_swaps,\n        block_swaps=block_swaps,\n        additional_fields={\"name\": \"ORCA Relax\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/orca/core.html#quacc.recipes.orca.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms,\n    charge,\n    spin_multiplicity,\n    xc=\"wb97x-d3bj\",\n    basis=\"def2-tzvp\",\n    input_swaps=None,\n    block_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Carry out a single-point calculation.</p> Note <p>Input Defaults:</p> <pre><code>{\n    xc: True,\n    basis: True,\n    \"sp\": True,\n    \"slowconv\": True,\n    \"normalprint\": True,\n    \"xyzfile\": True,\n}\n</code></pre> <p>Block Defaults:</p> <pre><code>(\n    {f\"%pal nprocs {multiprocessing.cpu_count()} end\": True}\n    if which(\"mpirun\")\n    else {}\n)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>charge</code>             (<code>int</code>)         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>)         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>xc</code>             (<code>str</code>, default:                 <code>'wb97x-d3bj'</code> )         \u2013          <p>Exchange-correlation functional</p> </li> <li> <code>basis</code>             (<code>str</code>, default:                 <code>'def2-tzvp'</code> )         \u2013          <p>Basis set</p> </li> <li> <code>input_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of orcasimpleinput swaps for the calculator. To enable new entries, set the value as True. To remove entries from the defaults, set the value as None.</p> </li> <li> <code>block_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of orcablock swaps for the calculator. To enable new entries, set the value as True. To remove entries from the defaults, set the value as None.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>cclibSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.cclib.cclib_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/orca/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms | dict,\n    charge: int,\n    spin_multiplicity: int,\n    xc: str = \"wb97x-d3bj\",\n    basis: str = \"def2-tzvp\",\n    input_swaps: dict | None = None,\n    block_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; cclibSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    ??? Note\n\n        Input Defaults:\n\n        ```python\n        {\n            xc: True,\n            basis: True,\n            \"sp\": True,\n            \"slowconv\": True,\n            \"normalprint\": True,\n            \"xyzfile\": True,\n        }\n        ```\n\n        Block Defaults:\n\n        ```python\n        (\n            {f\"%pal nprocs {multiprocessing.cpu_count()} end\": True}\n            if which(\"mpirun\")\n            else {}\n        )\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    input_swaps\n        Dictionary of orcasimpleinput swaps for the calculator. To enable new\n        entries, set the value as True. To remove entries from the defaults, set\n        the value as None.\n    block_swaps\n        Dictionary of orcablock swaps for the calculator. To enable new entries,\n        set the value as True. To remove entries from the defaults, set the\n        value as None.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    cclibSchema\n        Dictionary of results from [quacc.schemas.cclib.cclib_summarize_run][]\n    \"\"\"\n\n    default_inputs = {\n        xc: True,\n        basis: True,\n        \"sp\": True,\n        \"slowconv\": True,\n        \"normalprint\": True,\n        \"xyzfile\": True,\n    }\n    default_blocks = (\n        {f\"%pal nprocs {multiprocessing.cpu_count()} end\": True}\n        if which(\"mpirun\")\n        else {}\n    )\n\n    return _base_job(\n        atoms,\n        charge,\n        spin_multiplicity,\n        default_inputs=default_inputs,\n        default_blocks=default_blocks,\n        input_swaps=input_swaps,\n        block_swaps=block_swaps,\n        additional_fields={\"name\": \"ORCA Static\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/psi4/core.html","title":"core","text":"<p>Core recipes for Psi4</p>"},{"location":"reference/quacc/recipes/psi4/core.html#quacc.recipes.psi4.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms,\n    charge,\n    spin_multiplicity,\n    method=\"wb97x-v\",\n    basis=\"def2-tzvp\",\n    calc_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Function to carry out a single-point calculation.</p> Note <p>Calculator Defaults:</p> <pre><code>{\n    \"mem\": \"16GB\",\n    \"num_threads\": \"max\",\n    \"method\": method,\n    \"basis\": basis,\n    \"charge\": charge,\n    \"multiplicity\": spin_multiplicity,\n    \"reference\": \"uks\" if spin_multiplicity &gt; 1 else \"rks\",\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>charge</code>             (<code>int</code>)         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>)         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>method</code>             (<code>str</code>, default:                 <code>'wb97x-v'</code> )         \u2013          <p>The level of theory to use.</p> </li> <li> <code>basis</code>             (<code>str</code>, default:                 <code>'def2-tzvp'</code> )         \u2013          <p>Basis set</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. Set a value to <code>None</code> to remove a pre-existing key entirely.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/psi4/core.py</code> <pre><code>@job\n@requires(psi4, \"Psi4 not installed. Try conda install -c psi4 psi4\")\ndef static_job(\n    atoms: Atoms | dict,\n    charge: int,\n    spin_multiplicity: int,\n    method: str = \"wb97x-v\",\n    basis: str = \"def2-tzvp\",\n    calc_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Function to carry out a single-point calculation.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\n            \"mem\": \"16GB\",\n            \"num_threads\": \"max\",\n            \"method\": method,\n            \"basis\": basis,\n            \"charge\": charge,\n            \"multiplicity\": spin_multiplicity,\n            \"reference\": \"uks\" if spin_multiplicity &gt; 1 else \"rks\",\n        }\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    method\n        The level of theory to use.\n    basis\n        Basis set\n    calc_swaps\n        Dictionary of custom kwargs for the calculator. Set a value to `None` to remove\n        a pre-existing key entirely. Set a value to `None` to remove a pre-existing key entirely.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n\n    defaults = {\n        \"mem\": \"16GB\",\n        \"num_threads\": \"max\",\n        \"method\": method,\n        \"basis\": basis,\n        \"charge\": charge,\n        \"multiplicity\": spin_multiplicity,\n        \"reference\": \"uks\" if spin_multiplicity &gt; 1 else \"rks\",\n    }\n    return _base_job(\n        atoms,\n        charge,\n        spin_multiplicity,\n        defaults=defaults,\n        calc_swaps=calc_swaps,\n        additional_fields={\"name\": \"Psi4 Static\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/core.html","title":"core","text":"<p>Core recipes for the Q-Chem</p>"},{"location":"reference/quacc/recipes/qchem/core.html#quacc.recipes.qchem.core.freq_job","title":"freq_job","text":"<pre><code>freq_job(\n    atoms,\n    charge,\n    spin_multiplicity,\n    method=\"wb97mv\",\n    basis=\"def2-svpd\",\n    scf_algorithm=\"diis\",\n    pcm_dielectric=None,\n    smd_solvent=None,\n    n_cores=None,\n    overwrite_inputs=None,\n    copy_files=None,\n)\n</code></pre> <p>Perform a frequency calculation on a molecular structure.</p> Note <p>Calculator Defaults:</p> <pre><code>{\n    \"job_type\": \"freq\",\n    \"basis_set\": basis,\n    \"scf_algorithm\": scf_algorithm,\n    \"method\": method,\n    \"charge\": charge,\n    \"spin_multiplicity\": spin_multiplicity,\n    \"cores\": n_cores or multiprocessing.cpu_count(),\n    \"qchem_input_params\": {\n        \"pcm_dielectric\": pcm_dielectric,\n        \"smd_solvent\": smd_solvent,\n        \"overwrite_inputs\": overwrite_inputs,\n        \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n    },\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>charge</code>             (<code>int</code>)         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>)         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>method</code>             (<code>str</code>, default:                 <code>'wb97mv'</code> )         \u2013          <p>DFT exchange-correlation functional or other electronic structure method. Defaults to wB97M-V.</p> </li> <li> <code>basis</code>             (<code>str</code>, default:                 <code>'def2-svpd'</code> )         \u2013          <p>Basis set. Defaults to def2-SVPD.</p> </li> <li> <code>scf_algorithm</code>             (<code>str</code>, default:                 <code>'diis'</code> )         \u2013          <p>Algorithm used to converge the SCF. Defaults to \"diis\", but for particularly difficult cases, \"gdm\" should be employed instead.</p> </li> <li> <code>pcm_dielectric</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Dielectric constant of the optional polarizable continuum impicit solvation model. Defaults to None, in which case PCM will not be employed.</p> </li> <li> <code>smd_solvent</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Solvent to use for SMD implicit solvation model. Examples include \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem manual for a complete list of solvents available. Defaults to None, in which case SMD will not be employed.</p> </li> <li> <code>n_cores</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Number of cores to use for the Q-Chem calculation. Defaults to use all cores available on a given node.</p> </li> <li> <code>overwrite_inputs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary passed to <code>pymatgen.io.qchem.QChemDictSet</code> which can modify default values set therein as well as set additional Q-Chem parameters. See QChemDictSet documentation for more details.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/qchem/core.py</code> <pre><code>@job\ndef freq_job(\n    atoms: Atoms | dict,\n    charge: int,\n    spin_multiplicity: int,\n    method: str = \"wb97mv\",\n    basis: str = \"def2-svpd\",\n    scf_algorithm: str = \"diis\",\n    pcm_dielectric: str | None = None,\n    smd_solvent: str | None = None,\n    n_cores: int | None = None,\n    overwrite_inputs: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Perform a frequency calculation on a molecular structure.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\n            \"job_type\": \"freq\",\n            \"basis_set\": basis,\n            \"scf_algorithm\": scf_algorithm,\n            \"method\": method,\n            \"charge\": charge,\n            \"spin_multiplicity\": spin_multiplicity,\n            \"cores\": n_cores or multiprocessing.cpu_count(),\n            \"qchem_input_params\": {\n                \"pcm_dielectric\": pcm_dielectric,\n                \"smd_solvent\": smd_solvent,\n                \"overwrite_inputs\": overwrite_inputs,\n                \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n            },\n        }\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    method\n        DFT exchange-correlation functional or other electronic structure\n        method. Defaults to wB97M-V.\n    basis\n        Basis set. Defaults to def2-SVPD.\n    scf_algorithm\n        Algorithm used to converge the SCF. Defaults to \"diis\", but for\n        particularly difficult cases, \"gdm\" should be employed instead.\n    pcm_dielectric\n        Dielectric constant of the optional polarizable continuum impicit\n        solvation model. Defaults to None, in which case PCM will not be\n        employed.\n    smd_solvent\n        Solvent to use for SMD implicit solvation model. Examples include\n        \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem\n        manual for a complete list of solvents available. Defaults to None, in\n        which case SMD will not be employed.\n    n_cores\n        Number of cores to use for the Q-Chem calculation. Defaults to use all\n        cores available on a given node.\n    overwrite_inputs\n        Dictionary passed to `pymatgen.io.qchem.QChemDictSet` which can modify\n        default values set therein as well as set additional Q-Chem parameters.\n        See QChemDictSet documentation for more details.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n\n    defaults = {\n        \"job_type\": \"freq\",\n        \"basis_set\": basis,\n        \"scf_algorithm\": scf_algorithm,\n        \"method\": method,\n        \"charge\": charge,\n        \"spin_multiplicity\": spin_multiplicity,\n        \"cores\": n_cores or multiprocessing.cpu_count(),\n        \"qchem_input_params\": {\n            \"pcm_dielectric\": pcm_dielectric,\n            \"smd_solvent\": smd_solvent,\n            \"overwrite_inputs\": overwrite_inputs,\n            \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n        },\n    }\n    return _base_job(\n        atoms,\n        charge,\n        spin_multiplicity,\n        defaults=defaults,\n        copy_files=copy_files,\n        additional_fields={\"name\": \"Q-Chem Frequency\"},\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/core.html#quacc.recipes.qchem.core.internal_relax_job","title":"internal_relax_job","text":"<pre><code>internal_relax_job(\n    atoms,\n    charge,\n    spin_multiplicity,\n    method=\"wb97mv\",\n    basis=\"def2-svpd\",\n    scf_algorithm=\"diis\",\n    pcm_dielectric=None,\n    smd_solvent=None,\n    n_cores=None,\n    overwrite_inputs=None,\n    copy_files=None,\n)\n</code></pre> <p>Optimize aka \"relax\" a molecular structure with Q-Chem optimizers.</p> Note <p>Calculator Defaults:</p> <pre><code>{\n    \"job_type\": \"opt\",\n    \"basis_set\": basis,\n    \"scf_algorithm\": scf_algorithm,\n    \"method\": method,\n    \"charge\": charge,\n    \"spin_multiplicity\": spin_multiplicity,\n    \"cores\": n_cores or multiprocessing.cpu_count(),\n    \"qchem_input_params\": {\n        \"pcm_dielectric\": pcm_dielectric,\n        \"smd_solvent\": smd_solvent,\n        \"overwrite_inputs\": overwrite_inputs,\n        \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n    },\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>charge</code>             (<code>int</code>)         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>)         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>method</code>             (<code>str</code>, default:                 <code>'wb97mv'</code> )         \u2013          <p>DFT exchange-correlation functional or other electronic structure method. Defaults to wB97M-V.</p> </li> <li> <code>basis</code>             (<code>str</code>, default:                 <code>'def2-svpd'</code> )         \u2013          <p>Basis set. Defaults to def2-SVPD.</p> </li> <li> <code>scf_algorithm</code>             (<code>str</code>, default:                 <code>'diis'</code> )         \u2013          <p>Algorithm used to converge the SCF. Defaults to \"diis\", but for particularly difficult cases, \"gdm\" should be employed instead.</p> </li> <li> <code>pcm_dielectric</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Dielectric constant of the optional polarizable continuum impicit solvation model. Defaults to None, in which case PCM will not be employed.</p> </li> <li> <code>smd_solvent</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Solvent to use for SMD implicit solvation model. Examples include \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem manual for a complete list of solvents available. Defaults to None, in which case SMD will not be employed.</p> </li> <li> <code>n_cores</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Number of cores to use for the Q-Chem calculation. Defaults to use all cores available on a given node.</p> </li> <li> <code>overwrite_inputs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary passed to <code>pymatgen.io.qchem.QChemDictSet</code> which can modify default values set therein as well as set additional Q-Chem parameters. See QChemDictSet documentation for more details.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/qchem/core.py</code> <pre><code>@job\ndef internal_relax_job(\n    atoms: Atoms | dict,\n    charge: int,\n    spin_multiplicity: int,\n    method: str = \"wb97mv\",\n    basis: str = \"def2-svpd\",\n    scf_algorithm: str = \"diis\",\n    pcm_dielectric: str | None = None,\n    smd_solvent: str | None = None,\n    n_cores: int | None = None,\n    overwrite_inputs: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Optimize aka \"relax\" a molecular structure with Q-Chem optimizers.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\n            \"job_type\": \"opt\",\n            \"basis_set\": basis,\n            \"scf_algorithm\": scf_algorithm,\n            \"method\": method,\n            \"charge\": charge,\n            \"spin_multiplicity\": spin_multiplicity,\n            \"cores\": n_cores or multiprocessing.cpu_count(),\n            \"qchem_input_params\": {\n                \"pcm_dielectric\": pcm_dielectric,\n                \"smd_solvent\": smd_solvent,\n                \"overwrite_inputs\": overwrite_inputs,\n                \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n            },\n        }\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    method\n        DFT exchange-correlation functional or other electronic structure\n        method. Defaults to wB97M-V.\n    basis\n        Basis set. Defaults to def2-SVPD.\n    scf_algorithm\n        Algorithm used to converge the SCF. Defaults to \"diis\", but for\n        particularly difficult cases, \"gdm\" should be employed instead.\n    pcm_dielectric\n        Dielectric constant of the optional polarizable continuum impicit\n        solvation model. Defaults to None, in which case PCM will not be\n        employed.\n    smd_solvent\n        Solvent to use for SMD implicit solvation model. Examples include\n        \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem\n        manual for a complete list of solvents available. Defaults to None, in\n        which case SMD will not be employed.\n    n_cores\n        Number of cores to use for the Q-Chem calculation. Defaults to use all\n        cores available on a given node.\n    overwrite_inputs\n        Dictionary passed to `pymatgen.io.qchem.QChemDictSet` which can modify\n        default values set therein as well as set additional Q-Chem parameters.\n        See QChemDictSet documentation for more details.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n\n    defaults = {\n        \"job_type\": \"opt\",\n        \"basis_set\": basis,\n        \"scf_algorithm\": scf_algorithm,\n        \"method\": method,\n        \"charge\": charge,\n        \"spin_multiplicity\": spin_multiplicity,\n        \"cores\": n_cores or multiprocessing.cpu_count(),\n        \"qchem_input_params\": {\n            \"pcm_dielectric\": pcm_dielectric,\n            \"smd_solvent\": smd_solvent,\n            \"overwrite_inputs\": overwrite_inputs,\n            \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n        },\n    }\n    return _base_job(\n        atoms,\n        charge,\n        spin_multiplicity,\n        defaults=defaults,\n        additional_fields={\"name\": \"Q-Chem Optimization (Internal)\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/core.html#quacc.recipes.qchem.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms,\n    charge,\n    spin_multiplicity,\n    method=\"wb97mv\",\n    basis=\"def2-svpd\",\n    scf_algorithm=\"diis\",\n    pcm_dielectric=None,\n    smd_solvent=None,\n    n_cores=None,\n    overwrite_inputs=None,\n    opt_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Optimize aka \"relax\" a molecular structure with an ASE optimizer.</p> Note <p>Calculator defaults:</p> <pre><code>{\n    \"basis_set\": basis,\n    \"scf_algorithm\": scf_algorithm,\n    \"method\": method,\n    \"charge\": charge,\n    \"spin_multiplicity\": spin_multiplicity,\n    \"cores\": n_cores or multiprocessing.cpu_count(),\n    \"qchem_input_params\": {\n        \"pcm_dielectric\": pcm_dielectric,\n        \"smd_solvent\": smd_solvent,\n        \"overwrite_inputs\": overwrite_inputs,\n        \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n    },\n}\n</code></pre> <p>Optimizer defaults:</p> <pre><code>{\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": Sella if has_sella else FIRE, \"optimizer_kwargs\": {\"use_TRICs\": False}}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>charge</code>             (<code>int</code>)         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>)         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>method</code>             (<code>str</code>, default:                 <code>'wb97mv'</code> )         \u2013          <p>DFT exchange-correlation functional or other electronic structure method. Defaults to wB97M-V.</p> </li> <li> <code>basis</code>             (<code>str</code>, default:                 <code>'def2-svpd'</code> )         \u2013          <p>Basis set. Defaults to def2-SVPD.</p> </li> <li> <code>scf_algorithm</code>             (<code>str</code>, default:                 <code>'diis'</code> )         \u2013          <p>Algorithm used to converge the SCF. Defaults to \"diis\", but for particularly difficult cases, \"gdm\" should be employed instead.</p> </li> <li> <code>pcm_dielectric</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Dielectric constant of the optional polarizable continuum impicit solvation model. Defaults to None, in which case PCM will not be employed.</p> </li> <li> <code>smd_solvent</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Solvent to use for SMD implicit solvation model. Examples include \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem manual for a complete list of solvents available. Defaults to None, in which case SMD will not be employed.</p> </li> <li> <code>n_cores</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Number of cores to use for the Q-Chem calculation. Defaults to use all cores available on a given node.</p> </li> <li> <code>overwrite_inputs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary passed to <code>pymatgen.io.qchem.QChemDictSet</code> which can modify default values set therein as well as set additional Q-Chem parameters. See QChemDictSet documentation for more details.</p> </li> <li> <code>opt_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for quacc.runners.calc.run_ase_opt</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>quacc/recipes/qchem/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms | dict,\n    charge: int,\n    spin_multiplicity: int,\n    method: str = \"wb97mv\",\n    basis: str = \"def2-svpd\",\n    scf_algorithm: str = \"diis\",\n    pcm_dielectric: str | None = None,\n    smd_solvent: str | None = None,\n    n_cores: int | None = None,\n    overwrite_inputs: dict | None = None,\n    opt_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; OptSchema:\n    \"\"\"\n    Optimize aka \"relax\" a molecular structure with an ASE optimizer.\n\n    ??? Note\n\n        Calculator defaults:\n\n        ```python\n        {\n            \"basis_set\": basis,\n            \"scf_algorithm\": scf_algorithm,\n            \"method\": method,\n            \"charge\": charge,\n            \"spin_multiplicity\": spin_multiplicity,\n            \"cores\": n_cores or multiprocessing.cpu_count(),\n            \"qchem_input_params\": {\n                \"pcm_dielectric\": pcm_dielectric,\n                \"smd_solvent\": smd_solvent,\n                \"overwrite_inputs\": overwrite_inputs,\n                \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n            },\n        }\n        ```\n\n        Optimizer defaults:\n\n        ```python\n        {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": Sella if has_sella else FIRE, \"optimizer_kwargs\": {\"use_TRICs\": False}}\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    method\n        DFT exchange-correlation functional or other electronic structure\n        method. Defaults to wB97M-V.\n    basis\n        Basis set. Defaults to def2-SVPD.\n    scf_algorithm\n        Algorithm used to converge the SCF. Defaults to \"diis\", but for\n        particularly difficult cases, \"gdm\" should be employed instead.\n    pcm_dielectric\n        Dielectric constant of the optional polarizable continuum impicit\n        solvation model. Defaults to None, in which case PCM will not be\n        employed.\n    smd_solvent\n        Solvent to use for SMD implicit solvation model. Examples include\n        \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem\n        manual for a complete list of solvents available. Defaults to None, in\n        which case SMD will not be employed.\n    n_cores\n        Number of cores to use for the Q-Chem calculation. Defaults to use all\n        cores available on a given node.\n    overwrite_inputs\n        Dictionary passed to `pymatgen.io.qchem.QChemDictSet` which can modify\n        default values set therein as well as set additional Q-Chem parameters.\n        See QChemDictSet documentation for more details.\n    opt_swaps\n        Dictionary of custom kwargs for [quacc.runners.calc.run_ase_opt][]\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_opt_run][]\n    \"\"\"\n\n    qchem_defaults = {\n        \"basis_set\": basis,\n        \"scf_algorithm\": scf_algorithm,\n        \"method\": method,\n        \"charge\": charge,\n        \"spin_multiplicity\": spin_multiplicity,\n        \"cores\": n_cores or multiprocessing.cpu_count(),\n        \"qchem_input_params\": {\n            \"pcm_dielectric\": pcm_dielectric,\n            \"smd_solvent\": smd_solvent,\n            \"overwrite_inputs\": overwrite_inputs,\n            \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n        },\n    }\n    opt_defaults = {\n        \"fmax\": 0.01,\n        \"max_steps\": 1000,\n        \"optimizer\": Sella if has_sella else FIRE,\n        \"optimizer_kwargs\": {\"use_TRICs\": False},\n    }\n\n    return _base_opt_job(\n        atoms,\n        charge,\n        spin_multiplicity,\n        qchem_defaults=qchem_defaults,\n        opt_defaults=opt_defaults,\n        opt_swaps=opt_swaps,\n        additional_fields={\"name\": \"Q-Chem Optimization\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/core.html#quacc.recipes.qchem.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms,\n    charge,\n    spin_multiplicity,\n    method=\"wb97mv\",\n    basis=\"def2-tzvpd\",\n    scf_algorithm=\"diis\",\n    pcm_dielectric=None,\n    smd_solvent=None,\n    n_cores=None,\n    overwrite_inputs=None,\n    copy_files=None,\n)\n</code></pre> <p>Carry out a single-point calculation.</p> Note <p>Calculator Defaults:</p> <pre><code>{\n\"basis_set\": basis,\n\"scf_algorithm\": scf_algorithm,\n\"method\": method,\n\"charge\": charge,\n\"spin_multiplicity\": spin_multiplicity,\n\"cores\": n_cores or multiprocessing.cpu_count(),\n\"qchem_input_params\": {\n    \"pcm_dielectric\": pcm_dielectric,\n    \"smd_solvent\": smd_solvent,\n    \"overwrite_inputs\": overwrite_inputs,\n    \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n    \"nbo_params\": {\"version\": 7} if SETTINGS.QCHEM_NBO_EXE else None,\n    },\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>charge</code>             (<code>int</code>)         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>)         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>method</code>             (<code>str</code>, default:                 <code>'wb97mv'</code> )         \u2013          <p>DFT exchange-correlation functional or other electronic structure method. Defaults to wB97M-V.</p> </li> <li> <code>basis</code>             (<code>str</code>, default:                 <code>'def2-tzvpd'</code> )         \u2013          <p>Basis set. Defaults to def2-TZVPD.</p> </li> <li> <code>scf_algorithm</code>             (<code>str</code>, default:                 <code>'diis'</code> )         \u2013          <p>Algorithm used to converge the SCF. Defaults to \"diis\", but for particularly difficult cases, \"gdm\" should be employed instead.</p> </li> <li> <code>pcm_dielectric</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Dielectric constant of the optional polarizable continuum impicit solvation model. Defaults to None, in which case PCM will not be employed.</p> </li> <li> <code>smd_solvent</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Solvent to use for SMD implicit solvation model. Examples include \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem manual for a complete list of solvents available. Defaults to None, in which case SMD will not be employed.</p> </li> <li> <code>n_cores</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Number of cores to use for the Q-Chem calculation. Defaults to use all cores available on a given node.</p> </li> <li> <code>overwrite_inputs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary passed to <code>pymatgen.io.qchem.QChemDictSet</code> which can modify default values set therein as well as set additional Q-Chem parameters. See QChemDictSet documentation for more details.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/qchem/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms | dict,\n    charge: int,\n    spin_multiplicity: int,\n    method: str = \"wb97mv\",\n    basis: str = \"def2-tzvpd\",\n    scf_algorithm: str = \"diis\",\n    pcm_dielectric: str | None = None,\n    smd_solvent: str | None = None,\n    n_cores: int | None = None,\n    overwrite_inputs: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\n        \"basis_set\": basis,\n        \"scf_algorithm\": scf_algorithm,\n        \"method\": method,\n        \"charge\": charge,\n        \"spin_multiplicity\": spin_multiplicity,\n        \"cores\": n_cores or multiprocessing.cpu_count(),\n        \"qchem_input_params\": {\n            \"pcm_dielectric\": pcm_dielectric,\n            \"smd_solvent\": smd_solvent,\n            \"overwrite_inputs\": overwrite_inputs,\n            \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n            \"nbo_params\": {\"version\": 7} if SETTINGS.QCHEM_NBO_EXE else None,\n            },\n        }\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    method\n        DFT exchange-correlation functional or other electronic structure\n        method. Defaults to wB97M-V.\n    basis\n        Basis set. Defaults to def2-TZVPD.\n    scf_algorithm\n        Algorithm used to converge the SCF. Defaults to \"diis\", but for\n        particularly difficult cases, \"gdm\" should be employed instead.\n    pcm_dielectric\n        Dielectric constant of the optional polarizable continuum impicit\n        solvation model. Defaults to None, in which case PCM will not be\n        employed.\n    smd_solvent\n        Solvent to use for SMD implicit solvation model. Examples include\n        \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem\n        manual for a complete list of solvents available. Defaults to None, in\n        which case SMD will not be employed.\n    n_cores\n        Number of cores to use for the Q-Chem calculation. Defaults to use all\n        cores available on a given node.\n    overwrite_inputs\n        Dictionary passed to `pymatgen.io.qchem.QChemDictSet` which can modify\n        default values set therein as well as set additional Q-Chem parameters.\n        See QChemDictSet documentation for more details.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n    defaults = {\n        \"basis_set\": basis,\n        \"scf_algorithm\": scf_algorithm,\n        \"method\": method,\n        \"charge\": charge,\n        \"spin_multiplicity\": spin_multiplicity,\n        \"cores\": n_cores or multiprocessing.cpu_count(),\n        \"qchem_input_params\": {\n            \"pcm_dielectric\": pcm_dielectric,\n            \"smd_solvent\": smd_solvent,\n            \"overwrite_inputs\": overwrite_inputs,\n            \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n            \"nbo_params\": {\"version\": 7} if SETTINGS.QCHEM_NBO_EXE else None,\n        },\n    }\n\n    return _base_job(\n        atoms,\n        charge,\n        spin_multiplicity,\n        defaults=defaults,\n        additional_fields={\"name\": \"Q-Chem Static\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/ts.html","title":"ts","text":"<p>Transition state recipes for the Q-Chem</p>"},{"location":"reference/quacc/recipes/qchem/ts.html#quacc.recipes.qchem.ts.irc_job","title":"irc_job","text":"<pre><code>irc_job(\n    atoms,\n    charge,\n    spin_multiplicity,\n    direction=\"forward\",\n    method=\"wb97mv\",\n    basis=\"def2-svpd\",\n    scf_algorithm=\"diis\",\n    pcm_dielectric=None,\n    smd_solvent=None,\n    n_cores=None,\n    overwrite_inputs=None,\n    opt_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>IRC optimize a molecular structure.</p> Note <p>Calculator Defaults:</p> <pre><code>{\n    \"basis_set\": basis,\n    \"scf_algorithm\": scf_algorithm,\n    \"method\": method,\n    \"charge\": charge,\n    \"spin_multiplicity\": spin_multiplicity,\n    \"cores\": n_cores or multiprocessing.cpu_count(),\n    \"qchem_input_params\": {\n        \"pcm_dielectric\": pcm_dielectric,\n        \"smd_solvent\": smd_solvent,\n        \"overwrite_inputs\": overwrite_inputs,\n        \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n    },\n}\n</code></pre> <p>Optimizer Defaults:</p> <pre><code>{\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": \"Sella\"}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>charge</code>             (<code>int</code>)         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>)         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>direction</code>             (<code>Literal['forward', 'reverse']</code>, default:                 <code>'forward'</code> )         \u2013          <p>Direction of the IRC. Should be \"forward\" or \"reverse\".</p> </li> <li> <code>method</code>             (<code>str</code>, default:                 <code>'wb97mv'</code> )         \u2013          <p>DFT exchange-correlation functional or other electronic structure method. Defaults to wB97M-V.</p> </li> <li> <code>basis</code>             (<code>str</code>, default:                 <code>'def2-svpd'</code> )         \u2013          <p>Basis set. Defaults to def2-SVPD.</p> </li> <li> <code>scf_algorithm</code>             (<code>str</code>, default:                 <code>'diis'</code> )         \u2013          <p>Algorithm used to converge the SCF. Defaults to \"diis\", but for particularly difficult cases, \"gdm\" should be employed instead.</p> </li> <li> <code>pcm_dielectric</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Dielectric constant of the optional polarizable continuum impicit solvation model. Defaults to None, in which case PCM will not be employed.</p> </li> <li> <code>smd_solvent</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Solvent to use for SMD implicit solvation model. Examples include \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem manual for a complete list of solvents available. Defaults to None, in which case SMD will not be employed.</p> </li> <li> <code>n_cores</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Number of cores to use for the Q-Chem calculation. Defaults to use all cores available on a given node.</p> </li> <li> <code>overwrite_inputs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary passed to <code>pymatgen.io.qchem.QChemDictSet</code> which can modify default values set therein as well as set additional Q-Chem parameters. See QChemDictSet documentation for more details.</p> </li> <li> <code>opt_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for quacc.runners.calc.run_ase_opt</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>quacc/recipes/qchem/ts.py</code> <pre><code>@job\n@requires(\n    has_sella,\n    \"Sella must be installed. Refer to the quacc documentation.\",\n)\ndef irc_job(\n    atoms: Atoms | dict,\n    charge: int,\n    spin_multiplicity: int,\n    direction: Literal[\"forward\", \"reverse\"] = \"forward\",\n    method: str = \"wb97mv\",\n    basis: str = \"def2-svpd\",\n    scf_algorithm: str = \"diis\",\n    pcm_dielectric: str | None = None,\n    smd_solvent: str | None = None,\n    n_cores: int | None = None,\n    overwrite_inputs: dict | None = None,\n    opt_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; OptSchema:\n    \"\"\"\n    IRC optimize a molecular structure.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\n            \"basis_set\": basis,\n            \"scf_algorithm\": scf_algorithm,\n            \"method\": method,\n            \"charge\": charge,\n            \"spin_multiplicity\": spin_multiplicity,\n            \"cores\": n_cores or multiprocessing.cpu_count(),\n            \"qchem_input_params\": {\n                \"pcm_dielectric\": pcm_dielectric,\n                \"smd_solvent\": smd_solvent,\n                \"overwrite_inputs\": overwrite_inputs,\n                \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n            },\n        }\n        ```\n\n        Optimizer Defaults:\n\n        ```python\n        {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": \"Sella\"}\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    direction\n        Direction of the IRC. Should be \"forward\" or \"reverse\".\n    method\n        DFT exchange-correlation functional or other electronic structure\n        method. Defaults to wB97M-V.\n    basis\n        Basis set. Defaults to def2-SVPD.\n    scf_algorithm\n        Algorithm used to converge the SCF. Defaults to \"diis\", but for\n        particularly difficult cases, \"gdm\" should be employed instead.\n    pcm_dielectric\n        Dielectric constant of the optional polarizable continuum impicit\n        solvation model. Defaults to None, in which case PCM will not be\n        employed.\n    smd_solvent\n        Solvent to use for SMD implicit solvation model. Examples include\n        \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem\n        manual for a complete list of solvents available. Defaults to None, in\n        which case SMD will not be employed.\n    n_cores\n        Number of cores to use for the Q-Chem calculation. Defaults to use all\n        cores available on a given node.\n    overwrite_inputs\n        Dictionary passed to `pymatgen.io.qchem.QChemDictSet` which can modify\n        default values set therein as well as set additional Q-Chem parameters.\n        See QChemDictSet documentation for more details.\n    opt_swaps\n        Dictionary of custom kwargs for [quacc.runners.calc.run_ase_opt][]\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_opt_run][]\n    \"\"\"\n\n    qchem_defaults = {\n        \"basis_set\": basis,\n        \"scf_algorithm\": scf_algorithm,\n        \"method\": method,\n        \"charge\": charge,\n        \"spin_multiplicity\": spin_multiplicity,\n        \"cores\": n_cores or multiprocessing.cpu_count(),\n        \"qchem_input_params\": {\n            \"pcm_dielectric\": pcm_dielectric,\n            \"smd_solvent\": smd_solvent,\n            \"overwrite_inputs\": overwrite_inputs,\n            \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n        },\n    }\n    opt_defaults = {\n        \"fmax\": 0.01,\n        \"max_steps\": 1000,\n        \"optimizer\": IRC,\n        \"optimizer_kwargs\": {\"keep_going\": True},\n        \"run_kwargs\": {\"direction\": direction},\n    }\n    if opt_swaps and opt_swaps.get(\"optimizer\", IRC) is not IRC:\n        raise ValueError(\"Only Sella's IRC should be used for IRC optimization.\")\n\n    return _base_opt_job(\n        atoms,\n        charge,\n        spin_multiplicity,\n        qchem_defaults=qchem_defaults,\n        opt_defaults=opt_defaults,\n        opt_swaps=opt_swaps,\n        additional_fields={\"name\": \"Q-Chem IRC\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/ts.html#quacc.recipes.qchem.ts.quasi_irc_job","title":"quasi_irc_job","text":"<pre><code>quasi_irc_job(\n    atoms,\n    charge,\n    spin_multiplicity,\n    direction=\"forward\",\n    method=\"wb97mv\",\n    basis=\"def2-svpd\",\n    scf_algorithm=\"diis\",\n    pcm_dielectric=None,\n    smd_solvent=None,\n    n_cores=None,\n    overwrite_inputs=None,\n    irc_opt_swaps=None,\n    relax_opt_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Quasi-IRC optimize a molecular structure. Runs <code>irc_job</code> for 10 steps (default) followed by <code>relax_job</code>.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object.</p> </li> <li> <code>charge</code>             (<code>int</code>)         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>)         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>direction</code>             (<code>Literal['forward', 'reverse']</code>, default:                 <code>'forward'</code> )         \u2013          <p>Direction of the IRC. Should be \"forward\" or \"reverse\".</p> </li> <li> <code>irc_opt_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of opt_swaps kwargs for the irc_job.</p> Note <p>Uses the following defaults:</p> <pre><code>{\"fmax\": 100, \"max_steps\": 10}\n</code></pre> </li> <li> <code>relax_opt_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of opt_swaps kwargs for the relax_job.</p> Note <p>Uses the following defaults:</p> <pre><code>{}\n</code></pre> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>quacc/recipes/qchem/ts.py</code> <pre><code>@job\n@requires(\n    has_sella,\n    \"Sella must be installed. Refer to the quacc documentation.\",\n)\ndef quasi_irc_job(\n    atoms: Atoms | dict,\n    charge: int,\n    spin_multiplicity: int,\n    direction: Literal[\"forward\", \"reverse\"] = \"forward\",\n    method: str = \"wb97mv\",\n    basis: str = \"def2-svpd\",\n    scf_algorithm: str = \"diis\",\n    pcm_dielectric: str | None = None,\n    smd_solvent: str | None = None,\n    n_cores: int | None = None,\n    overwrite_inputs: dict | None = None,\n    irc_opt_swaps: dict | None = None,\n    relax_opt_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; OptSchema:\n    \"\"\"\n    Quasi-IRC optimize a molecular structure. Runs `irc_job` for\n    10 steps (default) followed by `relax_job`.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object.\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    direction\n        Direction of the IRC. Should be \"forward\" or \"reverse\".\n    irc_opt_swaps\n        Dictionary of opt_swaps kwargs for the irc_job.\n\n        ??? Note\n\n             Uses the following defaults:\n\n            ```python\n            {\"fmax\": 100, \"max_steps\": 10}\n            ```\n    relax_opt_swaps\n        Dictionary of opt_swaps kwargs for the relax_job.\n\n        ??? Note\n\n            Uses the following defaults:\n\n            ```python\n            {}\n            ```\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_opt_run][]\n    \"\"\"\n\n    default_settings = SETTINGS.copy()\n\n    irc_opt_swaps_defaults = {\"fmax\": 100, \"max_steps\": 10}\n    irc_opt_swaps = merge_dicts(irc_opt_swaps_defaults, irc_opt_swaps)\n\n    SETTINGS.CHECK_CONVERGENCE = False\n    irc_summary = irc_job.__wrapped__(\n        atoms,\n        charge,\n        spin_multiplicity,\n        direction=direction,\n        method=method,\n        basis=basis,\n        scf_algorithm=scf_algorithm,\n        pcm_dielectric=pcm_dielectric,\n        smd_solvent=smd_solvent,\n        n_cores=n_cores,\n        overwrite_inputs=overwrite_inputs,\n        opt_swaps=irc_opt_swaps,\n        copy_files=copy_files,\n    )\n\n    SETTINGS.CHECK_CONVERGENCE = default_settings.CHECK_CONVERGENCE\n    relax_summary = relax_job.__wrapped__(\n        irc_summary,\n        charge,\n        spin_multiplicity,\n        method=method,\n        basis=basis,\n        scf_algorithm=scf_algorithm,\n        pcm_dielectric=pcm_dielectric,\n        smd_solvent=smd_solvent,\n        n_cores=n_cores,\n        overwrite_inputs=overwrite_inputs,\n        opt_swaps=relax_opt_swaps,\n    )\n\n    relax_summary[\"initial_irc\"] = irc_summary\n\n    return relax_summary\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/ts.html#quacc.recipes.qchem.ts.ts_job","title":"ts_job","text":"<pre><code>ts_job(\n    atoms,\n    charge,\n    spin_multiplicity,\n    method=\"wb97mv\",\n    basis=\"def2-svpd\",\n    scf_algorithm=\"diis\",\n    pcm_dielectric=None,\n    smd_solvent=None,\n    n_cores=None,\n    overwrite_inputs=None,\n    opt_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>TS optimize a molecular structure.</p> Note <p>Calculator Defaults:</p> <pre><code>{\n    \"basis_set\": basis,\n    \"scf_algorithm\": scf_algorithm,\n    \"method\": method,\n    \"charge\": charge,\n    \"spin_multiplicity\": spin_multiplicity,\n    \"cores\": n_cores or multiprocessing.cpu_count(),\n    \"qchem_input_params\": {\n        \"pcm_dielectric\": pcm_dielectric,\n        \"smd_solvent\": smd_solvent,\n        \"overwrite_inputs\": overwrite_inputs,\n        \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n    },\n}\n</code></pre> <p>Optimizer Defaults:</p> <pre><code>{\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": Sella, \"optimizer_kwargs\": {\"use_TRICs\": False}}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>charge</code>             (<code>int</code>)         \u2013          <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>             (<code>int</code>)         \u2013          <p>Multiplicity of the system.</p> </li> <li> <code>method</code>             (<code>str</code>, default:                 <code>'wb97mv'</code> )         \u2013          <p>DFT exchange-correlation functional or other electronic structure method. Defaults to wB97M-V.</p> </li> <li> <code>basis</code>             (<code>str</code>, default:                 <code>'def2-svpd'</code> )         \u2013          <p>Basis set. Defaults to def2-SVPD.</p> </li> <li> <code>scf_algorithm</code>             (<code>str</code>, default:                 <code>'diis'</code> )         \u2013          <p>Algorithm used to converge the SCF. Defaults to \"diis\", but for particularly difficult cases, \"gdm\" should be employed instead.</p> </li> <li> <code>pcm_dielectric</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Dielectric constant of the optional polarizable continuum impicit solvation model. Defaults to None, in which case PCM will not be employed.</p> </li> <li> <code>smd_solvent</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Solvent to use for SMD implicit solvation model. Examples include \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem manual for a complete list of solvents available. Defaults to None, in which case SMD will not be employed.</p> </li> <li> <code>n_cores</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Number of cores to use for the Q-Chem calculation. Defaults to use all cores available on a given node.</p> </li> <li> <code>overwrite_inputs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary passed to <code>pymatgen.io.qchem.QChemDictSet</code> which can modify default values set therein as well as set additional Q-Chem parameters. See QChemDictSet documentation for more details.</p> </li> <li> <code>opt_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for quacc.runners.calc.run_ase_opt</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>quacc/recipes/qchem/ts.py</code> <pre><code>@job\n@requires(\n    has_sella,\n    \"Sella must be installed. Refer to the quacc documentation.\",\n)\ndef ts_job(\n    atoms: Atoms | dict,\n    charge: int,\n    spin_multiplicity: int,\n    method: str = \"wb97mv\",\n    basis: str = \"def2-svpd\",\n    scf_algorithm: str = \"diis\",\n    pcm_dielectric: str | None = None,\n    smd_solvent: str | None = None,\n    n_cores: int | None = None,\n    overwrite_inputs: dict | None = None,\n    opt_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; OptSchema:\n    \"\"\"\n    TS optimize a molecular structure.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\n            \"basis_set\": basis,\n            \"scf_algorithm\": scf_algorithm,\n            \"method\": method,\n            \"charge\": charge,\n            \"spin_multiplicity\": spin_multiplicity,\n            \"cores\": n_cores or multiprocessing.cpu_count(),\n            \"qchem_input_params\": {\n                \"pcm_dielectric\": pcm_dielectric,\n                \"smd_solvent\": smd_solvent,\n                \"overwrite_inputs\": overwrite_inputs,\n                \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n            },\n        }\n        ```\n\n        Optimizer Defaults:\n\n        ```python\n        {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": Sella, \"optimizer_kwargs\": {\"use_TRICs\": False}}\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    method\n        DFT exchange-correlation functional or other electronic structure\n        method. Defaults to wB97M-V.\n    basis\n        Basis set. Defaults to def2-SVPD.\n    scf_algorithm\n        Algorithm used to converge the SCF. Defaults to \"diis\", but for\n        particularly difficult cases, \"gdm\" should be employed instead.\n    pcm_dielectric\n        Dielectric constant of the optional polarizable continuum impicit\n        solvation model. Defaults to None, in which case PCM will not be\n        employed.\n    smd_solvent\n        Solvent to use for SMD implicit solvation model. Examples include\n        \"water\", \"ethanol\", \"methanol\", and \"acetonitrile\". Refer to the Q-Chem\n        manual for a complete list of solvents available. Defaults to None, in\n        which case SMD will not be employed.\n    n_cores\n        Number of cores to use for the Q-Chem calculation. Defaults to use all\n        cores available on a given node.\n    overwrite_inputs\n        Dictionary passed to `pymatgen.io.qchem.QChemDictSet` which can modify\n        default values set therein as well as set additional Q-Chem parameters.\n        See QChemDictSet documentation for more details.\n    opt_swaps\n        Dictionary of custom kwargs for [quacc.runners.calc.run_ase_opt][]\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_opt_run][]\n    \"\"\"\n\n    qchem_defaults = {\n        \"basis_set\": basis,\n        \"scf_algorithm\": scf_algorithm,\n        \"method\": method,\n        \"charge\": charge,\n        \"spin_multiplicity\": spin_multiplicity,\n        \"cores\": n_cores or multiprocessing.cpu_count(),\n        \"qchem_input_params\": {\n            \"pcm_dielectric\": pcm_dielectric,\n            \"smd_solvent\": smd_solvent,\n            \"overwrite_inputs\": overwrite_inputs,\n            \"max_scf_cycles\": 200 if scf_algorithm.lower() == \"gdm\" else None,\n        },\n    }\n    opt_defaults = {\n        \"fmax\": 0.01,\n        \"max_steps\": 1000,\n        \"optimizer\": Sella,\n        \"optimizer_kwargs\": {\"order\": 1, \"use_TRICs\": False},\n    }\n\n    if opt_swaps and opt_swaps.get(\"optimizer\", Sella) is not Sella:\n        raise ValueError(\"Only Sella should be used for TS optimization.\")\n\n    return _base_opt_job(\n        atoms,\n        charge,\n        spin_multiplicity,\n        qchem_defaults=qchem_defaults,\n        opt_defaults=opt_defaults,\n        opt_swaps=opt_swaps,\n        additional_fields={\"name\": \"Q-Chem TS\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/tblite/core.html","title":"core","text":"<p>Core recipes for the tblite code</p>"},{"location":"reference/quacc/recipes/tblite/core.html#quacc.recipes.tblite.core.freq_job","title":"freq_job","text":"<pre><code>freq_job(\n    atoms,\n    method=\"GFN2-xTB\",\n    energy=0.0,\n    temperature=298.15,\n    pressure=1.0,\n    calc_swaps=None,\n    vib_kwargs=None,\n    copy_files=None,\n)\n</code></pre> <p>Run a frequency job and calculate thermochemistry.</p> Note <p>Calculator Defaults:</p> <pre><code>{\"method\": method}\n</code></pre> <p>Vibrations Defaults:</p> <pre><code>{}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>method</code>             (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'IPEA1-xTB']</code>, default:                 <code>'GFN2-xTB'</code> )         \u2013          <p>GFN0-xTB, GFN1-xTB, GFN2-xTB, GFN-FF.</p> </li> <li> <code>energy</code>             (<code>float</code>, default:                 <code>0.0</code> )         \u2013          <p>Potential energy in eV. If 0, then the output is just the correction.</p> </li> <li> <code>temperature</code>             (<code>float</code>, default:                 <code>298.15</code> )         \u2013          <p>Temperature in Kelvins.</p> </li> <li> <code>pressure</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Pressure in bar.</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>dictionary of custom kwargs for the tblite calculator.</p> </li> <li> <code>vib_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>dictionary of custom kwargs for the Vibrations object.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VibThermoSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_vib_and_thermo</p> </li> </ul> Source code in <code>quacc/recipes/tblite/core.py</code> <pre><code>@job\n@requires(TBLite, \"tblite must be installed. Refer to the quacc documentation.\")\ndef freq_job(\n    atoms: Atoms | dict,\n    method: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"IPEA1-xTB\"] = \"GFN2-xTB\",\n    energy: float = 0.0,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    calc_swaps: dict | None = None,\n    vib_kwargs: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; VibThermoSchema:\n    \"\"\"\n    Run a frequency job and calculate thermochemistry.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\"method\": method}\n        ```\n\n        Vibrations Defaults:\n\n        ```python\n        {}\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    method\n        GFN0-xTB, GFN1-xTB, GFN2-xTB, GFN-FF.\n    energy\n        Potential energy in eV. If 0, then the output is just the correction.\n    temperature\n        Temperature in Kelvins.\n    pressure\n        Pressure in bar.\n    calc_swaps\n        dictionary of custom kwargs for the tblite calculator.\n    vib_kwargs\n        dictionary of custom kwargs for the Vibrations object.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    VibThermoSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_vib_and_thermo][]\n    \"\"\"\n    atoms = fetch_atoms(atoms)\n    vib_kwargs = vib_kwargs or {}\n\n    defaults = {\"method\": method}\n    flags = merge_dicts(defaults, calc_swaps)\n    atoms.calc = TBLite(**flags)\n\n    vibrations = run_ase_vib(atoms, vib_kwargs=vib_kwargs, copy_files=copy_files)\n    igt = build_ideal_gas(atoms, vibrations.get_frequencies(), energy=energy)\n\n    return summarize_vib_and_thermo(\n        vibrations,\n        igt,\n        temperature=temperature,\n        pressure=pressure,\n        additional_fields={\"name\": \"TBLite Frequency and Thermo\"},\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/tblite/core.html#quacc.recipes.tblite.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms,\n    method=\"GFN2-xTB\",\n    relax_cell=False,\n    calc_swaps=None,\n    opt_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Relax a structure.</p> Note <p>Calculator Defaults:</p> <pre><code>{\"method\": method}\n</code></pre> <p>Optimizer Defaults:</p> <pre><code>{\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": FIRE}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>method</code>             (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'IPEA1-xTB']</code>, default:                 <code>'GFN2-xTB'</code> )         \u2013          <p>GFN0-xTB, GFN1-xTB, GFN2-xTB.</p> </li> <li> <code>relax_cell</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to relax the cell.</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the tblite calculator.</p> </li> <li> <code>opt_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for quacc.runners.calc.run_ase_opt.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_opt_run</p> </li> </ul> Source code in <code>quacc/recipes/tblite/core.py</code> <pre><code>@job\n@requires(TBLite, \"tblite must be installed. Refer to the quacc documentation.\")\ndef relax_job(\n    atoms: Atoms | dict,\n    method: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"IPEA1-xTB\"] = \"GFN2-xTB\",\n    relax_cell: bool = False,\n    calc_swaps: dict | None = None,\n    opt_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; OptSchema:\n    \"\"\"\n    Relax a structure.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\"method\": method}\n        ```\n\n        Optimizer Defaults:\n\n        ```python\n        {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": FIRE}\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    method\n        GFN0-xTB, GFN1-xTB, GFN2-xTB.\n    relax_cell\n        Whether to relax the cell.\n    calc_swaps\n        Dictionary of custom kwargs for the tblite calculator.\n    opt_swaps\n        Dictionary of custom kwargs for [quacc.runners.calc.run_ase_opt][].\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_opt_run][]\n    \"\"\"\n    atoms = fetch_atoms(atoms)\n\n    defaults = {\"method\": method}\n    flags = merge_dicts(defaults, calc_swaps)\n    atoms.calc = TBLite(**flags)\n\n    opt_defaults = {\"fmax\": 0.01, \"max_steps\": 1000, \"optimizer\": FIRE}\n    opt_flags = merge_dicts(opt_defaults, opt_swaps)\n\n    dyn = run_ase_opt(atoms, relax_cell=relax_cell, copy_files=copy_files, **opt_flags)\n\n    return summarize_opt_run(dyn, additional_fields={\"name\": \"TBLite Relax\"})\n</code></pre>"},{"location":"reference/quacc/recipes/tblite/core.html#quacc.recipes.tblite.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms,\n    method=\"GFN2-xTB\",\n    calc_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Carry out a single-point calculation.</p> Note <p>Calculator Defaults:</p> <pre><code>{\"method\": method}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>method</code>             (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'IPEA1-xTB']</code>, default:                 <code>'GFN2-xTB'</code> )         \u2013          <p>GFN1-xTB, GFN2-xTB, and IPEA1-xTB.</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the tblite calculator.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.ase.summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/tblite/core.py</code> <pre><code>@job\n@requires(TBLite, \"tblite must be installed. Refer to the quacc documentation.\")\ndef static_job(\n    atoms: Atoms | dict,\n    method: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"IPEA1-xTB\"] = \"GFN2-xTB\",\n    calc_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\"method\": method}\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    method\n        GFN1-xTB, GFN2-xTB, and IPEA1-xTB.\n    calc_swaps\n        Dictionary of custom kwargs for the tblite calculator.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.summarize_run][]\n    \"\"\"\n    atoms = fetch_atoms(atoms)\n\n    defaults = {\"method\": method}\n    flags = merge_dicts(defaults, calc_swaps)\n    atoms.calc = TBLite(**flags)\n\n    final_atoms = run_calc(atoms, copy_files=copy_files)\n    return summarize_run(\n        final_atoms,\n        input_atoms=atoms,\n        additional_fields={\"name\": \"TBLite Static\"},\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/core.html","title":"core","text":"<p>Core recipes for VASP</p>"},{"location":"reference/quacc/recipes/vasp/core.html#quacc.recipes.vasp.core.double_relax_job","title":"double_relax_job","text":"<pre><code>double_relax_job(\n    atoms,\n    preset=\"BulkSet\",\n    relax_cell=True,\n    calc_swaps1=None,\n    calc_swaps2=None,\n    copy_files=None,\n)\n</code></pre> <p>double_relax a structure. This is particularly useful for a few reasons:</p> <ol> <li> <p>To carry out a cheaper pre-relaxation before the high-quality run.</p> </li> <li> <p>To carry out a GGA calculation before a meta-GGA or hybrid calculation that requires the GGA wavefunction.</p> </li> <li> <p>To carry out volume relaxations where large changes in volume can require a second relaxation to resolve forces.</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>preset</code>             (<code>str | None</code>, default:                 <code>'BulkSet'</code> )         \u2013          <p>Preset to use from <code>quacc.calculators.presets.vasp</code>.</p> </li> <li> <code>relax_cell</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>True if a volume relaxation (ISIF = 3) should be performed. False if only the positions (ISIF = 2) should be updated.</p> </li> <li> <code>calc_swaps1</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the first relaxation.</p> </li> <li> <code>calc_swaps2</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the second relaxation.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the (first) runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DoubleRelaxSchema</code>         \u2013          <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/vasp/core.py</code> <pre><code>@job\ndef double_relax_job(\n    atoms: Atoms | dict,\n    preset: str | None = \"BulkSet\",\n    relax_cell: bool = True,\n    calc_swaps1: dict | None = None,\n    calc_swaps2: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; DoubleRelaxSchema:\n    \"\"\"\n    double_relax a structure. This is particularly useful for a few reasons:\n\n    1. To carry out a cheaper pre-relaxation before the high-quality run.\n\n    2. To carry out a GGA calculation before a meta-GGA or hybrid calculation\n    that requires the GGA wavefunction.\n\n    3. To carry out volume relaxations where large changes in volume\n    can require a second relaxation to resolve forces.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    preset\n        Preset to use from `quacc.calculators.presets.vasp`.\n    relax_cell\n        True if a volume relaxation (ISIF = 3) should be performed. False if\n        only the positions (ISIF = 2) should be updated.\n    calc_swaps1\n        Dictionary of custom kwargs for the first relaxation.\n    calc_swaps2\n        Dictionary of custom kwargs for the second relaxation.\n    copy_files\n        Files to copy to the (first) runtime directory.\n\n    Returns\n    -------\n    DoubleRelaxSchema\n        Dictionary of results\n    \"\"\"\n\n    # Run first relaxation\n    summary1 = relax_job.__wrapped__(\n        atoms,\n        preset=preset,\n        relax_cell=relax_cell,\n        calc_swaps=calc_swaps1,\n        copy_files=copy_files,\n    )\n\n    # Run second relaxation\n    summary2 = relax_job.__wrapped__(\n        summary1,\n        preset=preset,\n        relax_cell=relax_cell,\n        calc_swaps=calc_swaps2,\n        copy_files=[\"WAVECAR\"],\n    )\n    summary2[\"relax1\"] = summary1\n\n    return summary2\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/core.html#quacc.recipes.vasp.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms,\n    preset=\"BulkSet\",\n    relax_cell=True,\n    calc_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Relax a structure.</p> Note <p>Calculator Defaults:</p> <pre><code>{\n    \"ediffg\": -0.02,\n    \"isif\": 3 if relax_cell else 2,\n    \"ibrion\": 2,\n    \"isym\": 0,\n    \"lcharg\": False,\n    \"lwave\": False,\n    \"nsw\": 200,\n    \"symprec\": 1e-8,\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>preset</code>             (<code>str | None</code>, default:                 <code>'BulkSet'</code> )         \u2013          <p>Preset to use from <code>quacc.calculators.presets.vasp</code>.</p> </li> <li> <code>relax_cell</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>True if a volume relaxation (ISIF = 3) should be performed. False if only the positions (ISIF = 2) should be updated.</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator. Set a value to <code>None</code> to remove a pre-existing key entirely.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.vasp_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/vasp/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms | dict,\n    preset: str | None = \"BulkSet\",\n    relax_cell: bool = True,\n    calc_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; VaspSchema:\n    \"\"\"\n    Relax a structure.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\n            \"ediffg\": -0.02,\n            \"isif\": 3 if relax_cell else 2,\n            \"ibrion\": 2,\n            \"isym\": 0,\n            \"lcharg\": False,\n            \"lwave\": False,\n            \"nsw\": 200,\n            \"symprec\": 1e-8,\n        }\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    preset\n        Preset to use from `quacc.calculators.presets.vasp`.\n    relax_cell\n        True if a volume relaxation (ISIF = 3) should be performed. False if\n        only the positions (ISIF = 2) should be updated.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator. Set a value to `None` to remove\n        a pre-existing key entirely.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.vasp_summarize_run][]\n    \"\"\"\n\n    defaults = {\n        \"ediffg\": -0.02,\n        \"isif\": 3 if relax_cell else 2,\n        \"ibrion\": 2,\n        \"isym\": 0,\n        \"lcharg\": False,\n        \"lwave\": False,\n        \"nsw\": 200,\n        \"symprec\": 1e-8,\n    }\n    return _base_job(\n        atoms,\n        preset=preset,\n        defaults=defaults,\n        calc_swaps=calc_swaps,\n        additional_fields={\"name\": \"VASP Relax\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/core.html#quacc.recipes.vasp.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms,\n    preset=\"BulkSet\",\n    calc_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Carry out a single-point calculation.</p> Note <p>Calculator Defaults:</p> <pre><code>{\n    \"ismear\": -5,\n    \"laechg\": True,\n    \"lcharg\": True,\n    \"lreal\": False,\n    \"lwave\": True,\n    \"nedos\": 5001,\n    \"nsw\": 0,\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>preset</code>             (<code>str | None</code>, default:                 <code>'BulkSet'</code> )         \u2013          <p>Preset to use from <code>quacc.calculators.presets.vasp</code>.</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator. Set a value to <code>None</code> to remove a pre-existing key entirely.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.vasp_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/vasp/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms | dict,\n    preset: str | None = \"BulkSet\",\n    calc_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; VaspSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\n            \"ismear\": -5,\n            \"laechg\": True,\n            \"lcharg\": True,\n            \"lreal\": False,\n            \"lwave\": True,\n            \"nedos\": 5001,\n            \"nsw\": 0,\n        }\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    preset\n        Preset to use from `quacc.calculators.presets.vasp`.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator. Set a value to `None` to remove\n        a pre-existing key entirely.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.vasp_summarize_run][]\n    \"\"\"\n\n    defaults = {\n        \"ismear\": -5,\n        \"laechg\": True,\n        \"lcharg\": True,\n        \"lreal\": False,\n        \"lwave\": True,\n        \"nedos\": 5001,\n        \"nsw\": 0,\n    }\n    return _base_job(\n        atoms,\n        preset=preset,\n        defaults=defaults,\n        calc_swaps=calc_swaps,\n        additional_fields={\"name\": \"VASP Static\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp.html","title":"mp","text":"<p>Materials Project-compatible recipes</p> <p>This set of recipes is meant to be compatible with the Materials Project Reference: https://doi.org/10.1103/PhysRevMaterials.6.013801</p> <p>Note</p> <p>The one true source of Materials Project workflows is atomate2. If you need an MP-compatible workflow, we strongly encourage you to use atomate2 to ensure that all of your settings are fully compatible and up-to-date. This module is a best effort to be used at your own discretion.</p>"},{"location":"reference/quacc/recipes/vasp/mp.html#quacc.recipes.vasp.mp.mp_prerelax_job","title":"mp_prerelax_job","text":"<pre><code>mp_prerelax_job(\n    atoms,\n    preset=\"MPScanSet\",\n    calc_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Function to pre-relax a structure with Materials Project settings. By default, this uses a PBEsol pre-relax step.</p> Note <p>Calculator Defaults:</p> <pre><code>{\"ediffg\": -0.05, \"xc\": \"pbesol\"}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>preset</code>             (<code>str | None</code>, default:                 <code>'MPScanSet'</code> )         \u2013          <p>Preset to use from <code>quacc.calculators.presets.vasp</code>.</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. Set a value to <code>None</code> to remove a pre-existing key entirely.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.vasp_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/vasp/mp.py</code> <pre><code>@job\ndef mp_prerelax_job(\n    atoms: Atoms | dict,\n    preset: str | None = \"MPScanSet\",\n    calc_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; VaspSchema:\n    \"\"\"\n    Function to pre-relax a structure with Materials Project settings. By\n    default, this uses a PBEsol pre-relax step.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\"ediffg\": -0.05, \"xc\": \"pbesol\"}\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    preset\n        Preset to use from `quacc.calculators.presets.vasp`.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator. Set a value to `None` to remove\n        a pre-existing key entirely. Set a value to `None` to remove a pre-existing key entirely.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.vasp_summarize_run][]\n    \"\"\"\n\n    defaults = {\"ediffg\": -0.05, \"xc\": \"pbesol\"}\n    return _base_job(\n        atoms,\n        preset=preset,\n        defaults=defaults,\n        calc_swaps=calc_swaps,\n        additional_fields={\"name\": \"MP Pre-Relax\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp.html#quacc.recipes.vasp.mp.mp_relax_flow","title":"mp_relax_flow","text":"<pre><code>mp_relax_flow(\n    atoms, prerelax_job_kwargs=None, relax_job_kwargs=None\n)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>MP-compatible pre-relax</p> </li> <li> <p>MP-compatible relax</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object for the structure.</p> </li> <li> <code>prerelax_job_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the pre-relaxation calculation.</p> </li> <li> <code>relax_job_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the relaxation calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MPRelaxFlowSchema</code>         \u2013          <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/vasp/mp.py</code> <pre><code>@flow\ndef mp_relax_flow(\n    atoms: Atoms | dict,\n    prerelax_job_kwargs: dict | None = None,\n    relax_job_kwargs: dict | None = None,\n) -&gt; MPRelaxFlowSchema:\n    \"\"\"\n    Workflow consisting of:\n\n    1. MP-compatible pre-relax\n\n    2. MP-compatible relax\n\n    Parameters\n    ----------\n    atoms\n        Atoms object for the structure.\n    prerelax_job_kwargs\n        Additional keyword arguments to pass to the pre-relaxation calculation.\n    relax_job_kwargs\n        Additional keyword arguments to pass to the relaxation calculation.\n\n    Returns\n    -------\n    MPRelaxFlowSchema\n        Dictionary of results\n    \"\"\"\n    prerelax_job_kwargs = prerelax_job_kwargs or {}\n    relax_job_kwargs = relax_job_kwargs or {}\n\n    # Run the prerelax\n    prerelax_results = mp_prerelax_job(atoms, **prerelax_job_kwargs)\n\n    # Update KSPACING arguments\n    bandgap = prerelax_results[\"output\"].get(\"bandgap\", 0)\n    if bandgap &lt; 1e-4:\n        kspacing_swaps = {\"kspacing\": 0.22, \"sigma\": 0.2, \"ismear\": 2}\n    else:\n        rmin = 25.22 - 2.87 * bandgap\n        kspacing = 2 * np.pi * 1.0265 / (rmin - 1.0183)\n        kspacing_swaps = {\"kspacing\": min(kspacing, 0.44), \"ismear\": -5, \"sigma\": 0.05}\n\n    relax_job_kwargs[\"calc_swaps\"] = kspacing_swaps | relax_job_kwargs.get(\n        \"calc_swaps\", {}\n    )\n\n    # Run the relax\n    relax_results = mp_relax_job(\n        prerelax_results, copy_files=[\"WAVECAR\"], **relax_job_kwargs\n    )\n    relax_results[\"prerelax\"] = prerelax_results\n\n    return relax_results\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp.html#quacc.recipes.vasp.mp.mp_relax_job","title":"mp_relax_job","text":"<pre><code>mp_relax_job(\n    atoms,\n    preset=\"MPScanSet\",\n    calc_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Function to relax a structure with Materials Project settings. By default, this uses an r2SCAN relax step.</p> Note <p>Calculator Defaults:</p> <pre><code>{}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>preset</code>             (<code>str | None</code>, default:                 <code>'MPScanSet'</code> )         \u2013          <p>Preset to use from <code>quacc.calculators.presets.vasp</code>.</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. Set a value to <code>None</code> to remove a pre-existing key entirely.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.vasp_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/vasp/mp.py</code> <pre><code>@job\ndef mp_relax_job(\n    atoms: Atoms | dict,\n    preset: str | None = \"MPScanSet\",\n    calc_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; VaspSchema:\n    \"\"\"\n    Function to relax a structure with Materials Project settings. By default,\n    this uses an r2SCAN relax step.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {}\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    preset\n        Preset to use from `quacc.calculators.presets.vasp`.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator. Set a value to `None` to remove\n        a pre-existing key entirely. Set a value to `None` to remove a pre-existing key entirely.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.vasp_summarize_run][]\n    \"\"\"\n\n    return _base_job(\n        atoms,\n        preset=preset,\n        defaults={},\n        calc_swaps=calc_swaps,\n        additional_fields={\"name\": \"MP Relax\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/qmof.html","title":"qmof","text":"<p>QMOF-compatible recipes</p> <p>This set of recipes is meant to be compatible with the QMOF Database workflow. Reference: https://doi.org/10.1016/j.matt.2021.02.015</p>"},{"location":"reference/quacc/recipes/vasp/qmof.html#quacc.recipes.vasp.qmof.qmof_relax_job","title":"qmof_relax_job","text":"<pre><code>qmof_relax_job(\n    atoms,\n    preset=\"QMOFSet\",\n    relax_cell=True,\n    run_prerelax=True,\n    calc_swaps=None,\n)\n</code></pre> <p>Relax a structure in a multi-step process for increased computational efficiency. This is all done in a single compute job. Settings are such that they are compatible with the QMOF Database.</p> <ol> <li> <p>A \"pre-relaxation\" with BFGSLineSearch to resolve very high forces.</p> </li> <li> <p>Position relaxation with default ENCUT and coarse k-point grid.</p> </li> <li> <p>Optional: volume relaxation with coarse k-point grid.</p> </li> <li> <p>Double relaxation using production-quality settings.</p> </li> <li> <p>Static calculation.</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>preset</code>             (<code>str | None</code>, default:                 <code>'QMOFSet'</code> )         \u2013          <p>Preset to use from <code>quacc.calculators.presets.vasp</code>. Applies for all jobs.</p> </li> <li> <code>relax_cell</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>True if a volume relaxation should be performed. False if only the positions should be updated.</p> </li> <li> <code>run_prerelax</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If True, a pre-relax will be carried out with BFGSLineSearch. Recommended if starting from hypothetical structures or materials with very high starting forces.</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. Set a value to <code>None</code> to remove a pre-existing key entirely. Applies for all jobs.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>QMOFRelaxSchema</code>         \u2013          <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/vasp/qmof.py</code> <pre><code>@job\ndef qmof_relax_job(\n    atoms: Atoms | dict,\n    preset: str | None = \"QMOFSet\",\n    relax_cell: bool = True,\n    run_prerelax: bool = True,\n    calc_swaps: dict | None = None,\n) -&gt; QMOFRelaxSchema:\n    \"\"\"\n    Relax a structure in a multi-step process for increased computational\n    efficiency. This is all done in a single compute job. Settings are such that\n    they are compatible with the QMOF Database.\n\n    1. A \"pre-relaxation\" with BFGSLineSearch to resolve very high forces.\n\n    2. Position relaxation with default ENCUT and coarse k-point grid.\n\n    3. Optional: volume relaxation with coarse k-point grid.\n\n    4. Double relaxation using production-quality settings.\n\n    5. Static calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    preset\n        Preset to use from `quacc.calculators.presets.vasp`. Applies for all jobs.\n    relax_cell\n        True if a volume relaxation should be performed. False if only the\n        positions should be updated.\n    run_prerelax\n        If True, a pre-relax will be carried out with BFGSLineSearch.\n        Recommended if starting from hypothetical structures or materials with\n        very high starting forces.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator. Set a value to `None` to remove\n        a pre-existing key entirely. Set a value to `None` to remove a pre-existing key entirely. Applies for all jobs.\n\n    Returns\n    -------\n    QMOFRelaxSchema\n        Dictionary of results\n    \"\"\"\n    atoms = fetch_atoms(atoms)\n\n    # 1. Pre-relaxation\n    if run_prerelax:\n        summary1 = _prerelax(atoms, preset, calc_swaps, fmax=5.0)\n        atoms = summary1[\"atoms\"]\n\n    # 2. Position relaxation (loose)\n    summary2 = _loose_relax_positions(atoms, preset, calc_swaps)\n    atoms = summary2[\"atoms\"]\n\n    # 3. Optional: Volume relaxation (loose)\n    if relax_cell:\n        summary3 = _loose_relax_cell(atoms, preset, calc_swaps)\n        atoms = summary3[\"atoms\"]\n\n    # 4. Double Relaxation This is done for two reasons: a) because it can\n    # resolve repadding issues when dV is large; b) because we can use LREAL =\n    # Auto for the first relaxation and the default LREAL for the second.\n    summary4 = _double_relax(atoms, preset, calc_swaps, relax_cell=relax_cell)\n    atoms = summary4[1][\"atoms\"]\n\n    # 5. Static Calculation\n    summary5 = _static(atoms, preset, calc_swaps)\n    summary5[\"prerelax_lowacc\"] = summary1 if run_prerelax else None\n    summary5[\"position_relax_lowacc\"] = summary2\n    summary5[\"volume_relax_lowacc\"] = summary3 if relax_cell else None\n    summary5[\"double_relax\"] = summary4\n\n    return summary5\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/slabs.html","title":"slabs","text":"<p>Recipes for slabs</p>"},{"location":"reference/quacc/recipes/vasp/slabs.html#quacc.recipes.vasp.slabs.bulk_to_slabs_flow","title":"bulk_to_slabs_flow","text":"<pre><code>bulk_to_slabs_flow(\n    atoms,\n    make_slabs_kwargs=None,\n    run_static=True,\n    slab_relax_kwargs=None,\n    slab_static_kwargs=None,\n)\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Slab generation</p> </li> <li> <p>Slab relaxations</p> </li> <li> <p>Slab statics (optional)</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>make_slabs_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to quacc.atoms.slabs.make_slabs_from_bulk</p> </li> <li> <code>run_static</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to run the static calculation.</p> </li> <li> <code>slab_relax_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the relaxation calculation.</p> </li> <li> <code>slab_static_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the static calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[VaspSchema]</code>         \u2013          <p>List of dictionary results from quacc.schemas.vasp.vasp_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/vasp/slabs.py</code> <pre><code>@flow\ndef bulk_to_slabs_flow(\n    atoms: Atoms | dict,\n    make_slabs_kwargs: dict | None = None,\n    run_static: bool = True,\n    slab_relax_kwargs: dict | None = None,\n    slab_static_kwargs: dict | None = None,\n) -&gt; list[VaspSchema]:\n    \"\"\"\n    Workflow consisting of:\n\n    1. Slab generation\n\n    2. Slab relaxations\n\n    3. Slab statics (optional)\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    make_slabs_kwargs\n        Additional keyword arguments to pass to [quacc.atoms.slabs.make_slabs_from_bulk][]\n    run_static\n        Whether to run the static calculation.\n    slab_relax_kwargs\n        Additional keyword arguments to pass to the relaxation calculation.\n    slab_static_kwargs\n        Additional keyword arguments to pass to the static calculation.\n\n    Returns\n    -------\n    list[VaspSchema]\n        List of dictionary results from [quacc.schemas.vasp.vasp_summarize_run][]\n    \"\"\"\n    slab_relax_kwargs = slab_relax_kwargs or {}\n    slab_static_kwargs = slab_static_kwargs or {}\n    make_slabs_kwargs = make_slabs_kwargs or {}\n\n    @job\n    def _make_slabs(atoms):\n        atoms = fetch_atoms(atoms)\n        return make_slabs_from_bulk(atoms, **make_slabs_kwargs)\n\n    @subflow\n    def _relax_distributed(slabs):\n        return [slab_relax_job(slab, **slab_relax_kwargs) for slab in slabs]\n\n    @subflow\n    def _relax_and_static_distributed(slabs):\n        return [\n            slab_static_job(\n                slab_relax_job(slab, **slab_relax_kwargs),\n                **slab_static_kwargs,\n            )\n            for slab in slabs\n        ]\n\n    slabs = _make_slabs(atoms)\n\n    return (\n        _relax_and_static_distributed(slabs)\n        if run_static\n        else _relax_distributed(slabs)\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/slabs.html#quacc.recipes.vasp.slabs.slab_relax_job","title":"slab_relax_job","text":"<pre><code>slab_relax_job(\n    atoms,\n    preset=\"SlabSet\",\n    calc_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Function to relax a slab.</p> Note <p>Calculator Parameters:</p> <pre><code>{\n    \"auto_dipole\": True,\n    \"ediffg\": -0.02,\n    \"isif\": 2,\n    \"ibrion\": 2,\n    \"isym\": 0,\n    \"lcharg\": False,\n    \"lwave\": False,\n    \"nsw\": 200,\n    \"symprec\": 1e-8,\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>preset</code>             (<code>str | None</code>, default:                 <code>'SlabSet'</code> )         \u2013          <p>Preset to use from <code>quacc.calculators.presets.vasp</code>.</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. Set a value to <code>None</code> to remove a pre-existing key entirely.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.vasp_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/vasp/slabs.py</code> <pre><code>@job\ndef slab_relax_job(\n    atoms: Atoms | dict,\n    preset: str | None = \"SlabSet\",\n    calc_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; VaspSchema:\n    \"\"\"\n    Function to relax a slab.\n\n    ??? Note\n\n        Calculator Parameters:\n\n        ```python\n        {\n            \"auto_dipole\": True,\n            \"ediffg\": -0.02,\n            \"isif\": 2,\n            \"ibrion\": 2,\n            \"isym\": 0,\n            \"lcharg\": False,\n            \"lwave\": False,\n            \"nsw\": 200,\n            \"symprec\": 1e-8,\n        }\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    preset\n        Preset to use from `quacc.calculators.presets.vasp`.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator. Set a value to `None` to remove\n        a pre-existing key entirely. Set a value to `None` to remove a pre-existing key entirely.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.vasp_summarize_run][]\n    \"\"\"\n\n    defaults = {\n        \"auto_dipole\": True,\n        \"ediffg\": -0.02,\n        \"isif\": 2,\n        \"ibrion\": 2,\n        \"isym\": 0,\n        \"lcharg\": False,\n        \"lwave\": False,\n        \"nsw\": 200,\n        \"symprec\": 1e-8,\n    }\n    return _base_job(\n        atoms,\n        preset=preset,\n        defaults=defaults,\n        calc_swaps=calc_swaps,\n        additional_fields={\"name\": \"VASP Slab Relax\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/slabs.html#quacc.recipes.vasp.slabs.slab_static_job","title":"slab_static_job","text":"<pre><code>slab_static_job(\n    atoms,\n    preset=\"SlabSet\",\n    calc_swaps=None,\n    copy_files=None,\n)\n</code></pre> <p>Function to carry out a single-point calculation on a slab.</p> Note <p>Calculator Defaults:</p> <pre><code>{\n    \"auto_dipole\": True,\n    \"ismear\": -5,\n    \"laechg\": True,\n    \"lcharg\": True,\n    \"lreal\": False,\n    \"lvhar\": True,\n    \"lwave\": True,\n    \"nedos\": 5001,\n    \"nsw\": 0,\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or a dictionary with the key \"atoms\" and an Atoms object as the value</p> </li> <li> <code>preset</code>             (<code>str | None</code>, default:                 <code>'SlabSet'</code> )         \u2013          <p>Preset to use from <code>quacc.calculators.presets.vasp</code>.</p> </li> <li> <code>calc_swaps</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of custom kwargs for the calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. Set a value to <code>None</code> to remove a pre-existing key entirely.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Files to copy to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary of results from quacc.schemas.vasp.vasp_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/vasp/slabs.py</code> <pre><code>@job\ndef slab_static_job(\n    atoms: Atoms | dict,\n    preset: str | None = \"SlabSet\",\n    calc_swaps: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; VaspSchema:\n    \"\"\"\n    Function to carry out a single-point calculation on a slab.\n\n    ??? Note\n\n        Calculator Defaults:\n\n        ```python\n        {\n            \"auto_dipole\": True,\n            \"ismear\": -5,\n            \"laechg\": True,\n            \"lcharg\": True,\n            \"lreal\": False,\n            \"lvhar\": True,\n            \"lwave\": True,\n            \"nedos\": 5001,\n            \"nsw\": 0,\n        }\n        ```\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or a dictionary with the key \"atoms\" and an Atoms object as\n        the value\n    preset\n        Preset to use from `quacc.calculators.presets.vasp`.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator. Set a value to `None` to remove\n        a pre-existing key entirely. Set a value to `None` to remove a pre-existing key entirely.\n    copy_files\n        Files to copy to the runtime directory.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.vasp_summarize_run][]\n    \"\"\"\n\n    defaults = {\n        \"auto_dipole\": True,\n        \"ismear\": -5,\n        \"laechg\": True,\n        \"lcharg\": True,\n        \"lreal\": False,\n        \"lvhar\": True,\n        \"lwave\": True,\n        \"nedos\": 5001,\n        \"nsw\": 0,\n    }\n    return _base_job(\n        atoms,\n        preset=preset,\n        defaults=defaults,\n        calc_swaps=calc_swaps,\n        additional_fields={\"name\": \"VASP Slab Static\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/slabs.html#quacc.recipes.vasp.slabs.slab_to_ads_flow","title":"slab_to_ads_flow","text":"<pre><code>slab_to_ads_flow(\n    slab,\n    adsorbate,\n    make_ads_kwargs=None,\n    run_static=True,\n    slab_relax_kwargs=None,\n    slab_static_kwargs=None,\n)\n</code></pre> <p>Workflow consisting of: 1. Slab-adsorbate generation 2. Slab-adsorbate relaxations 3. Slab-adsorbate statics (optional)</p> <p>Parameters:</p> <ul> <li> <code>slab</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object for the slab structure.</p> </li> <li> <code>adsorbate</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object for the adsorbate.</p> </li> <li> <code>make_ads_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to quacc.atoms.slabs.make_adsorbate_structures</p> </li> <li> <code>run_static</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to run the static calculation.</p> </li> <li> <code>slab_relax_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the relaxation calculation.</p> </li> <li> <code>slab_static_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional keyword arguments to pass to the static calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[VaspSchema]</code>         \u2013          <p>List of dictionaries of results from quacc.schemas.vasp.vasp_summarize_run</p> </li> </ul> Source code in <code>quacc/recipes/vasp/slabs.py</code> <pre><code>@flow\ndef slab_to_ads_flow(\n    slab: Atoms,\n    adsorbate: Atoms,\n    make_ads_kwargs: dict | None = None,\n    run_static: bool = True,\n    slab_relax_kwargs: dict | None = None,\n    slab_static_kwargs: dict | None = None,\n) -&gt; list[VaspSchema]:\n    \"\"\"\n    Workflow consisting of: 1. Slab-adsorbate generation 2. Slab-adsorbate\n    relaxations 3. Slab-adsorbate statics (optional)\n\n    Parameters\n    ----------\n    slab\n        Atoms object for the slab structure.\n    adsorbate\n        Atoms object for the adsorbate.\n    make_ads_kwargs\n        Additional keyword arguments to pass to [quacc.atoms.slabs.make_adsorbate_structures][]\n    run_static\n        Whether to run the static calculation.\n    slab_relax_kwargs\n        Additional keyword arguments to pass to the relaxation calculation.\n    slab_static_kwargs\n        Additional keyword arguments to pass to the static calculation.\n\n    Returns\n    -------\n    list[VaspSchema]\n        List of dictionaries of results from [quacc.schemas.vasp.vasp_summarize_run][]\n    \"\"\"\n\n    slab_relax_kwargs = slab_relax_kwargs or {}\n    slab_static_kwargs = slab_static_kwargs or {}\n    make_ads_kwargs = make_ads_kwargs or {}\n\n    @job\n    def _make_ads_slabs(atoms, adsorbate):\n        atoms = fetch_atoms(atoms)\n        return make_adsorbate_structures(atoms, adsorbate, **make_ads_kwargs)\n\n    @subflow\n    def _relax_distributed(slabs):\n        return [slab_relax_job(slab, **slab_relax_kwargs) for slab in slabs]\n\n    @subflow\n    def _relax_and_static_distributed(slabs):\n        return [\n            slab_static_job(\n                slab_relax_job(slab, **slab_relax_kwargs),\n                **slab_static_kwargs,\n            )\n            for slab in slabs\n        ]\n\n    ads_slabs = _make_ads_slabs(slab, adsorbate)\n\n    return (\n        _relax_and_static_distributed(ads_slabs)\n        if run_static\n        else _relax_distributed(ads_slabs)\n    )\n</code></pre>"},{"location":"reference/quacc/runners/calc.html","title":"calc","text":"<p>Utility functions for running ASE calculators</p>"},{"location":"reference/quacc/runners/calc.html#quacc.runners.calc.run_ase_opt","title":"run_ase_opt","text":"<pre><code>run_ase_opt(\n    atoms,\n    relax_cell=False,\n    fmax=0.01,\n    max_steps=500,\n    optimizer=FIRE,\n    optimizer_kwargs=None,\n    run_kwargs=None,\n    copy_files=None,\n)\n</code></pre> <p>Run an ASE-based optimization in a scratch directory and copy the results back to the original directory. This can be useful if file I/O is slow in the working directory, so long as file transfer speeds are reasonable.</p> <p>This is a wrapper around the optimizers in ASE. Note: This function does not modify the atoms object in-place.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>The Atoms object to run the calculation on.</p> </li> <li> <code>fmax</code>             (<code>float</code>, default:                 <code>0.01</code> )         \u2013          <p>Tolerance for the force convergence (in eV/A).</p> </li> <li> <code>max_steps</code>             (<code>int</code>, default:                 <code>500</code> )         \u2013          <p>Maximum number of steps to take.</p> </li> <li> <code>optimizer</code>             (<code>Optimizer</code>, default:                 <code>FIRE</code> )         \u2013          <p>Optimizer class to use.</p> </li> <li> <code>optimizer_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of kwargs for the optimizer. Takes all valid kwargs for ASE Optimizer classes. Refer to <code>_set_sella_kwargs</code> for Sella-related kwargs and how they are set.</p> </li> <li> <code>run_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of kwargs for the run() method of the optimizer.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Filenames to copy from source to scratch directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optimizer</code>         \u2013          <p>The ASE Optimizer object.</p> </li> </ul> Source code in <code>quacc/runners/calc.py</code> <pre><code>def run_ase_opt(\n    atoms: Atoms,\n    relax_cell: bool = False,\n    fmax: float = 0.01,\n    max_steps: int = 500,\n    optimizer: Optimizer = FIRE,\n    optimizer_kwargs: dict | None = None,\n    run_kwargs: dict | None = None,\n    copy_files: list[str] | None = None,\n) -&gt; Optimizer:\n    \"\"\"\n    Run an ASE-based optimization in a scratch directory and copy the results\n    back to the original directory. This can be useful if file I/O is slow in\n    the working directory, so long as file transfer speeds are reasonable.\n\n    This is a wrapper around the optimizers in ASE. Note: This function does not\n    modify the atoms object in-place.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object to run the calculation on.\n    fmax\n        Tolerance for the force convergence (in eV/A).\n    max_steps\n        Maximum number of steps to take.\n    optimizer\n        Optimizer class to use.\n    optimizer_kwargs\n        Dictionary of kwargs for the optimizer. Takes all valid kwargs for ASE\n        Optimizer classes. Refer to `_set_sella_kwargs` for Sella-related\n        kwargs and how they are set.\n    run_kwargs\n        Dictionary of kwargs for the run() method of the optimizer.\n    copy_files\n        Filenames to copy from source to scratch directory.\n\n    Returns\n    -------\n    Optimizer\n        The ASE Optimizer object.\n    \"\"\"\n\n    # Set defaults\n    optimizer_kwargs = optimizer_kwargs or {}\n    run_kwargs = run_kwargs or {}\n\n    # Check if trajectory kwarg is specified\n    if \"trajectory\" in optimizer_kwargs:\n        msg = \"Quacc does not support setting the `trajectory` kwarg.\"\n        raise ValueError(msg)\n\n    # Perform staging operations\n    atoms, tmpdir, job_results_dir = _calc_setup(atoms, copy_files=copy_files)\n\n    # Set Sella kwargs\n    if optimizer.__name__ == \"Sella\":\n        _set_sella_kwargs(atoms, optimizer_kwargs)\n    optimizer_kwargs.pop(\"use_TRICs\", None)\n\n    # Define the Trajectory object\n    traj_filename = Path(tmpdir, \"opt.traj\")\n    traj = Trajectory(traj_filename, \"w\", atoms=atoms)\n    optimizer_kwargs[\"trajectory\"] = traj\n\n    # Set volume relaxation constraints, if relevant\n    if relax_cell and atoms.pbc.any():\n        atoms = ExpCellFilter(atoms)\n\n    # Run calculation\n    with traj, optimizer(atoms, **optimizer_kwargs) as dyn:\n        dyn.run(fmax=fmax, steps=max_steps, **run_kwargs)\n\n    # Store the trajectory atoms\n    dyn.traj_atoms = read(traj_filename, index=\":\")\n\n    # Perform cleanup operations\n    _calc_cleanup(tmpdir, job_results_dir)\n\n    return dyn\n</code></pre>"},{"location":"reference/quacc/runners/calc.html#quacc.runners.calc.run_ase_vib","title":"run_ase_vib","text":"<pre><code>run_ase_vib(atoms, vib_kwargs=None, copy_files=None)\n</code></pre> <p>Run an ASE-based vibration analysis in a scratch directory and copy the results back to the original directory. This can be useful if file I/O is slow in the working directory, so long as file transfer speeds are reasonable.</p> <p>This is a wrapper around the vibrations module in ASE. Note: This function does not modify the atoms object in-place.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>The Atoms object to run the calculation on.</p> </li> <li> <code>vib_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of kwargs for the vibration analysis.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Filenames to copy from source to scratch directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Vibrations</code>         \u2013          <p>The updated Vibrations module</p> </li> </ul> Source code in <code>quacc/runners/calc.py</code> <pre><code>def run_ase_vib(\n    atoms: Atoms, vib_kwargs: dict | None = None, copy_files: list[str] | None = None\n) -&gt; Vibrations:\n    \"\"\"\n    Run an ASE-based vibration analysis in a scratch directory and copy the\n    results back to the original directory. This can be useful if file I/O is\n    slow in the working directory, so long as file transfer speeds are\n    reasonable.\n\n    This is a wrapper around the vibrations module in ASE. Note: This function\n    does not modify the atoms object in-place.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object to run the calculation on.\n    vib_kwargs\n        Dictionary of kwargs for the vibration analysis.\n    copy_files\n        Filenames to copy from source to scratch directory.\n\n    Returns\n    -------\n    Vibrations\n        The updated Vibrations module\n    \"\"\"\n\n    # Set defaults\n    vib_kwargs = vib_kwargs or {}\n\n    # Perform staging operations\n    atoms, tmpdir, job_results_dir = _calc_setup(atoms, copy_files=copy_files)\n\n    # Run calculation\n    vib = Vibrations(atoms, name=str(Path(tmpdir, \"vib\")), **vib_kwargs)\n    vib.run()\n    vib.summary(log=str(Path(tmpdir, \"vib_summary.log\")))\n\n    # Perform cleanup operations\n    _calc_cleanup(tmpdir, job_results_dir)\n\n    return vib\n</code></pre>"},{"location":"reference/quacc/runners/calc.html#quacc.runners.calc.run_calc","title":"run_calc","text":"<pre><code>run_calc(atoms, geom_file=None, copy_files=None)\n</code></pre> <p>Run a calculation in a scratch directory and copy the results back to the original directory. This can be useful if file I/O is slow in the working directory, so long as file transfer speeds are reasonable.</p> <p>This is a wrapper around atoms.get_potential_energy(). Note: This function does not modify the atoms object in-place.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>The Atoms object to run the calculation on.</p> </li> <li> <code>geom_file</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The filename of the log file that contains the output geometry, used to update the atoms object's positions and cell after a job. It is better to specify this rather than relying on ASE's atoms.get_potential_energy() function to update the positions, as this varies between codes.</p> </li> <li> <code>copy_files</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Filenames to copy from source to scratch directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>         \u2013          <p>The updated Atoms object.</p> </li> </ul> Source code in <code>quacc/runners/calc.py</code> <pre><code>def run_calc(\n    atoms: Atoms, geom_file: str | None = None, copy_files: list[str] | None = None\n) -&gt; Atoms:\n    \"\"\"\n    Run a calculation in a scratch directory and copy the results back to the\n    original directory. This can be useful if file I/O is slow in the working\n    directory, so long as file transfer speeds are reasonable.\n\n    This is a wrapper around atoms.get_potential_energy(). Note: This function\n    does not modify the atoms object in-place.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object to run the calculation on.\n    geom_file\n        The filename of the log file that contains the output geometry, used to\n        update the atoms object's positions and cell after a job. It is better\n        to specify this rather than relying on ASE's\n        atoms.get_potential_energy() function to update the positions, as this\n        varies between codes.\n    copy_files\n        Filenames to copy from source to scratch directory.\n\n    Returns\n    -------\n    Atoms\n        The updated Atoms object.\n    \"\"\"\n\n    # Perform staging operations\n    atoms, tmpdir, job_results_dir = _calc_setup(atoms, copy_files=copy_files)\n\n    # Run calculation via get_potential_energy()\n    atoms.get_potential_energy()\n\n    # Most ASE calculators do not update the atoms object in-place with a call\n    # to .get_potential_energy(), which is important if an internal optimizer is\n    # used. This section is done to ensure that the atoms object is updated with\n    # the correct positions and cell if a `geom_file` is provided.\n    if geom_file:\n        # Note: We have to be careful to make sure we don't lose the converged\n        # magnetic moments, if present. That's why we simply update the\n        # positions and cell in-place.\n        atoms_new = read(zpath(Path(tmpdir, geom_file)))\n        if isinstance(atoms_new, list):\n            atoms_new = atoms_new[-1]\n\n        # Make sure the atom indices didn't get updated somehow (sanity check).\n        # If this happens, there is a serious problem.\n        if (\n            np.array_equal(atoms_new.get_atomic_numbers(), atoms.get_atomic_numbers())\n            is False\n        ):\n            raise ValueError(\"Atomic numbers do not match between atoms and geom_file.\")\n\n        atoms.positions = atoms_new.positions\n        atoms.cell = atoms_new.cell\n\n    # Perform cleanup operations\n    _calc_cleanup(tmpdir, job_results_dir)\n\n    return atoms\n</code></pre>"},{"location":"reference/quacc/runners/prep.html","title":"prep","text":"<p>Utility functions for dealing with Atoms</p>"},{"location":"reference/quacc/runners/prep.html#quacc.runners.prep.prep_next_run","title":"prep_next_run","text":"<pre><code>prep_next_run(atoms, assign_id=True, move_magmoms=True)\n</code></pre> <p>Prepares the Atoms object for a new run.</p> <p>Depending on the arguments, this function will:     - Move the converged magnetic moments to the initial magnetic moments.     - Assign a unique ID to the Atoms object in atoms.info[\"_id\"]. Any       existing IDs will be moved to atoms.info[\"_old_ids\"].</p> <p>In all cases, the calculator will be reset so new jobs can be run.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>assign_id</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to assign a unique ID to the Atoms object in atoms.info[\"_id\"]. Any existing IDs will be moved to atoms.info[\"_old_ids\"].</p> </li> <li> <code>move_magmoms</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If True, move atoms.calc.results[\"magmoms\"] to atoms.get_initial_magnetic_moments()</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>         \u2013          <p>Updated Atoms object.</p> </li> </ul> Source code in <code>quacc/runners/prep.py</code> <pre><code>def prep_next_run(\n    atoms: Atoms, assign_id: bool = True, move_magmoms: bool = True\n) -&gt; Atoms:\n    \"\"\"\n    Prepares the Atoms object for a new run.\n\n    Depending on the arguments, this function will:\n        - Move the converged magnetic moments to the initial magnetic moments.\n        - Assign a unique ID to the Atoms object in atoms.info[\"_id\"]. Any\n          existing IDs will be moved to atoms.info[\"_old_ids\"].\n\n    In all cases, the calculator will be reset so new jobs can be run.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    assign_id\n        Whether to assign a unique ID to the Atoms object in atoms.info[\"_id\"].\n        Any existing IDs will be moved to atoms.info[\"_old_ids\"].\n    move_magmoms\n        If True, move atoms.calc.results[\"magmoms\"] to\n        atoms.get_initial_magnetic_moments()\n\n    Returns\n    -------\n    Atoms\n        Updated Atoms object.\n    \"\"\"\n    atoms = copy_atoms(atoms)\n\n    if (\n        move_magmoms\n        and hasattr(atoms, \"calc\")\n        and getattr(atoms.calc, \"results\", None) is not None\n    ):\n        # If there are initial magmoms set, then we should see what the final\n        # magmoms are. If they are present, move them to initial. If they are\n        # not present, it means the calculator doesn't support the \"magmoms\"\n        # property so we have to retain the initial magmoms given no further\n        # info.\n        if atoms.has(\"initial_magmoms\"):\n            atoms.set_initial_magnetic_moments(\n                atoms.calc.results.get(\"magmoms\", atoms.get_initial_magnetic_moments())\n            )\n        # If there are no initial magmoms set, just check the results and set\n        # everything to 0.0 if there is nothing there.\n        else:\n            atoms.set_initial_magnetic_moments(\n                atoms.calc.results.get(\"magmoms\", [0.0] * len(atoms))\n            )\n\n    # Clear off the calculator so we can run a new job. If we don't do this,\n    # then something like atoms *= (2,2,2) still has a calculator attached,\n    # which is a bit confusing.\n    atoms.calc = None\n\n    # Give the Atoms object a unique ID. This will be helpful for querying\n    # later. Also store any old IDs somewhere else for future reference. Note:\n    # Keep this at the end of the function so that the ID is assigned based on\n    # the returned Atoms object.\n    if assign_id:\n        if atoms.info.get(\"_id\", None) is not None:\n            if atoms.info.get(\"_old_ids\") is None:\n                atoms.info[\"_old_ids\"] = []\n            atoms.info[\"_old_ids\"].append(atoms.info[\"_id\"])\n        atoms.info[\"_id\"] = get_atoms_id(atoms)\n\n    return atoms\n</code></pre>"},{"location":"reference/quacc/runners/prep.html#quacc.runners.prep.set_magmoms","title":"set_magmoms","text":"<pre><code>set_magmoms(\n    atoms,\n    elemental_mags_dict=None,\n    elemental_mags_default=1.0,\n    copy_magmoms=True,\n    mag_cutoff=0.05,\n)\n</code></pre> <p>Sets the initial magnetic moments in the Atoms object.</p> <p>This function deserves particular attention. The following logic is applied: - If there is a converged set of magnetic moments, those are moved to the initial magmoms if copy_magmoms is True. - If there is no converged set of magnetic moments but the user has set initial magmoms, those are simply used as is. - If there are no converged magnetic moments or initial magnetic moments, then the default magnetic moments from the preset elemental_mags_dict (if specified) are set as the initial magnetic moments. - For any of the above scenarios, if mag_cutoff is not None, the newly set initial magnetic moments are checked. If all have a magnitude below mag_cutoff, then they are all set to 0 (no spin polarization).</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>Atoms object</p> </li> <li> <code>elemental_mags_dict</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Dictionary of elemental symbols and their corresponding magnetic moments to set. If None, no default values will be used.</p> </li> <li> <code>elemental_mags_default</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Default magnetic moment on an element if no magnetic moment is specified in the elemental_mags_dict. Only used if elemental_mags_dict is not None. This kwarg is mainly a convenience so that you don't need to list every single element in the elemental_mags_dict.</p> </li> <li> <code>copy_magmoms</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to copy the magnetic moments from the converged set of magnetic moments to the initial magnetic moments.</p> </li> <li> <code>mag_cutoff</code>             (<code>float | None</code>, default:                 <code>0.05</code> )         \u2013          <p>Magnitude below which the magnetic moments are considered to be zero. If None, no cutoff will be applied</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>         \u2013          <p>Atoms object</p> </li> </ul> Source code in <code>quacc/runners/prep.py</code> <pre><code>def set_magmoms(\n    atoms: Atoms,\n    elemental_mags_dict: dict | None = None,\n    elemental_mags_default: float = 1.0,\n    copy_magmoms: bool = True,\n    mag_cutoff: float | None = 0.05,\n) -&gt; Atoms:  # sourcery skip\n    \"\"\"\n    Sets the initial magnetic moments in the Atoms object.\n\n    This function deserves particular attention. The following logic is applied:\n    - If there is a converged set of magnetic moments, those are moved to the\n    initial magmoms if copy_magmoms is True. - If there is no converged set of\n    magnetic moments but the user has set initial magmoms, those are simply used\n    as is. - If there are no converged magnetic moments or initial magnetic\n    moments, then the default magnetic moments from the preset\n    elemental_mags_dict (if specified) are set as the initial magnetic moments.\n    - For any of the above scenarios, if mag_cutoff is not None, the newly set\n    initial magnetic moments are checked. If all have a magnitude below\n    mag_cutoff, then they are all set to 0 (no spin polarization).\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    elemental_mags_dict\n        Dictionary of elemental symbols and their corresponding magnetic moments\n        to set. If None, no default values will be used.\n    elemental_mags_default\n        Default magnetic moment on an element if no magnetic moment is specified\n        in the elemental_mags_dict. Only used if elemental_mags_dict is not\n        None. This kwarg is mainly a convenience so that you don't need to list\n        every single element in the elemental_mags_dict.\n    copy_magmoms\n        Whether to copy the magnetic moments from the converged set of magnetic\n        moments to the initial magnetic moments.\n    mag_cutoff\n        Magnitude below which the magnetic moments are considered to be zero. If\n        None, no cutoff will be applied\n\n    Returns\n    -------\n    Atoms\n        Atoms object\n    \"\"\"\n\n    # Handle the magnetic moments Check if a prior job was run and pull the\n    # prior magmoms\n    if hasattr(atoms, \"calc\") and getattr(atoms.calc, \"results\", None) is not None:\n        mags = atoms.calc.results.get(\"magmoms\", [0.0] * len(atoms))\n        # Note: It is important that we set mags to 0.0 here rather than None if\n        # the calculator has no magmoms because: 1) ispin=1 might be set, and 2)\n        # we do not want the preset magmoms to be used.\n    else:\n        mags = None\n\n    # Check if the user has set any initial magmoms\n    has_initial_mags = atoms.has(\"initial_magmoms\")\n\n    # If there are no initial magmoms set and this is not a follow-up job, we\n    # may need to add some from the preset yaml.\n    if mags is None:\n        if not has_initial_mags:\n            # If the preset dictionary has default magmoms, set those by\n            # element. If the element isn't in the magmoms dict then set it to\n            # mag_default.\n            if elemental_mags_dict:\n                initial_mags = np.array(\n                    [\n                        elemental_mags_dict.get(atom.symbol, elemental_mags_default)\n                        for atom in atoms\n                    ]\n                )\n                atoms.set_initial_magnetic_moments(initial_mags)\n        else:\n            pass\n    elif copy_magmoms:\n        atoms.set_initial_magnetic_moments(mags)\n\n    # If all the set mags are below mag_cutoff, set them to 0\n    if mag_cutoff:\n        has_new_initial_mags = atoms.has(\"initial_magmoms\")\n        new_initial_mags = atoms.get_initial_magnetic_moments()\n        if has_new_initial_mags and np.all(np.abs(new_initial_mags) &lt; mag_cutoff):\n            atoms.set_initial_magnetic_moments([0.0] * len(atoms))\n\n    return atoms\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html","title":"ase","text":"<p>Schemas for storing ASE-based data</p>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.summarize_ideal_gas_thermo","title":"summarize_ideal_gas_thermo","text":"<pre><code>summarize_ideal_gas_thermo(\n    igt,\n    temperature=298.15,\n    pressure=1.0,\n    charge_and_multiplicity=None,\n    additional_fields=None,\n    store=None,\n)\n</code></pre> <p>Get tabulated results from an ASE IdealGasThermo object and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> <code>igt</code>             (<code>IdealGasThermo</code>)         \u2013          <p>ASE IdealGasThermo object.</p> </li> <li> <code>temperature</code>             (<code>float</code>, default:                 <code>298.15</code> )         \u2013          <p>Temperature in Kelvins.</p> </li> <li> <code>pressure</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Pressure in bar.</p> </li> <li> <code>charge_and_multiplicity</code>             (<code>tuple[int, int] | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> <code>additional_fields</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the task document.</p> </li> <li> <code>store</code>             (<code>Store | None</code>, default:                 <code>None</code> )         \u2013          <p>Maggma Store object to store the results in. If None, <code>SETTINGS.PRIMARY_STORE</code> will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ThermoSchema</code>         \u2013          <p>Dictionary representation of the task document with the following fields:</p> <ul> <li>atoms: Atoms = Field(None, title = \"The Atoms object from the   calculation result.\")</li> <li>atoms_info: dict = Field(None, title = \"The Atoms object info obtained   from atoms.info.\")</li> <li>builder_meta: EmmetMeta = Field(default_factory=EmmetMeta,   description=\"Builder metadata.\"):<ul> <li>builder_meta.build_date: str =   Field(default_factory=datetime.utcnow, description=\"The build date   for this document.\")</li> <li>builder_meta.database_version: str = Field(None, description=\"The   database version for the built data.\")</li> <li>builder_meta.emmet_version: str = Field(version,   description=\"The version of emmet this document was built with.\")</li> <li>builder_meta.pymatgen_version: str = Field(pmg_version,   description=\"The version of pymatgen this document was built   with.\")</li> <li>builder_meta.pull_request: int = Field(None, description=\"The pull   request number associated with this data build.\")</li> </ul> </li> <li>dir_name: str = Field(None, description=\"Directory where the output is   parsed\")</li> <li>nid: str = Field(None, title = \"The node ID representing the machine   where the calculation was run.\")</li> <li>thermo_parameters: dict = Field(None, title = \"the parameters used to   run the thermo calculation.\")<ul> <li>thermo_parameters.temperature: float = Temperature in Kelvins</li> <li>thermo_parameters.pressure: float = Pressure in bar</li> <li>thermo_parameters.sigma: float = The rotational symmetry number of   the molecule</li> <li>thermo_parameters.spin_multiplicity: int = The spin multiplicity   of the molecule</li> <li>thermo_parameters.vib_freqs: List[float] = Vibrational frequencies   in cm^-1 used for the thermo calculation</li> <li>thermo_parameters.vib_energies: List[float] = Vibrational energies   in eV used for the thermo calculation</li> <li>thermo_parameters.n_imag: int = Number of imaginary vibrational   frequencies ignored in the thermo calculation</li> </ul> </li> <li>results: dict = Field(None, title = \"The results from the   calculation.\")<ul> <li>results.energy: float = The potential energy of the system in eV</li> <li>results.enthalpy: float = The enthalpy of the system in eV</li> <li>results.entropy: float = The entropy of the system in eV/K</li> <li>results.gibbs_energy: float = The Gibbs free energy of the system   in eV</li> <li>results.zpe: float = The zero point vibrational energy of the   system in eV</li> </ul> </li> </ul> <p>The task document also has the following fields from the Molecule object:</p> <ul> <li>charge: int = Field(None, description=\"Charge of the molecule\")</li> <li>chemsys: str = Field(None, title=\"Chemical System\",   description=\"dash-delimited string of elements in the  molecule\")</li> <li>composition: Composition = Field(None, description=\"Full composition   for the molecule\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced   Composition\", description=\"Simplified  representation of the composition\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in   the molecule\")</li> <li>formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\",   description=\"Alphabetical molecular  formula\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\",   description=\"Anonymized representation of  the formula\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\",   description=\"Cleaned representation of the  formula.\")</li> <li>natoms: int = Field(None, description=\"Total number of atoms in the   molecule\")</li> <li>molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object   from the Atoms object, if not  periodic and store_pmg is True.\")</li> <li>nelectrons: int = Field(None, title=\"Number of electrons\",   description=\"The total number of electrons for  the molecule\")</li> <li>nelements: int = Field(None, title=\"Number of Elements\")</li> <li>spin_multiplicity: int = Field(None, description=\"Spin multiplicity of   the molecule\")</li> <li>symmetry: PointGroupData = Field(None, description=\"Symmetry data for   this molecule\")<ul> <li>symmetry.eigen_tolerance: float = Field(None, title=\"Interia   Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare   eigen values of the inertia tensor.\")</li> <li>symmetry.linear: bool = Field(None, title=\"Molecule Linearity\",   description=\"Is the molecule linear?\")</li> <li>symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry   Operation Matrix Element Tolerance\" description=\"Tolerance used to   generate the full set of symmetry operations of the point group.\")</li> <li>symmetry.rotation_number: float = Field(None, title=\"Rotational   Symmetry Number\", description=\"Rotational symmetry number for the   molecule\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group   Symbol\", description=\"The point group for the lattice\")</li> <li>symmetry.tolerance: float = Field(None, title=\"Point Group   Analyzer Tolerance\", description=\"Distance tolerance to consider   sites as symmetrically equivalent.\")</li> </ul> </li> </ul> </li> </ul> Source code in <code>quacc/schemas/ase.py</code> <pre><code>def summarize_ideal_gas_thermo(\n    igt: IdealGasThermo,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    charge_and_multiplicity: tuple[int, int] | None = None,\n    additional_fields: dict | None = None,\n    store: Store | None = None,\n) -&gt; ThermoSchema:\n    \"\"\"\n    Get tabulated results from an ASE IdealGasThermo object and store them in a\n    database-friendly format.\n\n    Parameters\n    ----------\n    igt\n        ASE IdealGasThermo object.\n    temperature\n        Temperature in Kelvins.\n    pressure\n        Pressure in bar.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule\n        metadata.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. If None,\n        `SETTINGS.PRIMARY_STORE` will be used.\n\n    Returns\n    -------\n    ThermoSchema\n        Dictionary representation of the task document with the following\n        fields:\n\n        - atoms: Atoms = Field(None, title = \"The Atoms object from the\n          calculation result.\")\n        - atoms_info: dict = Field(None, title = \"The Atoms object info obtained\n          from atoms.info.\")\n        - builder_meta: EmmetMeta = Field(default_factory=EmmetMeta,\n          description=\"Builder metadata.\"):\n            - builder_meta.build_date: str =\n              Field(default_factory=datetime.utcnow, description=\"The build date\n              for this document.\")\n            - builder_meta.database_version: str = Field(None, description=\"The\n              database version for the built data.\")\n            - builder_meta.emmet_version: str = Field(__version__,\n              description=\"The version of emmet this document was built with.\")\n            - builder_meta.pymatgen_version: str = Field(pmg_version,\n              description=\"The version of pymatgen this document was built\n              with.\")\n            - builder_meta.pull_request: int = Field(None, description=\"The pull\n              request number associated with this data build.\")\n        - dir_name: str = Field(None, description=\"Directory where the output is\n          parsed\")\n        - nid: str = Field(None, title = \"The node ID representing the machine\n          where the calculation was run.\")\n        - thermo_parameters: dict = Field(None, title = \"the parameters used to\n          run the thermo calculation.\")\n            - thermo_parameters.temperature: float = Temperature in Kelvins\n            - thermo_parameters.pressure: float = Pressure in bar\n            - thermo_parameters.sigma: float = The rotational symmetry number of\n              the molecule\n            - thermo_parameters.spin_multiplicity: int = The spin multiplicity\n              of the molecule\n            - thermo_parameters.vib_freqs: List[float] = Vibrational frequencies\n              in cm^-1 used for the thermo calculation\n            - thermo_parameters.vib_energies: List[float] = Vibrational energies\n              in eV used for the thermo calculation\n            - thermo_parameters.n_imag: int = Number of imaginary vibrational\n              frequencies ignored in the thermo calculation\n        - results: dict = Field(None, title = \"The results from the\n          calculation.\")\n            - results.energy: float = The potential energy of the system in eV\n            - results.enthalpy: float = The enthalpy of the system in eV\n            - results.entropy: float = The entropy of the system in eV/K\n            - results.gibbs_energy: float = The Gibbs free energy of the system\n              in eV\n            - results.zpe: float = The zero point vibrational energy of the\n              system in eV\n\n        The task document also has the following fields from the Molecule\n        object:\n\n        - charge: int = Field(None, description=\"Charge of the molecule\")\n        - chemsys: str = Field(None, title=\"Chemical System\",\n          description=\"dash-delimited string of elements in the\n         molecule\")\n        - composition: Composition = Field(None, description=\"Full composition\n          for the molecule\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced\n          Composition\", description=\"Simplified\n         representation of the composition\")\n        - elements: List[Element] = Field(None, description=\"List of elements in\n          the molecule\")\n        - formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\",\n          description=\"Alphabetical molecular\n         formula\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\",\n          description=\"Anonymized representation of\n         the formula\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\",\n          description=\"Cleaned representation of the\n         formula.\")\n        - natoms: int = Field(None, description=\"Total number of atoms in the\n          molecule\")\n        - molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object\n          from the Atoms object, if not\n         periodic and store_pmg is True.\")\n        - nelectrons: int = Field(None, title=\"Number of electrons\",\n          description=\"The total number of electrons for\n         the molecule\")\n        - nelements: int = Field(None, title=\"Number of Elements\")\n        - spin_multiplicity: int = Field(None, description=\"Spin multiplicity of\n          the molecule\")\n        - symmetry: PointGroupData = Field(None, description=\"Symmetry data for\n          this molecule\")\n            - symmetry.eigen_tolerance: float = Field(None, title=\"Interia\n              Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare\n              eigen values of the inertia tensor.\")\n            - symmetry.linear: bool = Field(None, title=\"Molecule Linearity\",\n              description=\"Is the molecule linear?\")\n            - symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry\n              Operation Matrix Element Tolerance\" description=\"Tolerance used to\n              generate the full set of symmetry operations of the point group.\")\n            - symmetry.rotation_number: float = Field(None, title=\"Rotational\n              Symmetry Number\", description=\"Rotational symmetry number for the\n              molecule\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group\n              Symbol\", description=\"The point group for the lattice\")\n            - symmetry.tolerance: float = Field(None, title=\"Point Group\n              Analyzer Tolerance\", description=\"Distance tolerance to consider\n              sites as symmetrically equivalent.\")\n    \"\"\"\n\n    additional_fields = additional_fields or {}\n    store = SETTINGS.PRIMARY_STORE if store is None else store\n\n    uri = get_uri(Path.cwd())\n    spin_multiplicity = round(2 * igt.spin + 1)\n\n    inputs = {\n        \"parameters_thermo\": {\n            \"temperature\": temperature,\n            \"pressure\": pressure,\n            \"sigma\": igt.sigma,\n            \"spin_multiplicity\": spin_multiplicity,\n            \"vib_freqs\": [e / units.invcm for e in igt.vib_energies],\n            \"vib_energies\": igt.vib_energies.tolist(),\n            \"n_imag\": igt.n_imag,\n        },\n        \"nid\": uri.split(\":\")[0],\n        \"dir_name\": \":\".join(uri.split(\":\")[1:]),\n    }\n\n    results = {\n        \"results\": {\n            \"energy\": igt.potentialenergy,\n            \"enthalpy\": igt.get_enthalpy(temperature),\n            \"entropy\": igt.get_entropy(temperature, pressure * 10**5),\n            \"gibbs_energy\": igt.get_gibbs_energy(temperature, pressure * 10**5),\n            \"zpe\": igt.get_ZPE_correction(),\n        }\n    }\n\n    if charge_and_multiplicity and spin_multiplicity != charge_and_multiplicity[1]:\n        msg = (\n            \"The IdealGasThermo spin multiplicity does not match the user-specified multiplicity.\",\n        )\n        raise ValueError(msg)\n\n    atoms_db = atoms_to_metadata(\n        igt.atoms, charge_and_multiplicity=charge_and_multiplicity\n    )\n\n    task_doc = sort_dict(atoms_db | inputs | results | additional_fields)\n\n    if store:\n        results_to_db(store, task_doc)\n\n    return task_doc\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.summarize_opt_run","title":"summarize_opt_run","text":"<pre><code>summarize_opt_run(\n    dyn,\n    trajectory=None,\n    check_convergence=None,\n    charge_and_multiplicity=None,\n    prep_next_run=True,\n    additional_fields=None,\n    store=None,\n)\n</code></pre> <p>Get tabulated results from an ASE Atoms trajectory and store them in a database-friendly format. This is meant to be compatible with all calculator types.</p> <p>Parameters:</p> <ul> <li> <code>dyn</code>             (<code>Optimizer</code>)         \u2013          <p>ASE Optimizer object.</p> </li> <li> <code>trajectory</code>             (<code>Trajectory | list[Atoms]</code>, default:                 <code>None</code> )         \u2013          <p>ASE Trajectory object or list[Atoms] from reading a trajectory file. If None, the trajectory must be found in dyn.traj_atoms.</p> </li> <li> <code>check_convergence</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to check the convergence of the calculation. Defaults to True in settings.</p> </li> <li> <code>charge_and_multiplicity</code>             (<code>tuple[int, int] | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> <code>prep_next_run</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the Atoms object stored in {\"atoms\": atoms} should be prepared for the next run This clears out any attached calculator and moves the final magmoms to the initial magmoms.</p> </li> <li> <code>additional_fields</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the task document.</p> </li> <li> <code>store</code>             (<code>Store | None</code>, default:                 <code>None</code> )         \u2013          <p>Maggma Store object to store the results in. If None, <code>SETTINGS.PRIMARY_STORE</code> will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>         \u2013          <p>Dictionary representation of the task document with the following fields:</p> <ul> <li>atoms: Atoms = Field(None, title = \"The Atoms object from the   calculation result.\")</li> <li>atoms_info: dict = Field(None, title = \"The Atoms object info obtained   from atoms.info.\")</li> <li>builder_meta: EmmetMeta = Field(default_factory=EmmetMeta,   description=\"Builder metadata.\"):<ul> <li>builder_meta.build_date: str =   Field(default_factory=datetime.utcnow, description=\"The build date   for this document.\")</li> <li>builder_meta.database_version: str = Field(None, description=\"The   database version for the built data.\")</li> <li>builder_meta.emmet_version: str = Field(version,   description=\"The version of emmet this document was built with.\")</li> <li>builder_meta.pymatgen_version: str = Field(pmg_version,   description=\"The version of pymatgen this document was built   with.\")</li> <li>builder_meta.pull_request: int = Field(None, description=\"The pull   request number associated with this data build.\")</li> </ul> </li> <li>dir_name: str = Field(None, description=\"Directory where the output is   parsed\")</li> <li>input_structure: Molecule | Structure = Field(None, title = \"The   Pymatgen Structure or Molecule object from  the input Atoms object if input_atoms is not None.\")</li> <li>nid: str = Field(None, title = \"The node ID representing the machine   where the calculation was run.\")</li> <li>parameters: dict = Field(None, title = \"the parameters used to run the   calculation.\")</li> <li>opt_parameters: dict = Field(None, title = \"the parameters used to run   the optimization.\")</li> <li>results: dict = Field(None, title = \"The results from the   calculation.\")</li> <li>trajectory: List[AtomsSchema] = List containing the AtomsSchema from a   reading the trajectory file. Each entry contains the output Atoms   object in the key \"atoms\".</li> <li>trajectory_results: List[dict] = List of ase.calc.results from the   trajectory</li> </ul> <p>For periodic structures, the task document also has the following fields:</p> <ul> <li>chemsys: str = Field(None, title=\"Chemical System\",   description=\"dash-delimited string of elements in the material.\")</li> <li>composition: Composition = Field(None, description=\"Full composition   for the material.\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced   Composition\", description=\"Simplified  representation of the composition.\")</li> <li>density: float = Field(None, title=\"Density\", description=\"Density in   grams per cm^3.\")</li> <li>density_atomic: float = Field(None, title=\"Packing Density\",   description=\"The atomic packing density in  atoms per cm^3.\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in   the material.\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\",   description=\"Anonymized representation  of the formula.\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\",   description=\"Cleaned representation of the  formula.\")</li> <li>nelements: int = Field(None, description=\"Number of elements.\")</li> <li>nsites: int = Field(None, description=\"Total number of sites in the   structure.\")</li> <li>structure: Structure = Field(None, title = \"The Pymatgen Structure   object from the Atoms object, if periodic  and store_pmg is True.\")</li> <li>symmetry: SymmetryData = Field(None, description=\"Symmetry data for   this material.\")<ul> <li>symmetry.crystal_system: CrystalSystem = Field(None,   title=\"Crystal System\", description=\"The crystal system for this   lattice.\")</li> <li>symmetry.number: int = Field(None, title=\"Space Group Number\",   description=\"The spacegroup number for the lattice.\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group   Symbol\", description=\"The point group for the lattice.\")</li> <li>symmetry.symbol: str = Field(None, title=\"Space Group Symbol\",   description=\"The spacegroup symbol for the lattice.\")</li> <li>symmetry.symprec: float = Field(None, title=\"Symmetry Finding   Precision\", description=\"The precision given to spglib to   determine the symmetry of this lattice.\")</li> </ul> </li> <li>volume: float = Field(None, title=\"Volume\", description=\"Total volume   for this structure in Angstroms^3.\")</li> </ul> <p>For molecules that lack periodicity, the task document also has the following fields:</p> <ul> <li>charge: int = Field(None, description=\"Charge of the molecule\")</li> <li>chemsys: str = Field(None, title=\"Chemical System\",   description=\"dash-delimited string of elements in  the molecule\")</li> <li>composition: Composition = Field(None, description=\"Full composition   for the molecule\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced   Composition\", description=\"Simplified  representation of the composition\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in   the molecule\")</li> <li>formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\",   description=\"Alphabetical molecular  formula\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\",   description=\"Anonymized representation  of the formula\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\",   description=\"Cleaned representation of the  formula.\")</li> <li>molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object   from the Atoms object, if not  periodic and store_pmg is True.\")</li> <li>natoms: int = Field(None, description=\"Total number of atoms in the   molecule\")</li> <li>nelectrons: int = Field(None, title=\"Number of electrons\",   description=\"The total number of electrons for  the molecule\")</li> <li>nelements: int = Field(None, title=\"Number of Elements\")</li> <li>spin_multiplicity: int = Field(None, description=\"Spin multiplicity of   the molecule\")</li> <li>symmetry: PointGroupData = Field(None, description=\"Symmetry data for   this molecule\")<ul> <li>symmetry.eigen_tolerance: float = Field(None, title=\"Interia   Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare   eigen values of the inertia tensor.\")</li> <li>symmetry.linear: bool = Field(None, title=\"Molecule Linearity\",   description=\"Is the molecule linear?\")</li> <li>symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry   Operation Matrix Element Tolerance\" description=\"Tolerance used to   generate the full set of symmetry operations of the point group.\")</li> <li>symmetry.rotation_number: float = Field(None, title=\"Rotational   Symmetry Number\", description=\"Rotational symmetry number for the   molecule\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group   Symbol\", description=\"The point group for the lattice\")</li> <li>symmetry.tolerance: float = Field(None, title=\"Point Group   Analyzer Tolerance\", description=\"Distance tolerance to consider   sites as symmetrically equivalent.\")</li> </ul> </li> </ul> </li> </ul> Source code in <code>quacc/schemas/ase.py</code> <pre><code>def summarize_opt_run(\n    dyn: Optimizer,\n    trajectory: Trajectory | list[Atoms] = None,\n    check_convergence: bool | None = None,\n    charge_and_multiplicity: tuple[int, int] | None = None,\n    prep_next_run: bool = True,\n    additional_fields: dict | None = None,\n    store: Store | None = None,\n) -&gt; OptSchema:\n    \"\"\"\n    Get tabulated results from an ASE Atoms trajectory and store them in a\n    database-friendly format. This is meant to be compatible with all calculator\n    types.\n\n    Parameters\n    ----------\n    dyn\n        ASE Optimizer object.\n    trajectory\n        ASE Trajectory object or list[Atoms] from reading a trajectory file. If\n        None, the trajectory must be found in dyn.traj_atoms.\n    check_convergence\n        Whether to check the convergence of the calculation. Defaults to True in\n        settings.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule\n        metadata.\n    prep_next_run\n        Whether the Atoms object stored in {\"atoms\": atoms} should be prepared\n        for the next run This clears out any attached calculator and moves the\n        final magmoms to the initial magmoms.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. If None,\n        `SETTINGS.PRIMARY_STORE` will be used.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary representation of the task document with the following\n        fields:\n\n        - atoms: Atoms = Field(None, title = \"The Atoms object from the\n          calculation result.\")\n        - atoms_info: dict = Field(None, title = \"The Atoms object info obtained\n          from atoms.info.\")\n        - builder_meta: EmmetMeta = Field(default_factory=EmmetMeta,\n          description=\"Builder metadata.\"):\n            - builder_meta.build_date: str =\n              Field(default_factory=datetime.utcnow, description=\"The build date\n              for this document.\")\n            - builder_meta.database_version: str = Field(None, description=\"The\n              database version for the built data.\")\n            - builder_meta.emmet_version: str = Field(__version__,\n              description=\"The version of emmet this document was built with.\")\n            - builder_meta.pymatgen_version: str = Field(pmg_version,\n              description=\"The version of pymatgen this document was built\n              with.\")\n            - builder_meta.pull_request: int = Field(None, description=\"The pull\n              request number associated with this data build.\")\n        - dir_name: str = Field(None, description=\"Directory where the output is\n          parsed\")\n        - input_structure: Molecule | Structure = Field(None, title = \"The\n          Pymatgen Structure or Molecule object from\n         the input Atoms object if input_atoms is not None.\")\n        - nid: str = Field(None, title = \"The node ID representing the machine\n          where the calculation was run.\")\n        - parameters: dict = Field(None, title = \"the parameters used to run the\n          calculation.\")\n        - opt_parameters: dict = Field(None, title = \"the parameters used to run\n          the optimization.\")\n        - results: dict = Field(None, title = \"The results from the\n          calculation.\")\n        - trajectory: List[AtomsSchema] = List containing the AtomsSchema from a\n          reading the trajectory file. Each entry contains the output Atoms\n          object in the key \"atoms\".\n        - trajectory_results: List[dict] = List of ase.calc.results from the\n          trajectory\n\n        For periodic structures, the task document also has the following\n        fields:\n\n        - chemsys: str = Field(None, title=\"Chemical System\",\n          description=\"dash-delimited string of elements in the material.\")\n        - composition: Composition = Field(None, description=\"Full composition\n          for the material.\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced\n          Composition\", description=\"Simplified\n         representation of the composition.\")\n        - density: float = Field(None, title=\"Density\", description=\"Density in\n          grams per cm^3.\")\n        - density_atomic: float = Field(None, title=\"Packing Density\",\n          description=\"The atomic packing density in\n         atoms per cm^3.\")\n        - elements: List[Element] = Field(None, description=\"List of elements in\n          the material.\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\",\n          description=\"Anonymized representation\n         of the formula.\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\",\n          description=\"Cleaned representation of the\n         formula.\")\n        - nelements: int = Field(None, description=\"Number of elements.\")\n        - nsites: int = Field(None, description=\"Total number of sites in the\n          structure.\")\n        - structure: Structure = Field(None, title = \"The Pymatgen Structure\n          object from the Atoms object, if periodic\n         and store_pmg is True.\")\n        - symmetry: SymmetryData = Field(None, description=\"Symmetry data for\n          this material.\")\n            - symmetry.crystal_system: CrystalSystem = Field(None,\n              title=\"Crystal System\", description=\"The crystal system for this\n              lattice.\")\n            - symmetry.number: int = Field(None, title=\"Space Group Number\",\n              description=\"The spacegroup number for the lattice.\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group\n              Symbol\", description=\"The point group for the lattice.\")\n            - symmetry.symbol: str = Field(None, title=\"Space Group Symbol\",\n              description=\"The spacegroup symbol for the lattice.\")\n            - symmetry.symprec: float = Field(None, title=\"Symmetry Finding\n              Precision\", description=\"The precision given to spglib to\n              determine the symmetry of this lattice.\")\n        - volume: float = Field(None, title=\"Volume\", description=\"Total volume\n          for this structure in Angstroms^3.\")\n\n        For molecules that lack periodicity, the task document also has the\n        following fields:\n\n        - charge: int = Field(None, description=\"Charge of the molecule\")\n        - chemsys: str = Field(None, title=\"Chemical System\",\n          description=\"dash-delimited string of elements in\n         the molecule\")\n        - composition: Composition = Field(None, description=\"Full composition\n          for the molecule\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced\n          Composition\", description=\"Simplified\n         representation of the composition\")\n        - elements: List[Element] = Field(None, description=\"List of elements in\n          the molecule\")\n        - formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\",\n          description=\"Alphabetical molecular\n         formula\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\",\n          description=\"Anonymized representation\n         of the formula\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\",\n          description=\"Cleaned representation of the\n         formula.\")\n        - molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object\n          from the Atoms object, if not\n         periodic and store_pmg is True.\")\n        - natoms: int = Field(None, description=\"Total number of atoms in the\n          molecule\")\n        - nelectrons: int = Field(None, title=\"Number of electrons\",\n          description=\"The total number of electrons for\n         the molecule\")\n        - nelements: int = Field(None, title=\"Number of Elements\")\n        - spin_multiplicity: int = Field(None, description=\"Spin multiplicity of\n          the molecule\")\n        - symmetry: PointGroupData = Field(None, description=\"Symmetry data for\n          this molecule\")\n            - symmetry.eigen_tolerance: float = Field(None, title=\"Interia\n              Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare\n              eigen values of the inertia tensor.\")\n            - symmetry.linear: bool = Field(None, title=\"Molecule Linearity\",\n              description=\"Is the molecule linear?\")\n            - symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry\n              Operation Matrix Element Tolerance\" description=\"Tolerance used to\n              generate the full set of symmetry operations of the point group.\")\n            - symmetry.rotation_number: float = Field(None, title=\"Rotational\n              Symmetry Number\", description=\"Rotational symmetry number for the\n              molecule\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group\n              Symbol\", description=\"The point group for the lattice\")\n            - symmetry.tolerance: float = Field(None, title=\"Point Group\n              Analyzer Tolerance\", description=\"Distance tolerance to consider\n              sites as symmetrically equivalent.\")\n    \"\"\"\n\n    check_convergence = (\n        SETTINGS.CHECK_CONVERGENCE if check_convergence is None else check_convergence\n    )\n    additional_fields = additional_fields or {}\n    opt_parameters = dyn.todict()\n    if hasattr(dyn, \"fmax\"):\n        opt_parameters = opt_parameters | {\"fmax\": dyn.fmax}\n    store = SETTINGS.PRIMARY_STORE if store is None else store\n\n    # Check convergence\n    is_converged = dyn.converged()\n    if check_convergence and not is_converged:\n        msg = \"Optimization did not converge.\"\n        raise ValueError(msg)\n\n    # Get trajectory\n    if not trajectory:\n        trajectory = (\n            dyn.traj_atoms\n            if hasattr(dyn, \"traj_atoms\")\n            else read(dyn.trajectory.filename, index=\":\")\n        )\n\n    initial_atoms = trajectory[0]\n    final_atoms = dyn.atoms.atoms if isinstance(dyn.atoms, Filter) else dyn.atoms\n\n    # Get results\n    traj_results = {\n        \"trajectory_results\": [atoms.calc.results for atoms in trajectory],\n        \"trajectory\": [\n            atoms_to_metadata(atoms, charge_and_multiplicity=charge_and_multiplicity)\n            for atoms in trajectory\n        ],\n    }\n\n    results = {\n        \"results\": final_atoms.calc.results\n        | {\"converged\": is_converged, \"nsteps\": dyn.get_number_of_steps()}\n    }\n\n    # Get the calculator inputs\n    uri = get_uri(Path.cwd())\n    inputs = {\n        \"parameters\": dyn.atoms.calc.parameters,\n        \"parameters_opt\": opt_parameters,\n        \"nid\": uri.split(\":\")[0],\n        \"dir_name\": \":\".join(uri.split(\":\")[1:]),\n    }\n    input_atoms_db = atoms_to_metadata(\n        initial_atoms, charge_and_multiplicity=charge_and_multiplicity\n    )\n    inputs[\"input_structure\"] = input_atoms_db\n\n    # Prepares the Atoms object for the next run by moving the final magmoms to\n    # initial, clearing the calculator state, and assigning the resulting Atoms\n    # object a unique ID.\n    if prep_next_run:\n        final_atoms = prep_next_run_(final_atoms)\n\n    # Get tabulated properties of the structure itself\n    atoms_db = atoms_to_metadata(\n        final_atoms, charge_and_multiplicity=charge_and_multiplicity\n    )\n\n    # Create a dictionary of the inputs/outputs\n    task_doc = sort_dict(atoms_db | inputs | results | traj_results | additional_fields)\n\n    if store:\n        results_to_db(store, task_doc)\n\n    return task_doc\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.summarize_run","title":"summarize_run","text":"<pre><code>summarize_run(\n    atoms,\n    input_atoms=None,\n    charge_and_multiplicity=None,\n    prep_next_run=True,\n    additional_fields=None,\n    store=None,\n)\n</code></pre> <p>Get tabulated results from an Atoms object and calculator and store them in a database-friendly format. This is meant to be compatible with all calculator types.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>ASE Atoms following a calculation. A calculator must be attached.</p> </li> <li> <code>input_atoms</code>             (<code>Atoms | None</code>, default:                 <code>None</code> )         \u2013          <p>Input ASE Atoms object to store.</p> </li> <li> <code>charge_and_multiplicity</code>             (<code>tuple[int, int] | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> <code>prep_next_run</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the Atoms object stored in {\"atoms\": atoms} should be prepared for the next run This clears out any attached calculator and moves the final magmoms to the initial magmoms.</p> </li> <li> <code>additional_fields</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the task document.</p> </li> <li> <code>store</code>             (<code>Store | None</code>, default:                 <code>None</code> )         \u2013          <p>Maggma Store object to store the results in. If None, <code>SETTINGS.PRIMARY_STORE</code> will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>         \u2013          <p>Dictionary representation of the task document with the following fields:</p> <ul> <li>atoms: Atoms = Field(None, title = \"The Atoms object from the   calculation result.\")</li> <li>atoms_info: dict = Field(None, title = \"The Atoms object info obtained   from atoms.info.\")</li> <li>builder_meta: EmmetMeta = Field(default_factory=EmmetMeta,   description=\"Builder metadata.\"):<ul> <li>builder_meta.build_date: str =   Field(default_factory=datetime.utcnow, description=\"The build date   for this document.\")</li> <li>builder_meta.database_version: str = Field(None, description=\"The   database version for the built data.\")</li> <li>builder_meta.emmet_version: str = Field(version,   description=\"The version of emmet this document was built with.\")</li> <li>builder_meta.pymatgen_version: str = Field(pmg_version,   description=\"The version of pymatgen this document was built   with.\")</li> <li>builder_meta.pull_request: int = Field(None, description=\"The pull   request number associated with this data build.\")</li> </ul> </li> <li>dir_name: str = Field(None, description=\"Directory where the output is   parsed\")</li> <li>input_structure: Molecule | Structure = Field(None, title = \"The   Pymatgen Structure or Molecule object from  the input Atoms object if input_atoms is not None.\")</li> <li>nid: str = Field(None, title = \"The node ID representing the machine   where the calculation was run.\")</li> <li>parameters: dict = Field(None, title = \"the parameters used to run the   calculation.\")</li> <li>results: dict = Field(None, title = \"The results from the   calculation.\")</li> </ul> <p>For periodic structures, the task document also has the following fields: - chemsys: str = Field(None, title=\"Chemical System\", description=\"dash-delimited string of elements in the material.\") - composition: Composition = Field(None, description=\"Full composition for the material.\") - composition_reduced: Composition = Field(None, title=\"Reduced Composition\", description=\"Simplified  representation of the composition.\") - density: float = Field(None, title=\"Density\", description=\"Density in   grams per cm^3.\") - density_atomic: float = Field(None, title=\"Packing Density\",   description=\"The atomic packing density in  atoms per cm^3.\") - elements: List[Element] = Field(None, description=\"List of elements in   the material.\") - formula_anonymous: str = Field(None, title=\"Anonymous Formula\",   description=\"Anonymized representation  of the formula.\") - formula_pretty: str = Field(None, title=\"Pretty Formula\",   description=\"Cleaned representation of the  formula.\") - nelements: int = Field(None, description=\"Number of elements.\") - nsites: int = Field(None, description=\"Total number of sites in the   structure.\") - structure: Structure = Field(None, title = \"The Pymatgen Structure   object from the Atoms object, if  periodic and store_pmg is True.\") - symmetry: SymmetryData = Field(None, description=\"Symmetry data for   this material.\")     - symmetry.crystal_system: CrystalSystem = Field(None,       title=\"Crystal System\", description=\"The crystal system for this       lattice.\")     - symmetry.number: int = Field(None, title=\"Space Group Number\",       description=\"The spacegroup number for the lattice.\")     - symmetry.point_group: str = Field(None, title=\"Point Group       Symbol\", description=\"The point group for the lattice.\")     - symmetry.symbol: str = Field(None, title=\"Space Group Symbol\",       description=\"The spacegroup symbol for the lattice.\")     - symmetry.symprec: float = Field(None, title=\"Symmetry Finding       Precision\", description=\"The precision given to spglib to       determine the symmetry of this lattice.\") - volume: float = Field(None, title=\"Volume\", description=\"Total volume   for this structure in Angstroms^3.\")</p> <p>For molecules that lack periodicity, the task document also has the following fields:</p> <ul> <li>charge: int = Field(None, description=\"Charge of the molecule\")</li> <li>chemsys: str = Field(None, title=\"Chemical System\",   description=\"dash-delimited string of elements in the  molecule\")</li> <li>composition: Composition = Field(None, description=\"Full composition   for the molecule\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced   Composition\", description=\"Simplified  representation of the composition\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in   the molecule\")</li> <li>formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\",   description=\"Alphabetical molecular  formula\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\",   description=\"Anonymized representation of  the formula\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\",   description=\"Cleaned representation of the  formula.\")</li> <li>molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object   from the Atoms object, if not  periodic and store_pmg is True.\")</li> <li>natoms: int = Field(None, description=\"Total number of atoms in the   molecule\")</li> <li>nelectrons: int = Field(None, title=\"Number of electrons\",   description=\"The total number of electrons  for the molecule\")</li> <li>nelements: int = Field(None, title=\"Number of Elements\")</li> <li>spin_multiplicity: int = Field(None, description=\"Spin multiplicity of   the molecule\")</li> <li>symmetry: PointGroupData = Field(None, description=\"Symmetry data for   this molecule\")<ul> <li>symmetry.eigen_tolerance: float = Field(None, title=\"Interia   Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare   eigen values of the inertia tensor.\")</li> <li>symmetry.linear: bool = Field(None, title=\"Molecule Linearity\",   description=\"Is the molecule linear?\")</li> <li>symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry   Operation Matrix Element Tolerance\" description=\"Tolerance used to   generate the full set of symmetry operations of the point group.\")</li> <li>symmetry.rotation_number: float = Field(None, title=\"Rotational   Symmetry Number\", description=\"Rotational symmetry number for the   molecule\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group   Symbol\", description=\"The point group for the lattice\")</li> <li>symmetry.tolerance: float = Field(None, title=\"Point Group   Analyzer Tolerance\", description=\"Distance tolerance to consider   sites as symmetrically equivalent.\")</li> </ul> </li> </ul> </li> </ul> Source code in <code>quacc/schemas/ase.py</code> <pre><code>def summarize_run(\n    atoms: Atoms,\n    input_atoms: Atoms | None = None,\n    charge_and_multiplicity: tuple[int, int] | None = None,\n    prep_next_run: bool = True,\n    additional_fields: dict | None = None,\n    store: Store | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Get tabulated results from an Atoms object and calculator and store them in\n    a database-friendly format. This is meant to be compatible with all\n    calculator types.\n\n    Parameters\n    ----------\n    atoms\n        ASE Atoms following a calculation. A calculator must be attached.\n    input_atoms\n        Input ASE Atoms object to store.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule\n        metadata.\n    prep_next_run\n        Whether the Atoms object stored in {\"atoms\": atoms} should be prepared\n        for the next run This clears out any attached calculator and moves the\n        final magmoms to the initial magmoms.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. If None,\n        `SETTINGS.PRIMARY_STORE` will be used.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary representation of the task document with the following\n        fields:\n\n        - atoms: Atoms = Field(None, title = \"The Atoms object from the\n          calculation result.\")\n        - atoms_info: dict = Field(None, title = \"The Atoms object info obtained\n          from atoms.info.\")\n        - builder_meta: EmmetMeta = Field(default_factory=EmmetMeta,\n          description=\"Builder metadata.\"):\n            - builder_meta.build_date: str =\n              Field(default_factory=datetime.utcnow, description=\"The build date\n              for this document.\")\n            - builder_meta.database_version: str = Field(None, description=\"The\n              database version for the built data.\")\n            - builder_meta.emmet_version: str = Field(__version__,\n              description=\"The version of emmet this document was built with.\")\n            - builder_meta.pymatgen_version: str = Field(pmg_version,\n              description=\"The version of pymatgen this document was built\n              with.\")\n            - builder_meta.pull_request: int = Field(None, description=\"The pull\n              request number associated with this data build.\")\n        - dir_name: str = Field(None, description=\"Directory where the output is\n          parsed\")\n        - input_structure: Molecule | Structure = Field(None, title = \"The\n          Pymatgen Structure or Molecule object from\n         the input Atoms object if input_atoms is not None.\")\n        - nid: str = Field(None, title = \"The node ID representing the machine\n          where the calculation was run.\")\n        - parameters: dict = Field(None, title = \"the parameters used to run the\n          calculation.\")\n        - results: dict = Field(None, title = \"The results from the\n          calculation.\")\n\n        For periodic structures, the task document also has the following\n        fields: - chemsys: str = Field(None, title=\"Chemical System\",\n        description=\"dash-delimited string of elements in the material.\") -\n        composition: Composition = Field(None, description=\"Full composition for\n        the material.\") - composition_reduced: Composition = Field(None,\n        title=\"Reduced Composition\", description=\"Simplified\n         representation of the composition.\")\n        - density: float = Field(None, title=\"Density\", description=\"Density in\n          grams per cm^3.\")\n        - density_atomic: float = Field(None, title=\"Packing Density\",\n          description=\"The atomic packing density in\n         atoms per cm^3.\")\n        - elements: List[Element] = Field(None, description=\"List of elements in\n          the material.\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\",\n          description=\"Anonymized representation\n         of the formula.\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\",\n          description=\"Cleaned representation of the\n         formula.\")\n        - nelements: int = Field(None, description=\"Number of elements.\")\n        - nsites: int = Field(None, description=\"Total number of sites in the\n          structure.\")\n        - structure: Structure = Field(None, title = \"The Pymatgen Structure\n          object from the Atoms object, if\n         periodic and store_pmg is True.\")\n        - symmetry: SymmetryData = Field(None, description=\"Symmetry data for\n          this material.\")\n            - symmetry.crystal_system: CrystalSystem = Field(None,\n              title=\"Crystal System\", description=\"The crystal system for this\n              lattice.\")\n            - symmetry.number: int = Field(None, title=\"Space Group Number\",\n              description=\"The spacegroup number for the lattice.\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group\n              Symbol\", description=\"The point group for the lattice.\")\n            - symmetry.symbol: str = Field(None, title=\"Space Group Symbol\",\n              description=\"The spacegroup symbol for the lattice.\")\n            - symmetry.symprec: float = Field(None, title=\"Symmetry Finding\n              Precision\", description=\"The precision given to spglib to\n              determine the symmetry of this lattice.\")\n        - volume: float = Field(None, title=\"Volume\", description=\"Total volume\n          for this structure in Angstroms^3.\")\n\n        For molecules that lack periodicity, the task document also has the\n        following fields:\n\n        - charge: int = Field(None, description=\"Charge of the molecule\")\n        - chemsys: str = Field(None, title=\"Chemical System\",\n          description=\"dash-delimited string of elements in the\n         molecule\")\n        - composition: Composition = Field(None, description=\"Full composition\n          for the molecule\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced\n          Composition\", description=\"Simplified\n         representation of the composition\")\n        - elements: List[Element] = Field(None, description=\"List of elements in\n          the molecule\")\n        - formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\",\n          description=\"Alphabetical molecular\n         formula\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\",\n          description=\"Anonymized representation of\n         the formula\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\",\n          description=\"Cleaned representation of the\n         formula.\")\n        - molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object\n          from the Atoms object, if not\n         periodic and store_pmg is True.\")\n        - natoms: int = Field(None, description=\"Total number of atoms in the\n          molecule\")\n        - nelectrons: int = Field(None, title=\"Number of electrons\",\n          description=\"The total number of electrons\n         for the molecule\")\n        - nelements: int = Field(None, title=\"Number of Elements\")\n        - spin_multiplicity: int = Field(None, description=\"Spin multiplicity of\n          the molecule\")\n        - symmetry: PointGroupData = Field(None, description=\"Symmetry data for\n          this molecule\")\n            - symmetry.eigen_tolerance: float = Field(None, title=\"Interia\n              Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare\n              eigen values of the inertia tensor.\")\n            - symmetry.linear: bool = Field(None, title=\"Molecule Linearity\",\n              description=\"Is the molecule linear?\")\n            - symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry\n              Operation Matrix Element Tolerance\" description=\"Tolerance used to\n              generate the full set of symmetry operations of the point group.\")\n            - symmetry.rotation_number: float = Field(None, title=\"Rotational\n              Symmetry Number\", description=\"Rotational symmetry number for the\n              molecule\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group\n              Symbol\", description=\"The point group for the lattice\")\n            - symmetry.tolerance: float = Field(None, title=\"Point Group\n              Analyzer Tolerance\", description=\"Distance tolerance to consider\n              sites as symmetrically equivalent.\")\n    \"\"\"\n    # Make sure there is a calculator with results\n    if not atoms.calc:\n        msg = \"ASE Atoms object has no attached calculator.\"\n        raise ValueError(msg)\n    if not atoms.calc.results:\n        msg = \"ASE Atoms object's calculator has no results.\"\n        raise ValueError(msg)\n    store = SETTINGS.PRIMARY_STORE if store is None else store\n\n    additional_fields = additional_fields or {}\n\n    # Fetch all tabulated results from the attached calculator\n    results = {\"results\": atoms.calc.results}\n\n    # Get the calculator inputs\n    uri = get_uri(Path.cwd())\n    inputs = {\n        \"parameters\": atoms.calc.parameters,\n        \"nid\": uri.split(\":\")[0],\n        \"dir_name\": \":\".join(uri.split(\":\")[1:]),\n    }\n    if input_atoms:\n        input_atoms_db = atoms_to_metadata(\n            input_atoms, charge_and_multiplicity=charge_and_multiplicity\n        )\n        inputs[\"input_atoms\"] = input_atoms_db\n\n    # Prepares the Atoms object for the next run by moving the final magmoms to\n    # initial, clearing the calculator state, and assigning the resulting Atoms\n    # object a unique ID.\n    if prep_next_run:\n        atoms = prep_next_run_(atoms)\n\n    # Get tabulated properties of the structure itself\n    atoms_db = atoms_to_metadata(atoms, charge_and_multiplicity=charge_and_multiplicity)\n\n    # Create a dictionary of the inputs/outputs\n    task_doc = sort_dict(atoms_db | inputs | results | additional_fields)\n\n    if store:\n        results_to_db(store, task_doc)\n\n    return task_doc\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.summarize_vib_and_thermo","title":"summarize_vib_and_thermo","text":"<pre><code>summarize_vib_and_thermo(\n    vib,\n    igt,\n    temperature=298.15,\n    pressure=1.0,\n    charge_and_multiplicity=None,\n    additional_fields=None,\n    store=None,\n)\n</code></pre> <p>Get tabulated results from an ASE Vibrations run and ASE IdealGasThermo object and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> <code>vib</code>             (<code>Vibrations</code>)         \u2013          <p>ASE Vibrations object.</p> </li> <li> <code>igt</code>             (<code>IdealGasThermo</code>)         \u2013          <p>ASE IdealGasThermo object.</p> </li> <li> <code>temperature</code>             (<code>float</code>, default:                 <code>298.15</code> )         \u2013          <p>Temperature in Kelvins.</p> </li> <li> <code>pressure</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Pressure in bar.</p> </li> <li> <code>charge_and_multiplicity</code>             (<code>tuple[int, int] | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> <code>additional_fields</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the task document.</p> </li> <li> <code>store</code>             (<code>Store | None</code>, default:                 <code>None</code> )         \u2013          <p>Maggma Store object to store the results in. If None, <code>SETTINGS.PRIMARY_STORE</code> will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VibThermoSchema</code>         \u2013          <p>A dictionary that merges the <code>VibSchema</code> and <code>ThermoSchema</code>.</p> </li> </ul> Source code in <code>quacc/schemas/ase.py</code> <pre><code>def summarize_vib_and_thermo(\n    vib: Vibrations,\n    igt: IdealGasThermo,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    charge_and_multiplicity: tuple[int, int] | None = None,\n    additional_fields: dict | None = None,\n    store: Store | None = None,\n) -&gt; VibThermoSchema:\n    \"\"\"\n    Get tabulated results from an ASE Vibrations run and ASE IdealGasThermo object\n    and store them in a database-friendly format.\n\n    Parameters\n    ----------\n    vib\n        ASE Vibrations object.\n    igt\n        ASE IdealGasThermo object.\n    temperature\n        Temperature in Kelvins.\n    pressure\n        Pressure in bar.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule\n        metadata.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. If None,\n        `SETTINGS.PRIMARY_STORE` will be used.\n\n    Returns\n    -------\n    VibThermoSchema\n        A dictionary that merges the `VibSchema` and `ThermoSchema`.\n    \"\"\"\n    vib_task_doc = summarize_vib_run(\n        vib,\n        charge_and_multiplicity=charge_and_multiplicity,\n        additional_fields=additional_fields,\n        store=store,\n    )\n    thermo_task_doc = summarize_ideal_gas_thermo(\n        igt,\n        temperature=temperature,\n        pressure=pressure,\n        charge_and_multiplicity=charge_and_multiplicity,\n        additional_fields=additional_fields,\n        store=store,\n    )\n    return merge_dicts(vib_task_doc, thermo_task_doc)\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.summarize_vib_run","title":"summarize_vib_run","text":"<pre><code>summarize_vib_run(\n    vib,\n    charge_and_multiplicity=None,\n    additional_fields=None,\n    store=None,\n)\n</code></pre> <p>Get tabulated results from an ASE Vibrations object and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> <code>vib</code>             (<code>Vibrations</code>)         \u2013          <p>ASE Vibrations object.</p> </li> <li> <code>charge_and_multiplicity</code>             (<code>tuple[int, int] | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> <code>additional_fields</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the task document.</p> </li> <li> <code>store</code>             (<code>Store | None</code>, default:                 <code>None</code> )         \u2013          <p>Maggma Store object to store the results in. If None, <code>SETTINGS.PRIMARY_STORE</code> will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VibSchema</code>         \u2013          <p>Dictionary representation of the task document with the following fields:</p> <ul> <li>atoms: Atoms = Field(None, title = \"The Atoms object from the   calculation result.\")</li> <li>atoms_info: dict = Field(None, title = \"The Atoms object info obtained   from atoms.info.\")</li> <li>builder_meta: EmmetMeta = Field(default_factory=EmmetMeta,   description=\"Builder metadata.\"):<ul> <li>builder_meta.build_date: str =   Field(default_factory=datetime.utcnow, description=\"The build date   for this document.\")</li> <li>builder_meta.database_version: str = Field(None, description=\"The   database version for the built data.\")</li> <li>builder_meta.emmet_version: str = Field(version,   description=\"The version of emmet this document was built with.\")</li> <li>builder_meta.pymatgen_version: str = Field(pmg_version,   description=\"The version of pymatgen this document was built   with.\")</li> <li>builder_meta.pull_request: int = Field(None, description=\"The pull   request number associated with this data build.\")</li> </ul> </li> <li>dir_name: str = Field(None, description=\"Directory where the output is   parsed\")</li> <li>nid: str = Field(None, title = \"The node ID representing the machine   where the calculation was run.\")</li> <li>parameters: dict = Field(None, title = \"the parameters used to run the   calculation.\")</li> <li>vib_parameters: dict = Field(None, title = \"the parameters used to run   the vibrations.\")<ul> <li>vib_parameters.delta: float = the Vibrations delta value</li> <li>vib_parameters.direction: str = the Vibrations direction value</li> <li>vib_parameters.method: str = the Vibrations method value</li> <li>vib_parameters.ndof: int = the Vibrations ndof value</li> <li>vib_parameters.nfree: int = the Vibrations nfree value</li> </ul> </li> <li>results: dict = Field(None, title = \"The results from the   calculation.\")<ul> <li>results.imag_vib_freqs: List[float] = Imaginary vibrational   frequencies in cm^-1</li> <li>results.n_imag: int = Number of imaginary vibrational frequencies</li> <li>results.vib_energies: List[float] = Vibrational energies in eV.   3N-5 or 3N-6 for molecules; 3N for solids.</li> <li>results.vib_freqs: List[float] = Vibrational frequencies in cm^-1.   3N-5 or 3N-6 for molecules; 3N for solids.</li> <li>results.vib_energies_raw: List[float] = Vibrational energies in eV   of length 3N.</li> <li>results.vib_freqs_raw: List[float] = Vibrational frequencies in   cm^-1 of length 3N.</li> </ul> </li> </ul> <p>For periodic structures, the task document also has the following fields:</p> <ul> <li>chemsys: str = Field(None, title=\"Chemical System\",   description=\"dash-delimited string of elements in the material.\")</li> <li>composition: Composition = Field(None, description=\"Full composition   for the material.\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced   Composition\", description=\"Simplified  representation of the composition.\")</li> <li>density: float = Field(None, title=\"Density\", description=\"Density in   grams per cm^3.\")</li> <li>density_atomic: float = Field(None, title=\"Packing Density\",   description=\"The atomic packing density in atoms  per cm^3.\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in   the material.\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\",   description=\"Anonymized representation of the  formula.\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\",   description=\"Cleaned representation of the  formula.\")</li> <li>nelements: int = Field(None, description=\"Number of elements.\")</li> <li>nsites: int = Field(None, description=\"Total number of sites in the   structure.\")</li> <li>structure: Structure = Field(None, title = \"The Pymatgen Structure   object from the Atoms object, if periodic  and store_pmg is True.\")</li> <li>symmetry: SymmetryData = Field(None, description=\"Symmetry data for   this material.\")<ul> <li>symmetry.crystal_system: CrystalSystem = Field(None,   title=\"Crystal System\", description=\"The crystal system for this   lattice.\")</li> <li>symmetry.number: int = Field(None, title=\"Space Group Number\",   description=\"The spacegroup number for the lattice.\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group   Symbol\", description=\"The point group for the lattice.\")</li> <li>symmetry.symbol: str = Field(None, title=\"Space Group Symbol\",   description=\"The spacegroup symbol for the lattice.\")</li> <li>symmetry.symprec: float = Field(None, title=\"Symmetry Finding   Precision\", description=\"The precision given to spglib to   determine the symmetry of this lattice.\")</li> </ul> </li> <li>volume: float = Field(None, title=\"Volume\", description=\"Total volume   for this structure in Angstroms^3.\")</li> </ul> <p>For molecules that lack periodicity, the task document also has the following fields:</p> <ul> <li>charge: int = Field(None, description=\"Charge of the molecule\")</li> <li>chemsys: str = Field(None, title=\"Chemical System\",   description=\"dash-delimited string of elements in the  molecule\")</li> <li>composition: Composition = Field(None, description=\"Full composition   for the molecule\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced   Composition\", description=\"Simplified  representation of the composition\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in   the molecule\")</li> <li>formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\",   description=\"Alphabetical molecular  formula\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\",   description=\"Anonymized representation of  the formula\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\",   description=\"Cleaned representation of the  formula.\")</li> <li>natoms: int = Field(None, description=\"Total number of atoms in the   molecule\")</li> <li>molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object   from the Atoms object, if not  periodic and store_pmg is True.\")</li> <li>nelectrons: int = Field(None, title=\"Number of electrons\",   description=\"The total number of electrons for  the molecule\")</li> <li>nelements: int = Field(None, title=\"Number of Elements\")</li> <li>spin_multiplicity: int = Field(None, description=\"Spin multiplicity of   the molecule\")</li> <li>symmetry: PointGroupData = Field(None, description=\"Symmetry data for   this molecule\")<ul> <li>symmetry.eigen_tolerance: float = Field(None, title=\"Interia   Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare   eigen values of the inertia tensor.\")</li> <li>symmetry.linear: bool = Field(None, title=\"Molecule Linearity\",   description=\"Is the molecule linear?\")</li> <li>symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry   Operation Matrix Element Tolerance\" description=\"Tolerance used to   generate the full set of symmetry operations of the point group.\")</li> <li>symmetry.rotation_number: float = Field(None, title=\"Rotational   Symmetry Number\", description=\"Rotational symmetry number for the   molecule\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group   Symbol\", description=\"The point group for the lattice\")</li> <li>symmetry.tolerance: float = Field(None, title=\"Point Group   Analyzer Tolerance\", description=\"Distance tolerance to consider   sites as symmetrically equivalent.\")</li> </ul> </li> </ul> </li> </ul> Source code in <code>quacc/schemas/ase.py</code> <pre><code>def summarize_vib_run(\n    vib: Vibrations,\n    charge_and_multiplicity: tuple[int, int] | None = None,\n    additional_fields: dict | None = None,\n    store: Store | None = None,\n) -&gt; VibSchema:\n    \"\"\"\n    Get tabulated results from an ASE Vibrations object and store them in a\n    database-friendly format.\n\n    Parameters\n    ----------\n    vib\n        ASE Vibrations object.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule\n        metadata.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. If None,\n        `SETTINGS.PRIMARY_STORE` will be used.\n\n    Returns\n    -------\n    VibSchema\n        Dictionary representation of the task document with the following\n        fields:\n\n        - atoms: Atoms = Field(None, title = \"The Atoms object from the\n          calculation result.\")\n        - atoms_info: dict = Field(None, title = \"The Atoms object info obtained\n          from atoms.info.\")\n        - builder_meta: EmmetMeta = Field(default_factory=EmmetMeta,\n          description=\"Builder metadata.\"):\n            - builder_meta.build_date: str =\n              Field(default_factory=datetime.utcnow, description=\"The build date\n              for this document.\")\n            - builder_meta.database_version: str = Field(None, description=\"The\n              database version for the built data.\")\n            - builder_meta.emmet_version: str = Field(__version__,\n              description=\"The version of emmet this document was built with.\")\n            - builder_meta.pymatgen_version: str = Field(pmg_version,\n              description=\"The version of pymatgen this document was built\n              with.\")\n            - builder_meta.pull_request: int = Field(None, description=\"The pull\n              request number associated with this data build.\")\n        - dir_name: str = Field(None, description=\"Directory where the output is\n          parsed\")\n        - nid: str = Field(None, title = \"The node ID representing the machine\n          where the calculation was run.\")\n        - parameters: dict = Field(None, title = \"the parameters used to run the\n          calculation.\")\n        - vib_parameters: dict = Field(None, title = \"the parameters used to run\n          the vibrations.\")\n            - vib_parameters.delta: float = the Vibrations delta value\n            - vib_parameters.direction: str = the Vibrations direction value\n            - vib_parameters.method: str = the Vibrations method value\n            - vib_parameters.ndof: int = the Vibrations ndof value\n            - vib_parameters.nfree: int = the Vibrations nfree value\n        - results: dict = Field(None, title = \"The results from the\n          calculation.\")\n            - results.imag_vib_freqs: List[float] = Imaginary vibrational\n              frequencies in cm^-1\n            - results.n_imag: int = Number of imaginary vibrational frequencies\n            - results.vib_energies: List[float] = Vibrational energies in eV.\n              3N-5 or 3N-6 for molecules; 3N for solids.\n            - results.vib_freqs: List[float] = Vibrational frequencies in cm^-1.\n              3N-5 or 3N-6 for molecules; 3N for solids.\n            - results.vib_energies_raw: List[float] = Vibrational energies in eV\n              of length 3N.\n            - results.vib_freqs_raw: List[float] = Vibrational frequencies in\n              cm^-1 of length 3N.\n\n        For periodic structures, the task document also has the following\n        fields:\n\n        - chemsys: str = Field(None, title=\"Chemical System\",\n          description=\"dash-delimited string of elements in the material.\")\n        - composition: Composition = Field(None, description=\"Full composition\n          for the material.\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced\n          Composition\", description=\"Simplified\n         representation of the composition.\")\n        - density: float = Field(None, title=\"Density\", description=\"Density in\n          grams per cm^3.\")\n        - density_atomic: float = Field(None, title=\"Packing Density\",\n          description=\"The atomic packing density in atoms\n         per cm^3.\")\n        - elements: List[Element] = Field(None, description=\"List of elements in\n          the material.\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\",\n          description=\"Anonymized representation of the\n         formula.\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\",\n          description=\"Cleaned representation of the\n         formula.\")\n        - nelements: int = Field(None, description=\"Number of elements.\")\n        - nsites: int = Field(None, description=\"Total number of sites in the\n          structure.\")\n        - structure: Structure = Field(None, title = \"The Pymatgen Structure\n          object from the Atoms object, if periodic\n         and store_pmg is True.\")\n        - symmetry: SymmetryData = Field(None, description=\"Symmetry data for\n          this material.\")\n            - symmetry.crystal_system: CrystalSystem = Field(None,\n              title=\"Crystal System\", description=\"The crystal system for this\n              lattice.\")\n            - symmetry.number: int = Field(None, title=\"Space Group Number\",\n              description=\"The spacegroup number for the lattice.\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group\n              Symbol\", description=\"The point group for the lattice.\")\n            - symmetry.symbol: str = Field(None, title=\"Space Group Symbol\",\n              description=\"The spacegroup symbol for the lattice.\")\n            - symmetry.symprec: float = Field(None, title=\"Symmetry Finding\n              Precision\", description=\"The precision given to spglib to\n              determine the symmetry of this lattice.\")\n        - volume: float = Field(None, title=\"Volume\", description=\"Total volume\n          for this structure in Angstroms^3.\")\n\n        For molecules that lack periodicity, the task document also has the\n        following fields:\n\n        - charge: int = Field(None, description=\"Charge of the molecule\")\n        - chemsys: str = Field(None, title=\"Chemical System\",\n          description=\"dash-delimited string of elements in the\n         molecule\")\n        - composition: Composition = Field(None, description=\"Full composition\n          for the molecule\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced\n          Composition\", description=\"Simplified\n         representation of the composition\")\n        - elements: List[Element] = Field(None, description=\"List of elements in\n          the molecule\")\n        - formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\",\n          description=\"Alphabetical molecular\n         formula\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\",\n          description=\"Anonymized representation of\n         the formula\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\",\n          description=\"Cleaned representation of the\n         formula.\")\n        - natoms: int = Field(None, description=\"Total number of atoms in the\n          molecule\")\n        - molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object\n          from the Atoms object, if not\n         periodic and store_pmg is True.\")\n        - nelectrons: int = Field(None, title=\"Number of electrons\",\n          description=\"The total number of electrons for\n         the molecule\")\n        - nelements: int = Field(None, title=\"Number of Elements\")\n        - spin_multiplicity: int = Field(None, description=\"Spin multiplicity of\n          the molecule\")\n        - symmetry: PointGroupData = Field(None, description=\"Symmetry data for\n          this molecule\")\n            - symmetry.eigen_tolerance: float = Field(None, title=\"Interia\n              Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare\n              eigen values of the inertia tensor.\")\n            - symmetry.linear: bool = Field(None, title=\"Molecule Linearity\",\n              description=\"Is the molecule linear?\")\n            - symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry\n              Operation Matrix Element Tolerance\" description=\"Tolerance used to\n              generate the full set of symmetry operations of the point group.\")\n            - symmetry.rotation_number: float = Field(None, title=\"Rotational\n              Symmetry Number\", description=\"Rotational symmetry number for the\n              molecule\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group\n              Symbol\", description=\"The point group for the lattice\")\n            - symmetry.tolerance: float = Field(None, title=\"Point Group\n              Analyzer Tolerance\", description=\"Distance tolerance to consider\n              sites as symmetrically equivalent.\")\n    \"\"\"\n    additional_fields = additional_fields or {}\n    store = SETTINGS.PRIMARY_STORE if store is None else store\n\n    vib_freqs_raw = vib.get_frequencies().tolist()\n    vib_energies_raw = vib.get_energies().tolist()\n\n    atoms = vib._atoms if isinstance(vib, VibrationsData) else vib.atoms\n\n    # Convert imaginary modes to negative values for DB storage\n    for i, f in enumerate(vib_freqs_raw):\n        if np.imag(f) &gt; 0:\n            vib_freqs_raw[i] = -np.abs(f)\n            vib_energies_raw[i] = -np.abs(vib_energies_raw[i])\n        else:\n            vib_freqs_raw[i] = np.abs(f)\n            vib_energies_raw[i] = np.abs(vib_energies_raw[i])\n\n    uri = get_uri(Path.cwd())\n    inputs = {\n        \"parameters\": None\n        if isinstance(vib, VibrationsData)\n        else atoms.calc.parameters,\n        \"parameters_vib\": None\n        if isinstance(vib, VibrationsData)\n        else {\n            \"delta\": vib.delta,\n            \"direction\": vib.direction,\n            \"method\": vib.method,\n            \"ndof\": vib.ndof,\n            \"nfree\": vib.nfree,\n        },\n        \"nid\": uri.split(\":\")[0],\n        \"dir_name\": \":\".join(uri.split(\":\")[1:]),\n    }\n\n    atoms_db = atoms_to_metadata(atoms, charge_and_multiplicity=charge_and_multiplicity)\n\n    # Get the true vibrational modes\n    natoms = len(atoms)\n    if natoms == 1:\n        vib_freqs = []\n        vib_energies = []\n    elif atoms.pbc.any():\n        vib_freqs = vib_freqs_raw\n        vib_energies = vib_energies_raw\n    else:\n        # Sort by absolute value\n        vib_freqs_raw_sorted = vib_freqs_raw.copy()\n        vib_energies_raw_sorted = vib_energies_raw.copy()\n        vib_freqs_raw_sorted.sort(key=np.abs)\n        vib_energies_raw_sorted.sort(key=np.abs)\n\n        # Cut the 3N-5 or 3N-6 modes based on their absolute value\n        n_modes = 3 * natoms - 5 if atoms_db[\"symmetry\"][\"linear\"] else 3 * natoms - 6\n        vib_freqs = vib_freqs_raw_sorted[-n_modes:]\n        vib_energies = vib_energies_raw_sorted[-n_modes:]\n\n    imag_vib_freqs = [f for f in vib_freqs if f &lt; 0]\n\n    results = {\n        \"results\": {\n            \"imag_vib_freqs\": imag_vib_freqs,\n            \"n_imag\": len(imag_vib_freqs),\n            \"vib_energies\": vib_energies,\n            \"vib_freqs\": vib_freqs,\n            \"vib_energies_raw\": vib_energies_raw,\n            \"vib_freqs_raw\": vib_freqs_raw,\n        }\n    }\n\n    task_doc = sort_dict(atoms_db | inputs | results | additional_fields)\n\n    if store:\n        results_to_db(store, task_doc)\n\n    return task_doc\n</code></pre>"},{"location":"reference/quacc/schemas/atoms.html","title":"atoms","text":"<p>Schemas for storing metadata about Atoms objects</p>"},{"location":"reference/quacc/schemas/atoms.html#quacc.schemas.atoms.atoms_to_metadata","title":"atoms_to_metadata","text":"<pre><code>atoms_to_metadata(\n    atoms,\n    charge_and_multiplicity=None,\n    get_metadata=True,\n    strip_info=False,\n    store_pmg=True,\n    additional_fields=None,\n)\n</code></pre> <p>Convert an ASE Atoms object to a dict suitable for storage in MongoDB.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>ASE Atoms object to store in {\"atoms\": atoms}</p> </li> <li> <code>charge_and_multiplicity</code>             (<code>tuple[int, int] | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> <code>get_metadata</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to store atoms metadata in the returned dict.</p> </li> <li> <code>strip_info</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to strip the data from atoms.info in the returned {\"atoms\": atoms}. Note that this data will be stored in {\"atoms_info\": atoms.info} regardless</p> </li> <li> <code>store_pmg</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to store the Pymatgen Structure/Molecule object in {\"structure\": Structure} or {\"molecule\": Molecule}, respectively.</p> </li> <li> <code>additional_fields</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the document.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary representation of the atoms object with the following fields:</p> <ul> <li>atoms: Atoms = Field(None, title = \"The Atoms object from the   calculation result.\")</li> <li>atoms_info: dict = Field(None, title = \"The Atoms object info obtained   from atoms.info.\")</li> <li>builder_meta: EmmetMeta = Field(default_factory=EmmetMeta,   description=\"Builder metadata.\"):<ul> <li>builder_meta.build_date: str =   Field(default_factory=datetime.utcnow, description=\"The build date   for this document.\")</li> <li>builder_meta.database_version: str = Field(None, description=\"The   database version for the built data.\")</li> <li>builder_meta.emmet_version: str = Field(version,   description=\"The version of emmet this document was built with.\")</li> <li>builder_meta.pymatgen_version: str = Field(pmg_version,   description=\"The version of pymatgen this document was built   with.\")</li> <li>builder_meta.pull_request: int = Field(None, description=\"The pull   request number associated with this data build.\")</li> </ul> </li> </ul> <p>For periodic structures, the task document also has the following fields:</p> <ul> <li>chemsys: str = Field(None, title=\"Chemical System\",   description=\"dash-delimited string of elements in the material.\")</li> <li>composition: Composition = Field(None, description=\"Full composition   for the material.\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced   Composition\", description=\"Simplified representation of the   composition.\")</li> <li>density: float = Field(None, title=\"Density\", description=\"Density in   grams per cm^3.\")</li> <li>density_atomic: float = Field(None, title=\"Packing Density\",   description=\"The atomic packing density in atoms per cm^3.\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in   the material.\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\",   description=\"Anonymized representation of the formula.\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\",   description=\"Cleaned representation of the formula.\")</li> <li>nelements: int = Field(None, description=\"Number of elements.\")</li> <li>nsites: int = Field(None, description=\"Total number of sites in the   structure.\")</li> <li>structure: Structure = Field(None, title = \"The Pymatgen Structure   object from the Atoms object, if periodic and store_pmg is True.\")</li> <li>symmetry: SymmetryData = Field(None, description=\"Symmetry data for   this material.\")<ul> <li>symmetry.crystal_system: CrystalSystem = Field(None,   title=\"Crystal System\", description=\"The crystal system for this   lattice.\")</li> <li>symmetry.number: int = Field(None, title=\"Space Group Number\",   description=\"The spacegroup number for the lattice.\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group   Symbol\", description=\"The point group for the lattice.\")</li> <li>symmetry.symbol: str = Field(None, title=\"Space Group Symbol\",   description=\"The spacegroup symbol for the lattice.\")</li> <li>symmetry.symprec: float = Field(None, title=\"Symmetry Finding   Precision\", description=\"The precision given to spglib to   determine the symmetry of this lattice.\")</li> </ul> </li> <li>volume: float = Field(None, title=\"Volume\", description=\"Total volume   for this structure in Angstroms^3.\")</li> </ul> <p>For molecules that lack periodicity, the task document also has the following fields:</p> <ul> <li>charge: int = Field(None, description=\"Charge of the molecule\")</li> <li>chemsys: str = Field(None, title=\"Chemical System\",   description=\"dash-delimited string of elements in the molecule\")</li> <li>composition: Composition = Field(None, description=\"Full composition   for the molecule\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced   Composition\", description=\"Simplified representation of the   composition\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in   the molecule\")</li> <li>formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\",   description=\"Alphabetical molecular formula\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\",   description=\"Anonymized representation of the formula\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\",   description=\"Cleaned representation of the formula.\")</li> <li>molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object   from the Atoms object, if not periodic and store_pmg is True.\")</li> <li>natoms: int = Field(None, description=\"Total number of atoms in the   molecule\")</li> <li>nelectrons: int = Field(None, title=\"Number of electrons\",   description=\"The total number of electrons for the molecule\")</li> <li>nelements: int = Field(None, title=\"Number of Elements\")</li> <li>spin_multiplicity: int = Field(None, description=\"Spin multiplicity of   the molecule\")</li> <li>symmetry: PointGroupData = Field(None, description=\"Symmetry data for   this molecule\")<ul> <li>symmetry.eigen_tolerance: float = Field(None, title=\"Interia   Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare   eigen values of the inertia tensor.\")</li> <li>symmetry.linear: bool = Field(None, title=\"Molecule Linearity\",   description=\"Is the molecule linear?\")</li> <li>symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry   Operation Matrix Element Tolerance\" description=\"Tolerance used to   generate the full set of symmetry operations of the point group.\")</li> <li>symmetry.rotation_number: float = Field(None, title=\"Rotational   Symmetry Number\", description=\"Rotational symmetry number for the   molecule\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group   Symbol\", description=\"The point group for the lattice\")</li> <li>symmetry.tolerance: float = Field(None, title=\"Point Group   Analyzer Tolerance\", description=\"Distance tolerance to consider   sites as symmetrically equivalent.\")</li> </ul> </li> </ul> </li> </ul> Source code in <code>quacc/schemas/atoms.py</code> <pre><code>def atoms_to_metadata(\n    atoms: Atoms,\n    charge_and_multiplicity: tuple[int, int] | None = None,\n    get_metadata: bool = True,\n    strip_info: bool = False,\n    store_pmg: bool = True,\n    additional_fields: dict | None = None,\n) -&gt; AtomsSchema:\n    \"\"\"\n    Convert an ASE Atoms object to a dict suitable for storage in MongoDB.\n\n    Parameters\n    ----------\n    atoms\n        ASE Atoms object to store in {\"atoms\": atoms}\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule\n        metadata.\n    get_metadata\n        Whether to store atoms metadata in the returned dict.\n    strip_info\n        Whether to strip the data from atoms.info in the returned {\"atoms\":\n        atoms}. Note that this data will be stored in {\"atoms_info\": atoms.info}\n        regardless\n    store_pmg\n        Whether to store the Pymatgen Structure/Molecule object in {\"structure\":\n        Structure} or {\"molecule\": Molecule}, respectively.\n    additional_fields\n        Additional fields to add to the document.\n\n    Returns\n    -------\n    dict\n        Dictionary representation of the atoms object with the following fields:\n\n        - atoms: Atoms = Field(None, title = \"The Atoms object from the\n          calculation result.\")\n        - atoms_info: dict = Field(None, title = \"The Atoms object info obtained\n          from atoms.info.\")\n        - builder_meta: EmmetMeta = Field(default_factory=EmmetMeta,\n          description=\"Builder metadata.\"):\n            - builder_meta.build_date: str =\n              Field(default_factory=datetime.utcnow, description=\"The build date\n              for this document.\")\n            - builder_meta.database_version: str = Field(None, description=\"The\n              database version for the built data.\")\n            - builder_meta.emmet_version: str = Field(__version__,\n              description=\"The version of emmet this document was built with.\")\n            - builder_meta.pymatgen_version: str = Field(pmg_version,\n              description=\"The version of pymatgen this document was built\n              with.\")\n            - builder_meta.pull_request: int = Field(None, description=\"The pull\n              request number associated with this data build.\")\n\n        For periodic structures, the task document also has the following\n        fields:\n\n        - chemsys: str = Field(None, title=\"Chemical System\",\n          description=\"dash-delimited string of elements in the material.\")\n        - composition: Composition = Field(None, description=\"Full composition\n          for the material.\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced\n          Composition\", description=\"Simplified representation of the\n          composition.\")\n        - density: float = Field(None, title=\"Density\", description=\"Density in\n          grams per cm^3.\")\n        - density_atomic: float = Field(None, title=\"Packing Density\",\n          description=\"The atomic packing density in atoms per cm^3.\")\n        - elements: List[Element] = Field(None, description=\"List of elements in\n          the material.\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\",\n          description=\"Anonymized representation of the formula.\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\",\n          description=\"Cleaned representation of the formula.\")\n        - nelements: int = Field(None, description=\"Number of elements.\")\n        - nsites: int = Field(None, description=\"Total number of sites in the\n          structure.\")\n        - structure: Structure = Field(None, title = \"The Pymatgen Structure\n          object from the Atoms object, if periodic and store_pmg is True.\")\n        - symmetry: SymmetryData = Field(None, description=\"Symmetry data for\n          this material.\")\n            - symmetry.crystal_system: CrystalSystem = Field(None,\n              title=\"Crystal System\", description=\"The crystal system for this\n              lattice.\")\n            - symmetry.number: int = Field(None, title=\"Space Group Number\",\n              description=\"The spacegroup number for the lattice.\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group\n              Symbol\", description=\"The point group for the lattice.\")\n            - symmetry.symbol: str = Field(None, title=\"Space Group Symbol\",\n              description=\"The spacegroup symbol for the lattice.\")\n            - symmetry.symprec: float = Field(None, title=\"Symmetry Finding\n              Precision\", description=\"The precision given to spglib to\n              determine the symmetry of this lattice.\")\n        - volume: float = Field(None, title=\"Volume\", description=\"Total volume\n          for this structure in Angstroms^3.\")\n\n        For molecules that lack periodicity, the task document also has the\n        following fields:\n\n        - charge: int = Field(None, description=\"Charge of the molecule\")\n        - chemsys: str = Field(None, title=\"Chemical System\",\n          description=\"dash-delimited string of elements in the molecule\")\n        - composition: Composition = Field(None, description=\"Full composition\n          for the molecule\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced\n          Composition\", description=\"Simplified representation of the\n          composition\")\n        - elements: List[Element] = Field(None, description=\"List of elements in\n          the molecule\")\n        - formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\",\n          description=\"Alphabetical molecular formula\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\",\n          description=\"Anonymized representation of the formula\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\",\n          description=\"Cleaned representation of the formula.\")\n        - molecule: Molecule = Field(None, title = \"The Pymatgen Molecule object\n          from the Atoms object, if not periodic and store_pmg is True.\")\n        - natoms: int = Field(None, description=\"Total number of atoms in the\n          molecule\")\n        - nelectrons: int = Field(None, title=\"Number of electrons\",\n          description=\"The total number of electrons for the molecule\")\n        - nelements: int = Field(None, title=\"Number of Elements\")\n        - spin_multiplicity: int = Field(None, description=\"Spin multiplicity of\n          the molecule\")\n        - symmetry: PointGroupData = Field(None, description=\"Symmetry data for\n          this molecule\")\n            - symmetry.eigen_tolerance: float = Field(None, title=\"Interia\n              Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare\n              eigen values of the inertia tensor.\")\n            - symmetry.linear: bool = Field(None, title=\"Molecule Linearity\",\n              description=\"Is the molecule linear?\")\n            - symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry\n              Operation Matrix Element Tolerance\" description=\"Tolerance used to\n              generate the full set of symmetry operations of the point group.\")\n            - symmetry.rotation_number: float = Field(None, title=\"Rotational\n              Symmetry Number\", description=\"Rotational symmetry number for the\n              molecule\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group\n              Symbol\", description=\"The point group for the lattice\")\n            - symmetry.tolerance: float = Field(None, title=\"Point Group\n              Analyzer Tolerance\", description=\"Distance tolerance to consider\n              sites as symmetrically equivalent.\")\n    \"\"\"\n\n    additional_fields = additional_fields or {}\n    atoms = copy_atoms(atoms)\n    results = {}\n\n    # Get any charge or multiplicity keys\n    if charge_and_multiplicity:\n        atoms.charge = charge_and_multiplicity[0]\n        atoms.spin_multiplicity = charge_and_multiplicity[1]\n\n    # Strip the dummy atoms, if present\n    del atoms[[atom.index for atom in atoms if atom.symbol == \"X\"]]\n\n    # Get Atoms metadata, if requested. emmet already has built-in tools for\n    # generating pymatgen Structure/Molecule metadata, so we'll just use that.\n    if get_metadata:\n        if atoms.pbc.any():\n            struct = AseAtomsAdaptor().get_structure(atoms)\n            metadata = StructureMetadata().from_structure(struct).dict()\n            if store_pmg:\n                results[\"structure\"] = struct\n        else:\n            mol = AseAtomsAdaptor().get_molecule(atoms, charge_spin_check=False)\n            metadata = MoleculeMetadata().from_molecule(mol).dict()\n            if store_pmg:\n                results[\"molecule\"] = mol\n        metadata[\"builder_meta\"][\"build_date\"] = str(\n            metadata[\"builder_meta\"][\"build_date\"]\n        )\n    else:\n        metadata = {}\n\n    # Copy the info flags as a separate entry in the DB for easy querying\n    results[\"atoms_info\"] = _quacc_sanitize(atoms.info)\n\n    # Strip info if requested\n    if strip_info:\n        atoms_no_info = copy_atoms(atoms)\n        atoms_no_info.info = {}\n        results[\"atoms\"] = atoms_no_info\n    else:\n        results[\"atoms\"] = atoms\n\n    # Combine the metadata and results dictionaries\n    atoms_doc = metadata | results | additional_fields\n\n    return sort_dict(atoms_doc)\n</code></pre>"},{"location":"reference/quacc/schemas/atoms.html#quacc.schemas.atoms.fetch_atoms","title":"fetch_atoms","text":"<pre><code>fetch_atoms(atoms)\n</code></pre> <p>Returns an Atoms object from a typical quacc recipe input, which can either be an <code>Atoms</code> object or a dictionary with an entry <code>{\"atoms\": Atoms}</code>. It may seem a bit silly to do this, but there is a purpose. If you want to write a workflow where the output of one recipe is passed to the input of another recipe, you can always do <code>output[\"atoms\"]</code> to fetch the output Atoms object to pass to the input to the second function. However, this process will often be its own compute step in workflow management tools because they need to resolve the output in order to query it. Depending on the workflow manager, this can be a waste of compute resources, so it's oftentimes better to do this parsing inside the compute task itself, which is why passing in the raw dictionary can be preferred.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms | dict</code>)         \u2013          <p>Atoms object or dictionary with an entry <code>{\"atoms\": Atoms}</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>         \u2013          <p>Atoms object</p> </li> </ul> Source code in <code>quacc/schemas/atoms.py</code> <pre><code>def fetch_atoms(atoms: Atoms | dict) -&gt; Atoms:\n    \"\"\"\n    Returns an Atoms object from a typical quacc recipe input, which can either\n    be an `Atoms` object or a dictionary with an entry `{\"atoms\": Atoms}`. It\n    may seem a bit silly to do this, but there is a purpose. If you want to\n    write a workflow where the output of one recipe is passed to the input of\n    another recipe, you can always do `output[\"atoms\"]` to fetch the output\n    Atoms object to pass to the input to the second function. However, this\n    process will often be its own compute step in workflow management tools\n    because they need to resolve the output in order to query it. Depending on\n    the workflow manager, this can be a waste of compute resources, so it's\n    oftentimes better to do this parsing inside the compute task itself, which\n    is why passing in the raw dictionary can be preferred.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object or dictionary with an entry `{\"atoms\": Atoms}`\n\n    Returns\n    -------\n    Atoms\n        Atoms object\n    \"\"\"\n\n    try:\n        return atoms[\"atoms\"]\n    except Exception:\n        return atoms\n</code></pre>"},{"location":"reference/quacc/schemas/cclib.html","title":"cclib","text":"<p>Schemas for molecular DFT codes parsed by cclib</p>"},{"location":"reference/quacc/schemas/cclib.html#quacc.schemas.cclib.cclib_summarize_run","title":"cclib_summarize_run","text":"<pre><code>cclib_summarize_run(\n    atoms,\n    logfile_extensions,\n    dir_path=None,\n    charge_and_multiplicity=None,\n    pop_analyses=None,\n    check_convergence=None,\n    prep_next_run=True,\n    additional_fields=None,\n    store=None,\n)\n</code></pre> <p>Get tabulated results from a molecular DFT run and store them in a database-friendly format. This is meant to be a general parser built on top of cclib.</p> <p>This document inherits from the following schemas: cclibTaskDocument (see below), emmet.core.structure.MoleculeMetadata, emmet.core.base.EmmetBaseModel.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>ASE Atoms object following a calculation.</p> </li> <li> <code>logfile_extensions</code>             (<code>str | list[str]</code>)         \u2013          <p>Possible extensions of the log file (e.g. \".log\", \".out\", \".txt\", \".chk\"). Note that only a partial match is needed. For instance, <code>.log</code> will match <code>.log.gz</code> and <code>.log.1.gz</code>. If multiple files with this extension are found, the one with the most recent change time will be used. For an exact match only, put in the full file name.</p> </li> <li> <code>dir_path</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The path to the folder containing the calculation outputs. A value of None specifies the current working directory.</p> </li> <li> <code>charge_and_multiplicity</code>             (<code>tuple[int, int] | None</code>, default:                 <code>None</code> )         \u2013          <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> <code>pop_analyses</code>             (<code>list[Literal['cpsa', 'mpa', 'lpa', 'bickelhaupt', 'density', 'mbo', 'bader', 'ddec6', 'hirshfeld']] | None</code>, default:                 <code>None</code> )         \u2013          <p>The name(s) of any cclib post-processing analysis to run. Note that for bader, ddec6, and hirshfeld, a cube file (.cube, .cub) must reside in dir_path. Supports: \"cpsa\", \"mpa\", \"lpa\", \"bickelhaupt\", \"density\", \"mbo\", \"bader\", \"ddec6\", \"hirshfeld\".</p> </li> <li> <code>check_convergence</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to throw an error if geometry optimization convergence is not  reached. Defaults to True in settings.</p> </li> <li> <code>prep_next_run</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the Atoms object stored in {\"atoms\": atoms} should be prepared for the next run. This clears out any attached calculator and moves the final magmoms to the initial magmoms.</p> </li> <li> <code>additional_fields</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the task document.</p> </li> <li> <code>store</code>             (<code>Store | None</code>, default:                 <code>None</code> )         \u2013          <p>Maggma Store object to store the results in. If None, <code>SETTINGS.PRIMARY_STORE</code> will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary representation of the task document with the following fields:</p> <ul> <li>atoms: Atoms = Field(None, title = \"The Atoms object obtained from   atoms.\")</li> <li>atoms_info: dict = Field(None, title = \"The Atoms object info obtained   from atoms.info.\")</li> <li>attributes: Dict = Field(None, description=\"Computed properties and   calculation outputs. See https://cclib.github.io/data_notes.html\")</li> <li>builder_meta: EmmetMeta = Field(default_factory=EmmetMeta,   description=\"Builder metadata.\"):<ul> <li>builder_meta.build_date: str =   Field(default_factory=datetime.utcnow, description=\"The build date   for this document.\")</li> <li>builder_meta.database_version: str = Field(None, description=\"The   database version for the built data.\")</li> <li>builder_meta.emmet_version: str = Field(version,   description=\"The version of emmet this document was built with.\")</li> <li>builder_meta.pymatgen_version: str = Field(pmg_version,   description=\"The version of pymatgen this document was built   with.\")</li> <li>builder_meta.pull_request: int = Field(None, description=\"The pull   request number associated with this data build.\")</li> </ul> </li> <li>charge: int = Field(None, description=\"Charge of the molecule\")</li> <li>chemsys: str = Field(None, title=\"Chemical System\",   description=\"dash-delimited string of elements in the molecule\")</li> <li>composition: Composition = Field(None, description=\"Full composition   for the molecule\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced   Composition\", description=\"Simplified representation of the   composition\")</li> <li>dir_name: str = Field(None, description=\"Directory where the output is   parsed\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in   the molecule\")</li> <li>energy: float = Field(None, description=\"Final total energy\")</li> <li>formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\",   description=\"Alphabetical molecular formula\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\",   description=\"Anonymized representation of the formula\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\",   description=\"Cleaned representation of the formula.\")</li> <li>logfile: str = Field(None, description=\"Path to the log file used in   the post-processing analysis\")</li> <li>metadata: Dict = Field(None, description=\"Calculation metadata,   including input parameters and runtime statistics. See   https://cclib.github.io/data_notes.html#metadata\")</li> <li>molecule: Molecule = Field(None, description=\"Final output molecule   from the task\")</li> <li>natoms: int = Field(None, description=\"Total number of atoms in the   molecule\")</li> <li>nid: str = Field(None, title = \"The node ID representing the machine   where the calculation was run.\")</li> <li>nelectrons: int = Field(None, title=\"Number of electrons\",   description=\"The total number of electrons for the molecule\")</li> <li>nelements: int = Field(None, title=\"Number of Elements\")</li> <li>parameters: dict = Field(None, title = \"The input parameters obtained   from atoms.calc.parameters.\")</li> <li>spin_multiplicity: int = Field(None, description=\"Spin multiplicity of   the molecule\")</li> <li>symmetry: PointGroupData = Field(None, description=\"Symmetry data for   this molecule\")<ul> <li>symmetry.eigen_tolerance: float = Field(None, title=\"Interia   Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare   eigen values of the inertia tensor.\")</li> <li>symmetry.linear: bool = Field(None, title=\"Molecule Linearity\",   description=\"Is the molecule linear?\")</li> <li>symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry   Operation Matrix Element Tolerance\" description=\"Tolerance used to   generate the full set of symmetry operations of the point group.\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group   Symbol\", description=\"The point group for the lattice\")</li> <li>symmetry.rotation_number: float = Field(None, title=\"Rotational   Symmetry Number\", description=\"Rotational symmetry number for the   molecule\")</li> <li>symmetry.tolerance: float = Field(None, title=\"Point Group   Analyzer Tolerance\", description=\"Distance tolerance to consider   sites as symmetrically equivalent.\")</li> </ul> </li> <li>tags: List[str] = Field(None, description=\"Optional tags for this task   document\")</li> <li>task_label: str = Field(None, description=\"A description of the task\")</li> </ul> </li> </ul> Source code in <code>quacc/schemas/cclib.py</code> <pre><code>def cclib_summarize_run(\n    atoms: Atoms,\n    logfile_extensions: str | list[str],\n    dir_path: str | None = None,\n    charge_and_multiplicity: tuple[int, int] | None = None,\n    pop_analyses: list[\n        Literal[\n            \"cpsa\",\n            \"mpa\",\n            \"lpa\",\n            \"bickelhaupt\",\n            \"density\",\n            \"mbo\",\n            \"bader\",\n            \"ddec6\",\n            \"hirshfeld\",\n        ]\n    ]\n    | None = None,\n    check_convergence: bool | None = None,\n    prep_next_run: bool = True,\n    additional_fields: dict | None = None,\n    store: Store | None = None,\n) -&gt; cclibSchema:\n    \"\"\"\n    Get tabulated results from a molecular DFT run and store them in a\n    database-friendly format. This is meant to be a general parser built on top\n    of cclib.\n\n    This document inherits from the following schemas: cclibTaskDocument (see\n    below), emmet.core.structure.MoleculeMetadata,\n    emmet.core.base.EmmetBaseModel.\n\n    Parameters\n    ----------\n    atoms\n        ASE Atoms object following a calculation.\n    logfile_extensions\n        Possible extensions of the log file (e.g. \".log\", \".out\", \".txt\",\n        \".chk\"). Note that only a partial match is needed. For instance, `.log`\n        will match `.log.gz` and `.log.1.gz`. If multiple files with this\n        extension are found, the one with the most recent change time will be\n        used. For an exact match only, put in the full file name.\n    dir_path\n        The path to the folder containing the calculation outputs. A value of\n        None specifies the current working directory.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule\n        metadata.\n    pop_analyses\n        The name(s) of any cclib post-processing analysis to run. Note that for\n        bader, ddec6, and hirshfeld, a cube file (.cube, .cub) must reside in\n        dir_path. Supports: \"cpsa\", \"mpa\", \"lpa\", \"bickelhaupt\", \"density\",\n        \"mbo\", \"bader\", \"ddec6\", \"hirshfeld\".\n    check_convergence\n         Whether to throw an error if geometry optimization convergence is not\n         reached. Defaults to True in settings.\n    prep_next_run\n        Whether the Atoms object stored in {\"atoms\": atoms} should be prepared\n        for the next run. This clears out any attached calculator and moves the\n        final magmoms to the initial magmoms.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. If None,\n        `SETTINGS.PRIMARY_STORE` will be used.\n\n    Returns\n    -------\n    dict\n        Dictionary representation of the task document with the following\n        fields:\n\n        - atoms: Atoms = Field(None, title = \"The Atoms object obtained from\n          atoms.\")\n        - atoms_info: dict = Field(None, title = \"The Atoms object info obtained\n          from atoms.info.\")\n        - attributes: Dict = Field(None, description=\"Computed properties and\n          calculation outputs. See https://cclib.github.io/data_notes.html\")\n        - builder_meta: EmmetMeta = Field(default_factory=EmmetMeta,\n          description=\"Builder metadata.\"):\n            - builder_meta.build_date: str =\n              Field(default_factory=datetime.utcnow, description=\"The build date\n              for this document.\")\n            - builder_meta.database_version: str = Field(None, description=\"The\n              database version for the built data.\")\n            - builder_meta.emmet_version: str = Field(__version__,\n              description=\"The version of emmet this document was built with.\")\n            - builder_meta.pymatgen_version: str = Field(pmg_version,\n              description=\"The version of pymatgen this document was built\n              with.\")\n            - builder_meta.pull_request: int = Field(None, description=\"The pull\n              request number associated with this data build.\")\n        - charge: int = Field(None, description=\"Charge of the molecule\")\n        - chemsys: str = Field(None, title=\"Chemical System\",\n          description=\"dash-delimited string of elements in the molecule\")\n        - composition: Composition = Field(None, description=\"Full composition\n          for the molecule\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced\n          Composition\", description=\"Simplified representation of the\n          composition\")\n        - dir_name: str = Field(None, description=\"Directory where the output is\n          parsed\")\n        - elements: List[Element] = Field(None, description=\"List of elements in\n          the molecule\")\n        - energy: float = Field(None, description=\"Final total energy\")\n        - formula_alphabetical: str = Field(None, title=\"Alphabetical Formula\",\n          description=\"Alphabetical molecular formula\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\",\n          description=\"Anonymized representation of the formula\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\",\n          description=\"Cleaned representation of the formula.\")\n        - logfile: str = Field(None, description=\"Path to the log file used in\n          the post-processing analysis\")\n        - metadata: Dict = Field(None, description=\"Calculation metadata,\n          including input parameters and runtime statistics. See\n          https://cclib.github.io/data_notes.html#metadata\")\n        - molecule: Molecule = Field(None, description=\"Final output molecule\n          from the task\")\n        - natoms: int = Field(None, description=\"Total number of atoms in the\n          molecule\")\n        - nid: str = Field(None, title = \"The node ID representing the machine\n          where the calculation was run.\")\n        - nelectrons: int = Field(None, title=\"Number of electrons\",\n          description=\"The total number of electrons for the molecule\")\n        - nelements: int = Field(None, title=\"Number of Elements\")\n        - parameters: dict = Field(None, title = \"The input parameters obtained\n          from atoms.calc.parameters.\")\n        - spin_multiplicity: int = Field(None, description=\"Spin multiplicity of\n          the molecule\")\n        - symmetry: PointGroupData = Field(None, description=\"Symmetry data for\n          this molecule\")\n            - symmetry.eigen_tolerance: float = Field(None, title=\"Interia\n              Tensor Eigenvalue Tolerance\", description=\"Tolerance to compare\n              eigen values of the inertia tensor.\")\n            - symmetry.linear: bool = Field(None, title=\"Molecule Linearity\",\n              description=\"Is the molecule linear?\")\n            - symmetry.matrix_tolerance: float = Field(None, title=\"Symmetry\n              Operation Matrix Element Tolerance\" description=\"Tolerance used to\n              generate the full set of symmetry operations of the point group.\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group\n              Symbol\", description=\"The point group for the lattice\")\n            - symmetry.rotation_number: float = Field(None, title=\"Rotational\n              Symmetry Number\", description=\"Rotational symmetry number for the\n              molecule\")\n            - symmetry.tolerance: float = Field(None, title=\"Point Group\n              Analyzer Tolerance\", description=\"Distance tolerance to consider\n              sites as symmetrically equivalent.\")\n        - tags: List[str] = Field(None, description=\"Optional tags for this task\n          document\")\n        - task_label: str = Field(None, description=\"A description of the task\")\n    \"\"\"\n\n    additional_fields = additional_fields or {}\n    dir_path = dir_path or Path.cwd()\n    store = SETTINGS.PRIMARY_STORE if store is None else store\n    check_convergence = (\n        SETTINGS.CHECK_CONVERGENCE if check_convergence is None else check_convergence\n    )\n\n    # Make sure there is a calculator with results\n    if not atoms.calc:\n        msg = \"ASE Atoms object has no attached calculator.\"\n        raise ValueError(msg)\n    if not atoms.calc.results:\n        msg = \"ASE Atoms object's calculator has no results.\"\n        raise ValueError(msg)\n\n    # Fortunately, there is already a cclib parser in Atomate2\n    taskdoc = _cclibTaskDocument.from_logfile(\n        dir_path, logfile_extensions, store_trajectory=True, analysis=pop_analyses\n    )\n    uri = taskdoc[\"dir_name\"]\n    taskdoc[\"nid\"] = uri.split(\":\")[0]\n    taskdoc[\"dir_name\"] = \":\".join(uri.split(\":\")[1:])\n    taskdoc[\"builder_meta\"][\"build_date\"] = str(taskdoc[\"builder_meta\"][\"build_date\"])\n    taskdoc[\"logfile\"] = taskdoc[\"logfile\"].split(\":\")[-1]\n    if taskdoc[\"attributes\"].get(\"trajectory\"):\n        taskdoc[\"attributes\"][\"trajectory\"] = [\n            atoms_to_metadata(\n                AseAtomsAdaptor().get_atoms(molecule),\n                charge_and_multiplicity=charge_and_multiplicity,\n            )\n            for molecule in taskdoc[\"attributes\"][\"trajectory\"]\n        ]\n\n    # Check convergence if requested\n    if check_convergence and taskdoc[\"attributes\"].get(\"optdone\") is False:\n        msg = \"Optimization not complete.\"\n        raise ValueError(msg)\n\n    # Get the calculator inputs\n    inputs = {\"parameters\": atoms.calc.parameters}\n\n    # Prepares the Atoms object for the next run by moving the final magmoms to\n    # initial, clearing the calculator state, and assigning the resulting Atoms\n    # object a unique ID.\n    if prep_next_run:\n        atoms = prep_next_run_(atoms)\n\n    # We use get_metadata=False and store_pmg=False because the TaskDocument\n    # already makes the structure metadata for us\n    atoms_db = atoms_to_metadata(atoms, get_metadata=False, store_pmg=False)\n\n    # Create a dictionary of the inputs/outputs\n    summary = sort_dict(atoms_db | inputs | taskdoc | additional_fields)\n\n    # Store the results\n    if store:\n        results_to_db(store, summary)\n\n    return summary\n</code></pre>"},{"location":"reference/quacc/schemas/vasp.html","title":"vasp","text":"<p>Schemas for VASP</p>"},{"location":"reference/quacc/schemas/vasp.html#quacc.schemas.vasp.bader_runner","title":"bader_runner","text":"<pre><code>bader_runner(path=None, scratch_dir=None)\n</code></pre> <p>Runs a Bader partial charge and spin moment analysis using the VASP output files in the given path. This function requires that <code>bader</code> is located in your PATH environment variable. See http://theory.cm.utexas.edu/henkelman/code/bader for the bader code.</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The path where the VASP output files are located. Must include CHGCAR, AECCAR0, AECCAR2, and POTCAR files. These files can be gzip'd or not -- it doesn't matter. If None, the current working directory is used.</p> </li> <li> <code>scratch_dir</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The path where the Bader analysis will be run. Defaults to SETTINGS.SCRATCH_DIR.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary containing the Bader analysis summary:     {         \"min_dist\": List[float], \"atomic_volume\": List[float],         \"vacuum_charge\": float, \"vacuum_volume\": float, \"bader_version\":         float, \"partial_charges\": List[float], \"spin_moments\":         List[float],     }</p> </li> </ul> Source code in <code>quacc/schemas/vasp.py</code> <pre><code>def bader_runner(path: str | None = None, scratch_dir: str | None = None) -&gt; dict:\n    \"\"\"\n    Runs a Bader partial charge and spin moment analysis using the VASP output\n    files in the given path. This function requires that `bader` is located in\n    your PATH environment variable. See\n    http://theory.cm.utexas.edu/henkelman/code/bader for the bader code.\n\n    Parameters\n    ----------\n    path\n        The path where the VASP output files are located. Must include CHGCAR,\n        AECCAR0, AECCAR2, and POTCAR files. These files can be gzip'd or not --\n        it doesn't matter. If None, the current working directory is used.\n    scratch_dir\n        The path where the Bader analysis will be run. Defaults to\n        SETTINGS.SCRATCH_DIR.\n\n    Returns\n    -------\n    dict\n        Dictionary containing the Bader analysis summary:\n            {\n                \"min_dist\": List[float], \"atomic_volume\": List[float],\n                \"vacuum_charge\": float, \"vacuum_volume\": float, \"bader_version\":\n                float, \"partial_charges\": List[float], \"spin_moments\":\n                List[float],\n            }\n    \"\"\"\n    scratch_dir = SETTINGS.SCRATCH_DIR if scratch_dir is None else scratch_dir\n    path = path or Path.cwd()\n\n    # Make sure files are present\n    relevant_files = [\"AECCAR0\", \"AECCAR2\", \"CHGCAR\", \"POTCAR\"]\n    for f in relevant_files:\n        if not Path(path, f).exists() and not Path(path, f\"{f}.gz\").exists():\n            msg = f\"Could not find {f} in {path}.\"\n            raise FileNotFoundError(msg)\n\n    # Run Bader analysis\n    with TemporaryDirectory(dir=scratch_dir) as tmpdir:\n        copy_decompress(relevant_files, tmpdir)\n        bader_stats = bader_analysis_from_path(path)\n\n    # Store the partial charge, which is much more useful than the raw charge\n    # and is more intuitive than the charge transferred. An atom with a positive\n    # partial charge is cationic, whereas an atom with a negative partial charge\n    # is anionic.\n    bader_stats[\"partial_charges\"] = [-c for c in bader_stats[\"charge_transfer\"]]\n\n    # Some cleanup of the returned dictionary\n    if \"magmom\" in bader_stats:\n        bader_stats[\"spin_moments\"] = bader_stats[\"magmom\"]\n    bader_stats.pop(\"charge\", None)\n    bader_stats.pop(\"charge_transfer\", None)\n    bader_stats.pop(\"reference_used\", None)\n    bader_stats.pop(\"magmom\", None)\n\n    return bader_stats\n</code></pre>"},{"location":"reference/quacc/schemas/vasp.html#quacc.schemas.vasp.chargemol_runner","title":"chargemol_runner","text":"<pre><code>chargemol_runner(\n    path=None, atomic_densities_path=None, scratch_dir=None\n)\n</code></pre> <p>Runs a Chargemol (i.e. DDEC6 + CM5) analysis using the VASP output files in the given path. This function requires that the chargemol executable, given by the name <code>Chargemol_09_26_2017_linux_parallel</code>, <code>Chargemol_09_26_2017_linux_serial</code>, or <code>chargemol</code> is in the system PATH environment variable. See https://sourceforge.net/projects/ddec/files for the Chargemol code.</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The path where the VASP output files are located. Must include CHGCAR, AECCAR0, AECCAR2, and POTCAR files. These files can be gzip'd or not -- it doesn't matter. If None, the current working directory is used.</p> </li> <li> <code>atomic_densities_path</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The path where the reference atomic densities are located for Chargemol. If None, we assume that this directory is defined in an environment variable named DDEC6_ATOMIC_DENSITIES_DIR. See the Chargemol documentation for more information.</p> </li> <li> <code>scratch_dir</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The path where the Chargemol analysis will be run.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Dictionary containing the Chargemol analysis summary:     {         \"ddec\": {                     \"partial_charges\": List[float], \"spin_moments\":                     List[float], \"dipoles\": List[float],                     \"bond_order_sums\": List[float], \"bond_order_dict\":                     Dict                 },         \"cm5\": {                     \"partial_charges\": List[float],                 }     }</p> </li> </ul> Source code in <code>quacc/schemas/vasp.py</code> <pre><code>def chargemol_runner(\n    path: str | None = None,\n    atomic_densities_path: str | None = None,\n    scratch_dir: str | None = None,\n) -&gt; dict:\n    \"\"\"\n    Runs a Chargemol (i.e. DDEC6 + CM5) analysis using the VASP output files in\n    the given path. This function requires that the chargemol executable, given\n    by the name `Chargemol_09_26_2017_linux_parallel`,\n    `Chargemol_09_26_2017_linux_serial`, or `chargemol` is in the system PATH\n    environment variable. See https://sourceforge.net/projects/ddec/files for\n    the Chargemol code.\n\n    Parameters\n    ----------\n    path\n        The path where the VASP output files are located. Must include CHGCAR,\n        AECCAR0, AECCAR2, and POTCAR files. These files can be gzip'd or not --\n        it doesn't matter. If None, the current working directory is used.\n    atomic_densities_path\n        The path where the reference atomic densities are located for Chargemol.\n        If None, we assume that this directory is defined in an environment\n        variable named DDEC6_ATOMIC_DENSITIES_DIR. See the Chargemol\n        documentation for more information.\n    scratch_dir\n        The path where the Chargemol analysis will be run.\n\n    Returns\n    -------\n    dict\n        Dictionary containing the Chargemol analysis summary:\n            {\n                \"ddec\": {\n                            \"partial_charges\": List[float], \"spin_moments\":\n                            List[float], \"dipoles\": List[float],\n                            \"bond_order_sums\": List[float], \"bond_order_dict\":\n                            Dict\n                        },\n                \"cm5\": {\n                            \"partial_charges\": List[float],\n                        }\n            }\n    \"\"\"\n    scratch_dir = SETTINGS.SCRATCH_DIR if scratch_dir is None else scratch_dir\n    path = path or Path.cwd()\n\n    # Make sure files are present\n    relevant_files = [\"AECCAR0\", \"AECCAR2\", \"CHGCAR\", \"POTCAR\"]\n    for f in relevant_files:\n        if not Path(path, f).exists() and not Path(path, f\"{f}.gz\").exists():\n            msg = f\"Could not find {f} in {path}.\"\n            raise FileNotFoundError(msg)\n\n    # Check environment variable\n    if atomic_densities_path is None and \"DDEC6_ATOMIC_DENSITIES_DIR\" not in os.environ:\n        msg = \"DDEC6_ATOMIC_DENSITIES_DIR environment variable not defined.\"\n        raise ValueError(msg)\n\n    # Run Chargemol analysis\n    with TemporaryDirectory(dir=scratch_dir) as tmpdir:\n        copy_decompress(relevant_files, tmpdir)\n        chargemol_stats = ChargemolAnalysis(\n            path=path,\n            atomic_densities_path=atomic_densities_path,\n        )\n\n    # Some cleanup of the returned dictionary\n    chargemol_stats.pop(\"rsquared_moments\", None)\n    chargemol_stats.pop(\"rcubed_moments\", None)\n    chargemol_stats.pop(\"rfourth_moments\", None)\n\n    return chargemol_stats\n</code></pre>"},{"location":"reference/quacc/schemas/vasp.html#quacc.schemas.vasp.vasp_summarize_run","title":"vasp_summarize_run","text":"<pre><code>vasp_summarize_run(\n    atoms,\n    dir_path=None,\n    prep_next_run=True,\n    run_bader=None,\n    check_convergence=True,\n    additional_fields=None,\n    store=None,\n)\n</code></pre> <p>Get tabulated results from a VASP run and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>             (<code>Atoms</code>)         \u2013          <p>ASE Atoms object following a calculation.</p> </li> <li> <code>dir_path</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Path to VASP outputs. A value of None specifies the current working directory</p> </li> <li> <code>prep_next_run</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the Atoms object stored in {\"atoms\": atoms} should be prepared for the next run. This clears out any attached calculator and moves the final magmoms to the initial magmoms.</p> </li> <li> <code>run_bader</code>             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether a Bader analysis should be performed. Will not run if bader executable is not in PATH even if bader is set to True. Defaults to VASP_BADER in settings.</p> </li> <li> <code>check_convergence</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to throw an error if convergence is not reached.</p> </li> <li> <code>additional_fields</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional fields to add to the task document.</p> </li> <li> <code>store</code>             (<code>Store | None</code>, default:                 <code>None</code> )         \u2013          <p>Maggma Store object to store the results in. If None, <code>SETTINGS.PRIMARY_STORE</code> will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>         \u2013          <p>Dictionary representation of the task document with the following fields:</p> <ul> <li>analysis: AnalysisDoc = Field(None, title=\"Calculation Analysis\",   description=\"Some analysis of calculation data after collection.\")<ul> <li>analysis.delta_volume: float = Field(None, title=\"Volume Change\",   description=\"Volume change for the calculation.\")</li> <li>analysis.delta_volume_percent: float = Field(None, title=\"Volume   Change Percent\", description=\"Percent volume change for the   calculation.\")</li> <li>analysis.max_force: float = Field(None, title=\"Max Force\",   description=\"Maximum force on any atom at the end of the   calculation.\")</li> <li>analysis.warnings: List[str] = Field(None, title=\"Calculation   Warnings\",description=\"Warnings issued after analysis.\")</li> <li>analysis.errors: List[str] = Field(None, title=\"Calculation   Errors\", description=\"Errors issued after analysis.\")</li> </ul> </li> <li>atoms: Atoms = Field(None, title = \"The Atoms object from the   calculation result.\")</li> <li>atoms_info: dict = Field(None, title = \"The Atoms object info obtained   from atoms.info.\")</li> <li>builder_meta: EmmetMeta = Field(default_factory=EmmetMeta,   description=\"Builder metadata.\"):<ul> <li>builder_meta.build_date: str =   Field(default_factory=datetime.utcnow, description=\"The build date   for this document.\")</li> <li>builder_meta.emmet_version: str = Field(version,   description=\"The version of emmet this document was built with.\")</li> <li>builder_meta.pymatgen_version: str = Field(pmg_version,   description=\"The version of pymatgen this document was built   with.\")</li> </ul> </li> <li>chemsys: str = Field(None, title=\"Chemical System\",   description=\"dash-delimited string of elements in the material.\")</li> <li>composition: Composition = Field(None, description=\"Full composition   for the material.\")</li> <li>composition_reduced: Composition = Field(None, title=\"Reduced   Composition\", description=\"Simplified representation of the   composition.\")</li> <li>custodian: List[CustodianDoc] = Field(None, title=\"Calcs reversed   data\", description=\"Detailed custodian data for each VASP calculation   contributing to the task document.\")<ul> <li>custodian.corrections: List[Any] = Field(None, title=\"Custodian   Corrections\", description=\"List of custodian correction data for   calculation.\")</li> <li>custodian.job: dict = Field(None, title=\"Cusotodian Job Data\",   description=\"Job data logged by custodian.\",)</li> </ul> </li> <li>density: float = Field(None, title=\"Density\", description=\"Density in   grams per cm^3.\")</li> <li>density_atomic: float = Field(None, title=\"Packing Density\",   description=\"The atomic packing density in atoms per cm^3.\")</li> <li>dir_name: str = Field(None, description=\"The directory for this VASP   task\")</li> <li>elements: List[Element] = Field(None, description=\"List of elements in   the material.\")</li> <li>entry: ComputedEntry = Field(None, description=\"The ComputedEntry from   the task doc\")</li> <li>formula_anonymous: str = Field(None, title=\"Anonymous Formula\",   description=\"Anonymized representation of the formula.\")</li> <li>formula_pretty: str = Field(None, title=\"Pretty Formula\",   description=\"Cleaned representation of the formula.\")</li> <li>input: InputDoc = Field(None, description=\"The input structure used to   generate the current task document.\")<ul> <li>input.incar: Dict[str, Any] = Field(None, description=\"INCAR   parameters for the calculation\")</li> <li>input.is_hubbard: bool = Field(False, description=\"Is this a   Hubbard +U calculation\")</li> <li>input.kpoints: Union[Dict[str, Any], Kpoints] = Field(None,   description=\"KPOINTS for the calculation\")</li> <li>input.hubbards: Dict = Field(None, description=\"The hubbard   parameters used\")</li> <li>input.lattice_rec: Lattice = Field(None, description=\"Reciprocal   lattice of the structure\")</li> <li>input.nkpoints: int = Field(None, description=\"Total number of   k-points\")</li> <li>input.potcar: List[str] = Field(None, description=\"POTCAR symbols   in the calculation\")</li> <li>input.potcar_spec: List[PotcarSpec] = Field(None,   description=\"Title and hash of POTCAR files used in the   calculation\")</li> <li>input.potcar_type: List[str] = Field(None, description=\"List of   POTCAR functional types.\")</li> <li>input.parameters: Dict = Field(None, description=\"Parameters from   vasprun\")</li> <li>input.structure: Structure = Field(None, description=\"Input   structure for the calculation\")</li> </ul> </li> <li>nelements: int = Field(None, description=\"Number of elements.\")</li> <li>nid: str = Field(None, title = \"The node ID representing the machine   where the calculation was run.\")</li> <li>nsites: int = Field(None, description=\"Total number of sites in the   structure.\")</li> <li>orig_inputs: OrigInputs = Field(None, description=\"The exact set of   input parameters used to generate the current task document.\")<ul> <li>orig_inputs.incar: Union[Incar, Dict] = Field(None,   description=\"Pymatgen object representing the INCAR file.\")</li> <li>orig_inputs.poscar: Poscar = Field(None, description=\"Pymatgen   object representing the POSCAR file.\")</li> <li>orig_inputs.kpoints: Kpoints = Field(None, description=\"Pymatgen   object representing the KPOINTS file.\")</li> <li>orig_inputs.potcar: Union[Potcar, VaspPotcar, List[Any]] =   Field(None, description=\"Pymatgen object representing the POTCAR   file.\",)</li> </ul> </li> <li>output: OutputDoc = Field(None, description=\"The exact set of output   parameters used to generate the current task document.\")<ul> <li>output.bandgap: float = Field(None, description=\"The DFT bandgap   for the last calculation\")</li> <li>output.density: float = Field(..., description=\"Density of in   units of g/cc.\")</li> <li>output.direct_gap: float = the direct bandgap (eV)</li> <li>output.dos_properties: DosProperties = Field(None,   description=\"DOS properties for the material\")</li> <li>output.efermi: float = the fermi energy</li> <li>output.energy: float = Field(..., description=\"Total Energy in   units of eV.\")</li> <li>output.energy_per_atom: float = Field(None, description=\"The final   DFT energy per atom for the last calculation\")</li> <li>output.forces: List[List[float]] = Field(None, description=\"The   force on each atom in units of eV/A^2.\")</li> <li>output.ionic_steps: float = the number of ionic steps</li> <li>output.is_gap_direct: bool = if the band gap is direct</li> <li>output.mag_density: float = magnetization density</li> <li>output.outcar: Outcar = Field(None, description=\"Pymatgen object   representing the OUTCAR file.\")</li> <li>output.run_stats: Dict = Field(None, description=\"Runtime   statistics from the calculation.\")</li> <li>output.stress: List[List[float]] = Field(None, description=\"The   stress on the cell in units of kB.\")</li> <li>output.structure: Structure = Field(None, title=\"Output   Structure\", description=\"Output Structure from the VASP   calculation.\")</li> </ul> </li> <li>state: TaskState = Field(None, description=\"State of this   calculation\")</li> <li>symmetry: SymmetryData = Field(None, description=\"Symmetry data for   this material.\")<ul> <li>symmetry.crystal_system: CrystalSystem = Field(None,   title=\"Crystal System\", description=\"The crystal system for this   lattice.\")</li> <li>symmetry.number: int = Field(None, title=\"Space Group Number\",   description=\"The spacegroup number for the lattice.\")</li> <li>symmetry.point_group: str = Field(None, title=\"Point Group   Symbol\", description=\"The point group for the lattice.\")</li> <li>symmetry.symbol: str = Field(None, title=\"Space Group Symbol\",   description=\"The spacegroup symbol for the lattice.\")</li> <li>symmetry.symprec: float = Field(None, title=\"Symmetry Finding   Precision\", description=\"The precision given to spglib to   determine the symmetry of this lattice.\")</li> <li>symmetry.version</li> </ul> </li> <li>vasp_version: str: the version of VASP</li> <li>volume: float = Field(None, title=\"Volume\", description=\"Total volume   for this structure in Angstroms^3.\")</li> </ul> <p>If run_bader is True, the following fields are added:</p> <ul> <li>bader<ul> <li>bader.atomic_volume: float = The atomic volume</li> <li>bader.bader_charge: float = The net bader charge</li> <li>bader.bader_spin: float = The net bader spin density</li> <li>bader.bader_version: float = The bader version</li> <li>bader.min_dist: List[float] = The bader min_dist parameter</li> <li>bader.partial_charges: List[float] = The atom-projected bader   partial charges</li> <li>bader.spin_moments: List[float] = The atom-projected bader spin   moments</li> </ul> </li> </ul> </li> </ul> Source code in <code>quacc/schemas/vasp.py</code> <pre><code>def vasp_summarize_run(\n    atoms: Atoms,\n    dir_path: str | None = None,\n    prep_next_run: bool = True,\n    run_bader: bool | None = None,\n    check_convergence: bool = True,\n    additional_fields: dict | None = None,\n    store: Store | None = None,\n) -&gt; VaspSchema:\n    \"\"\"\n    Get tabulated results from a VASP run and store them in a database-friendly\n    format.\n\n    Parameters\n    ----------\n    atoms\n        ASE Atoms object following a calculation.\n    dir_path\n        Path to VASP outputs. A value of None specifies the current working\n        directory\n    prep_next_run\n        Whether the Atoms object stored in {\"atoms\": atoms} should be prepared\n        for the next run. This clears out any attached calculator and moves the\n        final magmoms to the initial magmoms.\n    run_bader\n        Whether a Bader analysis should be performed. Will not run if bader\n        executable is not in PATH even if bader is set to True. Defaults to\n        VASP_BADER in settings.\n    check_convergence\n        Whether to throw an error if convergence is not reached.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. If None,\n        `SETTINGS.PRIMARY_STORE` will be used.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary representation of the task document with the following\n        fields:\n\n        - analysis: AnalysisDoc = Field(None, title=\"Calculation Analysis\",\n          description=\"Some analysis of calculation data after collection.\")\n            - analysis.delta_volume: float = Field(None, title=\"Volume Change\",\n              description=\"Volume change for the calculation.\")\n            - analysis.delta_volume_percent: float = Field(None, title=\"Volume\n              Change Percent\", description=\"Percent volume change for the\n              calculation.\")\n            - analysis.max_force: float = Field(None, title=\"Max Force\",\n              description=\"Maximum force on any atom at the end of the\n              calculation.\")\n            - analysis.warnings: List[str] = Field(None, title=\"Calculation\n              Warnings\",description=\"Warnings issued after analysis.\")\n            - analysis.errors: List[str] = Field(None, title=\"Calculation\n              Errors\", description=\"Errors issued after analysis.\")\n        - atoms: Atoms = Field(None, title = \"The Atoms object from the\n          calculation result.\")\n        - atoms_info: dict = Field(None, title = \"The Atoms object info obtained\n          from atoms.info.\")\n        - builder_meta: EmmetMeta = Field(default_factory=EmmetMeta,\n          description=\"Builder metadata.\"):\n            - builder_meta.build_date: str =\n              Field(default_factory=datetime.utcnow, description=\"The build date\n              for this document.\")\n            - builder_meta.emmet_version: str = Field(__version__,\n              description=\"The version of emmet this document was built with.\")\n            - builder_meta.pymatgen_version: str = Field(pmg_version,\n              description=\"The version of pymatgen this document was built\n              with.\")\n        - chemsys: str = Field(None, title=\"Chemical System\",\n          description=\"dash-delimited string of elements in the material.\")\n        - composition: Composition = Field(None, description=\"Full composition\n          for the material.\")\n        - composition_reduced: Composition = Field(None, title=\"Reduced\n          Composition\", description=\"Simplified representation of the\n          composition.\")\n        - custodian: List[CustodianDoc] = Field(None, title=\"Calcs reversed\n          data\", description=\"Detailed custodian data for each VASP calculation\n          contributing to the task document.\")\n            - custodian.corrections: List[Any] = Field(None, title=\"Custodian\n              Corrections\", description=\"List of custodian correction data for\n              calculation.\")\n            - custodian.job: dict = Field(None, title=\"Cusotodian Job Data\",\n              description=\"Job data logged by custodian.\",)\n        - density: float = Field(None, title=\"Density\", description=\"Density in\n          grams per cm^3.\")\n        - density_atomic: float = Field(None, title=\"Packing Density\",\n          description=\"The atomic packing density in atoms per cm^3.\")\n        - dir_name: str = Field(None, description=\"The directory for this VASP\n          task\")\n        - elements: List[Element] = Field(None, description=\"List of elements in\n          the material.\")\n        - entry: ComputedEntry = Field(None, description=\"The ComputedEntry from\n          the task doc\")\n        - formula_anonymous: str = Field(None, title=\"Anonymous Formula\",\n          description=\"Anonymized representation of the formula.\")\n        - formula_pretty: str = Field(None, title=\"Pretty Formula\",\n          description=\"Cleaned representation of the formula.\")\n        - input: InputDoc = Field(None, description=\"The input structure used to\n          generate the current task document.\")\n            - input.incar: Dict[str, Any] = Field(None, description=\"INCAR\n              parameters for the calculation\")\n            - input.is_hubbard: bool = Field(False, description=\"Is this a\n              Hubbard +U calculation\")\n            - input.kpoints: Union[Dict[str, Any], Kpoints] = Field(None,\n              description=\"KPOINTS for the calculation\")\n            - input.hubbards: Dict = Field(None, description=\"The hubbard\n              parameters used\")\n            - input.lattice_rec: Lattice = Field(None, description=\"Reciprocal\n              lattice of the structure\")\n            - input.nkpoints: int = Field(None, description=\"Total number of\n              k-points\")\n            - input.potcar: List[str] = Field(None, description=\"POTCAR symbols\n              in the calculation\")\n            - input.potcar_spec: List[PotcarSpec] = Field(None,\n              description=\"Title and hash of POTCAR files used in the\n              calculation\")\n            - input.potcar_type: List[str] = Field(None, description=\"List of\n              POTCAR functional types.\")\n            - input.parameters: Dict = Field(None, description=\"Parameters from\n              vasprun\")\n            - input.structure: Structure = Field(None, description=\"Input\n              structure for the calculation\")\n        - nelements: int = Field(None, description=\"Number of elements.\")\n        - nid: str = Field(None, title = \"The node ID representing the machine\n          where the calculation was run.\")\n        - nsites: int = Field(None, description=\"Total number of sites in the\n          structure.\")\n        - orig_inputs: OrigInputs = Field(None, description=\"The exact set of\n          input parameters used to generate the current task document.\")\n            - orig_inputs.incar: Union[Incar, Dict] = Field(None,\n              description=\"Pymatgen object representing the INCAR file.\")\n            - orig_inputs.poscar: Poscar = Field(None, description=\"Pymatgen\n              object representing the POSCAR file.\")\n            - orig_inputs.kpoints: Kpoints = Field(None, description=\"Pymatgen\n              object representing the KPOINTS file.\")\n            - orig_inputs.potcar: Union[Potcar, VaspPotcar, List[Any]] =\n              Field(None, description=\"Pymatgen object representing the POTCAR\n              file.\",)\n        - output: OutputDoc = Field(None, description=\"The exact set of output\n          parameters used to generate the current task document.\")\n            - output.bandgap: float = Field(None, description=\"The DFT bandgap\n              for the last calculation\")\n            - output.density: float = Field(..., description=\"Density of in\n              units of g/cc.\")\n            - output.direct_gap: float = the direct bandgap (eV)\n            - output.dos_properties: DosProperties = Field(None,\n              description=\"DOS properties for the material\")\n            - output.efermi: float = the fermi energy\n            - output.energy: float = Field(..., description=\"Total Energy in\n              units of eV.\")\n            - output.energy_per_atom: float = Field(None, description=\"The final\n              DFT energy per atom for the last calculation\")\n            - output.forces: List[List[float]] = Field(None, description=\"The\n              force on each atom in units of eV/A^2.\")\n            - output.ionic_steps: float = the number of ionic steps\n            - output.is_gap_direct: bool = if the band gap is direct\n            - output.mag_density: float = magnetization density\n            - output.outcar: Outcar = Field(None, description=\"Pymatgen object\n              representing the OUTCAR file.\")\n            - output.run_stats: Dict = Field(None, description=\"Runtime\n              statistics from the calculation.\")\n            - output.stress: List[List[float]] = Field(None, description=\"The\n              stress on the cell in units of kB.\")\n            - output.structure: Structure = Field(None, title=\"Output\n              Structure\", description=\"Output Structure from the VASP\n              calculation.\")\n        - state: TaskState = Field(None, description=\"State of this\n          calculation\")\n        - symmetry: SymmetryData = Field(None, description=\"Symmetry data for\n          this material.\")\n            - symmetry.crystal_system: CrystalSystem = Field(None,\n              title=\"Crystal System\", description=\"The crystal system for this\n              lattice.\")\n            - symmetry.number: int = Field(None, title=\"Space Group Number\",\n              description=\"The spacegroup number for the lattice.\")\n            - symmetry.point_group: str = Field(None, title=\"Point Group\n              Symbol\", description=\"The point group for the lattice.\")\n            - symmetry.symbol: str = Field(None, title=\"Space Group Symbol\",\n              description=\"The spacegroup symbol for the lattice.\")\n            - symmetry.symprec: float = Field(None, title=\"Symmetry Finding\n              Precision\", description=\"The precision given to spglib to\n              determine the symmetry of this lattice.\")\n            - symmetry.version\n        - vasp_version: str: the version of VASP\n        - volume: float = Field(None, title=\"Volume\", description=\"Total volume\n          for this structure in Angstroms^3.\")\n\n        If run_bader is True, the following fields are added:\n\n        - bader\n            - bader.atomic_volume: float = The atomic volume\n            - bader.bader_charge: float = The net bader charge\n            - bader.bader_spin: float = The net bader spin density\n            - bader.bader_version: float = The bader version\n            - bader.min_dist: List[float] = The bader min_dist parameter\n            - bader.partial_charges: List[float] = The atom-projected bader\n              partial charges\n            - bader.spin_moments: List[float] = The atom-projected bader spin\n              moments\n    \"\"\"\n\n    additional_fields = additional_fields or {}\n    run_bader = SETTINGS.VASP_BADER if run_bader is None else run_bader\n    dir_path = dir_path or Path.cwd()\n    store = SETTINGS.PRIMARY_STORE if store is None else store\n\n    # Fetch all tabulated results from VASP outputs files Fortunately, emmet\n    # already has a handy function for this\n    taskdoc = TaskDoc.from_directory(dir_path).dict()\n\n    uri = taskdoc[\"dir_name\"]\n    taskdoc[\"nid\"] = uri.split(\":\")[0]\n    taskdoc[\"dir_name\"] = \":\".join(uri.split(\":\")[1:])\n    taskdoc[\"builder_meta\"][\"build_date\"] = str(taskdoc[\"builder_meta\"][\"build_date\"])\n\n    # Check for calculation convergence\n    if check_convergence and taskdoc[\"state\"] != \"successful\":\n        raise ValueError(\"VASP calculation did not converge. Will not store task data.\")\n\n    # Remove unnecessary fields\n    for k in [\n        \"additional_json\",\n        \"author\",\n        \"calcs_reversed\",\n        \"icsd_id\",\n        \"last_updated\",\n        \"structure\",  # already in output\n        \"tags\",\n        \"task_id\",\n        \"task_label\",\n        \"transformations\",\n        \"vasp_objects\",\n    ]:\n        taskdoc.pop(k, None)\n\n    if \"output\" in taskdoc:\n        taskdoc[\"output\"].pop(\"elph_displaced_structures\", None)\n        taskdoc[\"output\"].pop(\"frequency_dependent_dielectric\", None)\n\n    # Get Bader analysis\n    if run_bader:\n        try:\n            bader_stats = bader_runner(dir_path)\n        except Exception:\n            bader_stats = None\n            warnings.warn(\"Bader analysis could not be performed.\", UserWarning)\n\n        if bader_stats:\n            taskdoc[\"bader\"] = bader_stats\n\n            # Attach bader charges/spins to structure object\n            struct = taskdoc[\"output\"][\"structure\"]\n            struct.add_site_property(\"bader_charge\", bader_stats[\"partial_charges\"])\n            if \"spin_moments\" in bader_stats:\n                struct.add_site_property(\"bader_spin\", bader_stats[\"spin_moments\"])\n            taskdoc[\"output\"][\"structure\"] = struct\n\n    # Prepares the Atoms object for the next run by moving the final magmoms to\n    # initial, clearing the calculator state, and assigning the resulting Atoms\n    # object a unique ID.\n    if prep_next_run:\n        atoms = prep_next_run_(atoms)\n\n    # We use get_metadata=False and store_pmg=False because the TaskDocument\n    # already makes the structure metadata for us\n    atoms_db = atoms_to_metadata(atoms, get_metadata=False, store_pmg=False)\n\n    # Make task document\n    summary = sort_dict(taskdoc | atoms_db | additional_fields)\n\n    # Store the results\n    if store:\n        results_to_db(store, taskdoc)\n\n    return summary\n</code></pre>"},{"location":"reference/quacc/utils/dicts.html","title":"dicts","text":"<p>Utility functions for dealing with dictionaries</p>"},{"location":"reference/quacc/utils/dicts.html#quacc.utils.dicts.merge_dicts","title":"merge_dicts","text":"<pre><code>merge_dicts(dict1, dict2, remove_nones=True)\n</code></pre> <p>Recursively merges two dictionaries. If one the inputs are <code>None</code>, then it is treated as <code>{}</code>.</p> <p>Parameters:</p> <ul> <li> <code>dict1</code>             (<code>dict | None</code>)         \u2013          <p>First dictionary</p> </li> <li> <code>dict2</code>             (<code>dict | None</code>)         \u2013          <p>Second dictionary</p> </li> <li> <code>remove_nones</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If True, remove empty lists and dictionaries</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Merged dictionary</p> </li> </ul> Source code in <code>quacc/utils/dicts.py</code> <pre><code>def merge_dicts(\n    dict1: dict | None, dict2: dict | None, remove_nones: bool = True\n) -&gt; dict:\n    \"\"\"\n    Recursively merges two dictionaries. If one the inputs are `None`, then\n    it is treated as `{}`.\n\n    Parameters\n    ----------\n    dict1\n        First dictionary\n    dict2\n        Second dictionary\n    remove_nones\n        If True, remove empty lists and dictionaries\n\n    Returns\n    -------\n    dict\n        Merged dictionary\n    \"\"\"\n    dict1 = dict1 or {}\n    dict2 = dict2 or {}\n    merged = dict1.copy()\n\n    for key, value in dict2.items():\n        if key in merged:\n            if isinstance(merged[key], dict) and isinstance(value, dict):\n                merged[key] = merge_dicts(merged[key], value)\n            else:\n                merged[key] = value\n        else:\n            merged[key] = value\n\n    if remove_nones:\n        merged = remove_dict_empties(merged)\n\n    return merged\n</code></pre>"},{"location":"reference/quacc/utils/dicts.html#quacc.utils.dicts.remove_dict_empties","title":"remove_dict_empties","text":"<pre><code>remove_dict_empties(start_dict)\n</code></pre> <p>For a given dictionary, recursively remove all items that are None or are empty lists/dicts.</p> <p>Parameters:</p> <ul> <li> <code>start_dict</code>             (<code>dict</code>)         \u2013          <p>Dictionary to clean</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Cleaned dictionary</p> </li> </ul> Source code in <code>quacc/utils/dicts.py</code> <pre><code>def remove_dict_empties(start_dict: dict) -&gt; dict:\n    \"\"\"\n    For a given dictionary, recursively remove all items that are None or are\n    empty lists/dicts.\n\n    Parameters\n    ----------\n    start_dict\n        Dictionary to clean\n\n    Returns\n    -------\n    dict\n        Cleaned dictionary\n    \"\"\"\n\n    if isinstance(start_dict, dict):\n        return {\n            k: remove_dict_empties(v) for k, v in start_dict.items() if v is not None\n        }\n    return (\n        [remove_dict_empties(v) for v in start_dict]\n        if isinstance(start_dict, list)\n        else start_dict\n    )\n</code></pre>"},{"location":"reference/quacc/utils/dicts.html#quacc.utils.dicts.sort_dict","title":"sort_dict","text":"<pre><code>sort_dict(start_dict)\n</code></pre> <p>For a given dictionary, recursively sort all entries alphabetically by key.</p> <p>Parameters:</p> <ul> <li> <code>start_dict</code>             (<code>dict</code>)         \u2013          <p>Dictionary to sort</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Sorted dictionary</p> </li> </ul> Source code in <code>quacc/utils/dicts.py</code> <pre><code>def sort_dict(start_dict: dict) -&gt; dict:\n    \"\"\"\n    For a given dictionary, recursively sort all entries alphabetically by key.\n\n    Parameters\n    ----------\n    start_dict\n        Dictionary to sort\n\n    Returns\n    -------\n    dict\n        Sorted dictionary\n    \"\"\"\n\n    return {\n        k: sort_dict(v) if isinstance(v, dict) else v\n        for k, v in sorted(start_dict.items())\n    }\n</code></pre>"},{"location":"reference/quacc/utils/files.html","title":"files","text":"<p>Utility functions for file and path handling</p>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.check_logfile","title":"check_logfile","text":"<pre><code>check_logfile(logfile, check_str)\n</code></pre> <p>Check if a logfile has a given string (case-insensitive).</p> <p>Parameters:</p> <ul> <li> <code>logfile</code>             (<code>str</code>)         \u2013          <p>Path to the logfile.</p> </li> <li> <code>check_str</code>             (<code>str</code>)         \u2013          <p>String to check for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True if the string is found in the logfile, False otherwise.</p> </li> </ul> Source code in <code>quacc/utils/files.py</code> <pre><code>def check_logfile(logfile: str, check_str: str) -&gt; bool:\n    \"\"\"\n    Check if a logfile has a given string (case-insensitive).\n\n    Parameters\n    ----------\n    logfile : str\n        Path to the logfile.\n    check_str : str\n        String to check for.\n\n    Returns\n    -------\n    bool\n        True if the string is found in the logfile, False otherwise.\n    \"\"\"\n    zlog = zpath(logfile)\n    with zopen(zlog, \"r\") as f:\n        for line in f:\n            clean_line = line if isinstance(line, str) else line.decode(\"utf-8\")\n            if check_str.lower() in clean_line.lower():\n                return True\n    return False\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.copy_decompress","title":"copy_decompress","text":"<pre><code>copy_decompress(source_files, destination)\n</code></pre> <p>Copy and decompress files from source to destination.</p> <p>Parameters:</p> <ul> <li> <code>source_files</code>             (<code>list[str | Path]</code>)         \u2013          <p>List of files to copy and decompress.</p> </li> <li> <code>destination</code>             (<code>str | Path</code>)         \u2013          <p>Destination directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>quacc/utils/files.py</code> <pre><code>def copy_decompress(source_files: list[str | Path], destination: str | Path) -&gt; None:\n    \"\"\"\n    Copy and decompress files from source to destination.\n\n    Parameters\n    ----------\n    source_files\n        List of files to copy and decompress.\n    destination\n        Destination directory.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    for f in source_files:\n        z_path = Path(zpath(f))\n        if z_path.exists():\n            copy(z_path, Path(destination, z_path.name))\n            decompress_file(Path(destination, z_path.name))\n        else:\n            warnings.warn(f\"Cannot find file: {z_path}\", UserWarning)\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.find_recent_logfile","title":"find_recent_logfile","text":"<pre><code>find_recent_logfile(dir_name, logfile_extensions)\n</code></pre> <p>Find the most recent logfile in a given directory.</p> <p>Parameters:</p> <ul> <li> <code>dir_name</code>             (<code>Path | str</code>)         \u2013          <p>The path to the directory to search</p> </li> <li> <code>logfile_extensions</code>             (<code>str | list[str]</code>)         \u2013          <p>The extension (or list of possible extensions) of the logfile to search for. For an exact match only, put in the full file name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>logfile</code>         \u2013          <p>The path to the most recent logfile with the desired extension</p> </li> </ul> Source code in <code>quacc/utils/files.py</code> <pre><code>def find_recent_logfile(dir_name: Path | str, logfile_extensions: str | list[str]):\n    \"\"\"\n    Find the most recent logfile in a given directory.\n\n    Parameters\n    ----------\n    dir_name\n        The path to the directory to search\n    logfile_extensions\n        The extension (or list of possible extensions) of the logfile to search\n        for. For an exact match only, put in the full file name.\n\n    Returns\n    -------\n    logfile\n        The path to the most recent logfile with the desired extension\n    \"\"\"\n    mod_time = 0.0\n    logfile = None\n    if isinstance(logfile_extensions, str):\n        logfile_extensions = [logfile_extensions]\n    for f in os.listdir(dir_name):\n        f_path = Path(dir_name, f)\n        for ext in logfile_extensions:\n            if ext in f and f_path.stat().st_mtime &gt; mod_time:\n                mod_time = f_path.stat().st_mtime\n                logfile = f_path.resolve()\n    return logfile\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.get_uri","title":"get_uri","text":"<pre><code>get_uri(dir_name)\n</code></pre> <p>Return the URI path for a directory.</p> <p>This allows files hosted on different file servers to have distinct locations.</p> <p>Adapted from Atomate2.</p> <p>Parameters:</p> <ul> <li> <code>dir_name</code>             (<code>str</code>)         \u2013          <p>A directory name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>Full URI path, e.g., \"fileserver.host.com:/full/path/of/dir_name\".</p> </li> </ul> Source code in <code>quacc/utils/files.py</code> <pre><code>def get_uri(dir_name: str | Path) -&gt; str:\n    \"\"\"\n    Return the URI path for a directory.\n\n    This allows files hosted on different file servers to have distinct\n    locations.\n\n    Adapted from Atomate2.\n\n    Parameters\n    ----------\n    dir_name : str\n        A directory name.\n\n    Returns\n    -------\n    str\n        Full URI path, e.g., \"fileserver.host.com:/full/path/of/dir_name\".\n    \"\"\"\n    fullpath = Path(dir_name).absolute()\n    hostname = socket.gethostname()\n    with contextlib.suppress(socket.gaierror, socket.herror):\n        hostname = socket.gethostbyaddr(hostname)[0]\n    return f\"{hostname}:{fullpath}\"\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.load_yaml_calc","title":"load_yaml_calc","text":"<pre><code>load_yaml_calc(yaml_path)\n</code></pre> <p>Loads a YAML file containing calculator settings. This YAML loader looks for a special flag \"parent\" in the YAML file. If this flag is present, the YAML file specified in the \"parent\" flag is loaded and its contents are inherited by the child YAML file.</p> <p>Parameters:</p> <ul> <li> <code>yaml_path</code>             (<code>str | Path</code>)         \u2013          <p>Path to the YAML file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>The calculator configuration (i.e. settings).</p> </li> </ul> Source code in <code>quacc/utils/files.py</code> <pre><code>def load_yaml_calc(yaml_path: str | Path) -&gt; dict:\n    \"\"\"\n    Loads a YAML file containing calculator settings. This YAML loader looks for\n    a special flag \"parent\" in the YAML file. If this flag is present, the YAML\n    file specified in the \"parent\" flag is loaded and its contents are inherited\n    by the child YAML file.\n\n    Parameters\n    ----------\n    yaml_path\n        Path to the YAML file.\n\n    Returns\n    -------\n    dict\n        The calculator configuration (i.e. settings).\n    \"\"\"\n\n    yaml_path = Path(yaml_path).with_suffix(\".yaml\")\n\n    if not yaml_path.exists():\n        msg = f\"Cannot find {yaml_path}\"\n        raise ValueError(msg)\n\n    # Load YAML file\n    with yaml_path.open() as stream:\n        config = yaml.safe_load(stream)\n\n    # Inherit arguments from any parent YAML files but do not overwrite those in\n    # the child file.\n    for config_arg in config.copy():\n        if \"parent\" in config_arg.lower():\n            yaml_parent_path = Path(yaml_path).parent / Path(config[config_arg])\n            parent_config = load_yaml_calc(yaml_parent_path)\n\n            for k, v in parent_config.items():\n                if k not in config:\n                    config[k] = v\n                else:\n                    v_new = parent_config.get(k, {})\n                    for kk, vv in v_new.items():\n                        if kk not in config[k]:\n                            config[k][kk] = vv\n\n            del config[config_arg]\n\n    return config\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.make_unique_dir","title":"make_unique_dir","text":"<pre><code>make_unique_dir(base_path=None)\n</code></pre> <p>Make a directory with a unique name. Uses the same format as Jobflow.</p> <p>Parameters:</p> <ul> <li> <code>base_path</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Path to the base directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>Path to the job directory.</p> </li> </ul> Source code in <code>quacc/utils/files.py</code> <pre><code>def make_unique_dir(base_path: str | None = None) -&gt; Path:\n    \"\"\"\n    Make a directory with a unique name. Uses the same format as Jobflow.\n\n    Parameters\n    ----------\n    base_path\n        Path to the base directory.\n\n    Returns\n    -------\n    Path\n        Path to the job directory.\n    \"\"\"\n    time_now = datetime.utcnow().strftime(\"%Y-%m-%d-%H-%M-%S-%f\")\n    job_dir = Path(f\"quacc-{time_now}-{randint(10000, 99999)}\")\n    if base_path:\n        job_dir = Path(base_path, job_dir)\n    job_dir.mkdir(parents=True)\n\n    return job_dir\n</code></pre>"},{"location":"reference/quacc/wflow/db.html","title":"db","text":"<p>Utility functions for interfacing with databases</p>"},{"location":"reference/quacc/wflow/db.html#quacc.wflow.db.covalent_to_db","title":"covalent_to_db","text":"<pre><code>covalent_to_db(store, dispatch_ids=None, results_dir=None)\n</code></pre> <p>Store the results of a Covalent database in a user-specified Maggma Store</p> <p>Parameters:</p> <ul> <li> <code>store</code>             (<code>Store</code>)         \u2013          <p>The Maggma Store object to store the results in</p> </li> <li> <code>dispatch_ids</code>             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Dispatch ID to store. If None, all dispatch IDs in the results_dir will be stored</p> </li> <li> <code>results_dir</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The Covalent results_dir to pull if dispatch_ID is None. If None, the results_dir from ct.get_config() will be used</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>quacc/wflow/db.py</code> <pre><code>def covalent_to_db(\n    store: Store, dispatch_ids: list[str] | None = None, results_dir: str | None = None\n) -&gt; None:\n    \"\"\"\n    Store the results of a Covalent database in a user-specified Maggma Store\n\n    Parameters\n    ----------\n    store\n        The Maggma Store object to store the results in\n    dispatch_ids\n        Dispatch ID to store. If None, all dispatch IDs in the results_dir will\n        be stored\n    results_dir\n        The Covalent results_dir to pull if dispatch_ID is None. If None, the\n        results_dir from ct.get_config() will be used\n\n    Returns\n    -------\n    None\n    \"\"\"\n    import covalent as ct\n    from covalent._shared_files.exceptions import MissingLatticeRecordError\n\n    if dispatch_ids and results_dir:\n        msg = \"Cannot specify both dispatch_id and results_dir\"\n        raise ValueError(msg)\n    dispatch_ids = dispatch_ids or []\n\n    # Get the dispatch IDs\n    if not dispatch_ids:\n        if results_dir:\n            dispatch_ids = os.listdir(results_dir)\n        else:\n            config_results_dir = ct.get_config()[\"dispatcher\"][\"results_dir\"]\n            dispatch_ids = os.listdir(config_results_dir)\n\n    # Populate the docs\n    docs = []\n    for d_id in dispatch_ids:\n        try:\n            result_obj = ct.get_result(d_id)\n        except MissingLatticeRecordError:\n            warnings.warn(f\"Could not find dispatch_id: {d_id}\", UserWarning)\n            continue\n        if result_obj and result_obj.status == \"COMPLETED\":\n            docs.append({\"dispatch_id\": d_id, \"result\": result_obj.result})\n\n    # Store the results\n    if docs:\n        with store:\n            store.update(docs, key=\"dispatch_id\")\n</code></pre>"},{"location":"reference/quacc/wflow/db.html#quacc.wflow.db.results_to_db","title":"results_to_db","text":"<pre><code>results_to_db(store, results)\n</code></pre> <p>Store the results of a quacc recipe in a user-specified Maggma Store. A UUID will be generated for each entry.</p> <p>Parameters:</p> <ul> <li> <code>store</code>             (<code>Store</code>)         \u2013          <p>The Maggma Store object to store the results in</p> </li> <li> <code>results</code>             (<code>dict | list[dict]</code>)         \u2013          <p>The output summary dictionary or list of dictionaries from a quacc recipe</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          </li> </ul> Source code in <code>quacc/wflow/db.py</code> <pre><code>def results_to_db(store: Store, results: dict | list[dict]) -&gt; None:\n    \"\"\"\n    Store the results of a quacc recipe in a user-specified Maggma Store. A UUID\n    will be generated for each entry.\n\n    Parameters\n    ----------\n    store\n        The Maggma Store object to store the results in\n    results\n        The output summary dictionary or list of dictionaries from a quacc\n        recipe\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    if isinstance(results, dict):\n        results = [results]\n\n    for result in results:\n        result[\"uuid\"] = str(uuid.uuid4())\n\n    with store:\n        store.update(results, key=\"uuid\")\n</code></pre>"},{"location":"reference/quacc/wflow/decorators.html","title":"decorators","text":"<p>Workflow decorators</p>"},{"location":"reference/quacc/wflow/decorators.html#quacc.wflow.decorators.flow","title":"flow","text":"<pre><code>flow(_func=None, **kwargs)\n</code></pre> <p>Decorator for workflows, which consist of at least one compute job. This is a <code>@flow</code> decorator.</p> Quacc Covalent Parsl Prefect Redun Jobflow <code>flow</code> <code>ct.lattice</code> No effect <code>flow</code> <code>task</code> No effect <p>All <code>@flow</code>-decorated functions are transformed into their corresponding decorator.</p> <pre><code>from quacc import flow, job\n\n@job\ndef add(a, b):\n    return a + b\n\n@flow\ndef workflow(a, b, c):\n    return add(add(a, b), c)\n\nworkflow(1, 2, 3)\n</code></pre> <p>... is the same as doing</p> Covalent\u2b50Parsl\u2b50PrefectRedunJobflow <pre><code>import covalent as ct\n\n@ct.electron\ndef add(a, b):\n    return a + b\n\n@ct.lattice\ndef workflow(a, b, c):\n    return add(add(a, b), c)\n\nworkflow(1, 2, 3)\n</code></pre> <pre><code>from parsl import python_app\n\n@python_app\ndef add(a, b):\n    return a + b\n\ndef workflow(a, b, c):\n    return add(add(a, b), c)\n\nworkflow(1, 2, 3)\n</code></pre> <pre><code>from prefect import flow, task\n\n@task\ndef add(a, b):\n    return a + b\n\n@flow\ndef workflow(a, b, c):\n    return add.submit(add.submit(a, b), c)\n\nworkflow(1, 2, 3)\n</code></pre> <pre><code>from redun import task\n\n@task\ndef add(a, b):\n    return a + b\n\n@task\ndef workflow(a, b, c):\n    return add(add(a, b), c)\n\nworkflow(1, 2, 3)\n</code></pre> <p>Warning</p> <p>This decorator is not meant to be used with Jobflow at this time.</p> <p>Parameters:</p> <ul> <li> <code>_func</code>             (<code>Callable | None</code>, default:                 <code>None</code> )         \u2013          <p>The function to decorate. This is not meant to be supplied by the user.</p> </li> <li> <code>**kwargs</code>         \u2013          <p>Keyword arguments to pass to the decorator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Flow</code>         \u2013          <p>The <code>@flow</code>-decorated function.</p> </li> </ul> Source code in <code>quacc/wflow/decorators.py</code> <pre><code>def flow(_func: Callable | None = None, **kwargs) -&gt; Flow:\n    \"\"\"\n    Decorator for workflows, which consist of at least one compute job. This is\n    a `#!Python @flow` decorator.\n\n    | Quacc  | Covalent     | Parsl     | Prefect | Redun  | Jobflow   |\n    | ------ | ------------ | --------- | ------- | ------ | --------- |\n    | `flow` | `ct.lattice` | No effect | `flow`  | `task` | No effect |\n\n    All `#!Python @flow`-decorated functions are transformed into their corresponding\n    decorator.\n\n    ```python\n    from quacc import flow, job\n\n    @job\n    def add(a, b):\n        return a + b\n\n    @flow\n    def workflow(a, b, c):\n        return add(add(a, b), c)\n\n    workflow(1, 2, 3)\n    ```\n\n    ... is the same as doing\n\n    === \"Covalent\u2b50\"\n\n        ```python\n        import covalent as ct\n\n        @ct.electron\n        def add(a, b):\n            return a + b\n\n        @ct.lattice\n        def workflow(a, b, c):\n            return add(add(a, b), c)\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Parsl\u2b50\"\n\n        ```python\n        from parsl import python_app\n\n        @python_app\n        def add(a, b):\n            return a + b\n\n        def workflow(a, b, c):\n            return add(add(a, b), c)\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Prefect\"\n\n        ```python\n        from prefect import flow, task\n\n        @task\n        def add(a, b):\n            return a + b\n\n        @flow\n        def workflow(a, b, c):\n            return add.submit(add.submit(a, b), c)\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Redun\"\n\n        ```python\n        from redun import task\n\n        @task\n        def add(a, b):\n            return a + b\n\n        @task\n        def workflow(a, b, c):\n            return add(add(a, b), c)\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Jobflow\"\n\n        !!! Warning\n\n            This decorator is not meant to be used with Jobflow at this time.\n\n    Parameters\n    ----------\n    _func\n        The function to decorate. This is not meant to be supplied by the user.\n    **kwargs\n        Keyword arguments to pass to the decorator.\n\n    Returns\n    -------\n    Flow\n        The `#!Python @flow`-decorated function.\n    \"\"\"\n    from quacc import SETTINGS\n\n    if _func is None:\n        return functools.partial(flow, **kwargs)\n\n    wflow_engine = SETTINGS.WORKFLOW_ENGINE\n    if wflow_engine == \"covalent\":\n        import covalent as ct\n\n        decorated = ct.lattice(_func, **kwargs)\n    elif wflow_engine == \"redun\":\n        from redun import task as redun_task\n\n        decorated = redun_task(_func, **kwargs)\n    elif wflow_engine == \"prefect\":\n        from prefect import flow as prefect_flow\n\n        decorated = prefect_flow(_func, **kwargs)\n    else:\n        decorated = _func\n\n    return decorated\n</code></pre>"},{"location":"reference/quacc/wflow/decorators.html#quacc.wflow.decorators.job","title":"job","text":"<pre><code>job(_func=None, **kwargs)\n</code></pre> <p>Decorator for individual compute jobs. This is a <code>@job</code> decorator. Think of each <code>@job</code>-decorated function as an individual SLURM job, if that helps.</p> Quacc Covalent Parsl Prefect Redun Jobflow <code>job</code> <code>ct.electron</code> <code>python_app</code> <code>task</code> <code>task</code> <code>job</code> <p>All <code>@job</code>-decorated functions are transformed into their corresponding decorator.</p> <p>The wrapped function can also be stripped of its decorator by calling the <code>.__wrapped__</code> attribute.</p> <pre><code>from quacc import job\n\n@job\ndef add(a, b):\n    return a + b\n\nadd(1, 2)\n</code></pre> <p>... is the same as doing</p> Covalent\u2b50Parsl\u2b50PrefectRedunJobflow <pre><code>import covalent as ct\n\n@ct.electron\ndef add(a, b):\n    return a + b\n\nadd(1, 2)\n</code></pre> <pre><code>from parsl import python_app\n\n@python_app\ndef add(a, b):\n    return a + b\n\nadd(1, 2)\n</code></pre> <pre><code>from prefect import task\n\n@task\ndef add(a, b):\n    return a + b\n\nadd.submit(1, 2)\n</code></pre> <pre><code>from redun import task\n\n@task\ndef add(a, b):\n    return a + b\n\nadd(1, 2)\n</code></pre> <pre><code>import jobflow as jf\n\n@jf.job\ndef add(a, b):\n    return a + b\n\nadd(1, 2)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>_func</code>             (<code>Callable | None</code>, default:                 <code>None</code> )         \u2013          <p>The function to decorate. This is not meant to be supplied by the user.</p> </li> <li> <code>**kwargs</code>         \u2013          <p>Keyword arguments to pass to the workflow engine decorator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Job</code>         \u2013          <p>The @job-decorated function.</p> </li> </ul> Source code in <code>quacc/wflow/decorators.py</code> <pre><code>def job(_func: Callable | None = None, **kwargs) -&gt; Job:\n    \"\"\"\n    Decorator for individual compute jobs. This is a `#!Python @job` decorator. Think\n    of each `#!Python @job`-decorated function as an individual SLURM job, if that helps.\n\n    | Quacc | Covalent      | Parsl        | Prefect | Redun  | Jobflow |\n    | ----- | ------------- | ------------ | ------- | ------ | ------- |\n    | `job` | `ct.electron` | `python_app` | `task`  | `task` | `job`   |\n\n    All `#!Python @job`-decorated functions are transformed into their corresponding\n    decorator.\n\n    The wrapped function can also be stripped of its decorator by calling the\n    `#!Python .__wrapped__` attribute.\n\n    ```python\n    from quacc import job\n\n    @job\n    def add(a, b):\n        return a + b\n\n    add(1, 2)\n    ```\n\n    ... is the same as doing\n\n    === \"Covalent\u2b50\"\n\n        ```python\n        import covalent as ct\n\n        @ct.electron\n        def add(a, b):\n            return a + b\n\n        add(1, 2)\n        ```\n\n    === \"Parsl\u2b50\"\n\n        ```python\n        from parsl import python_app\n\n        @python_app\n        def add(a, b):\n            return a + b\n\n        add(1, 2)\n        ```\n\n    === \"Prefect\"\n\n        ```python\n        from prefect import task\n\n        @task\n        def add(a, b):\n            return a + b\n\n        add.submit(1, 2)\n        ```\n\n    === \"Redun\"\n\n        ```python\n        from redun import task\n\n        @task\n        def add(a, b):\n            return a + b\n\n        add(1, 2)\n        ```\n\n    === \"Jobflow\"\n\n        ```python\n        import jobflow as jf\n\n        @jf.job\n        def add(a, b):\n            return a + b\n\n        add(1, 2)\n        ```\n\n    Parameters\n    ----------\n    _func\n        The function to decorate. This is not meant to be supplied by the user.\n    **kwargs\n        Keyword arguments to pass to the workflow engine decorator.\n\n    Returns\n    -------\n    Job\n        The @job-decorated function.\n    \"\"\"\n\n    @functools.wraps(_func)\n    def _inner(*f_args, decorator_kwargs: dict | None = None, **f_kwargs) -&gt; Any:\n        \"\"\"\n        This function is used for handling workflow engines that require some action\n        beyond just decoration. It also patches the parent function `_func` to takke\n        an additional keyword argument, `deocrator_kwargs`, that is a dictionary of\n        keyword arguments to pass during the decorator construction.\n\n        Parameters\n        ----------\n        *f_args\n            Positional arguments to the function, if any.\n        decorator_kwargs\n            Keyword arguments to pass to the workflow engine decorator.\n        **f_kwargs\n            Keyword arguments to the function, if any.\n\n        Returns\n        -------\n        Any\n            The output of the @job-decorated function.\n        \"\"\"\n        decorator_kwargs = decorator_kwargs if decorator_kwargs is not None else kwargs\n\n        if wflow_engine == \"prefect\":\n            from prefect import task as prefect_task\n\n            decorated = prefect_task(_func, **decorator_kwargs)\n            return decorated.submit(*f_args, **f_kwargs)\n\n        return decorated(*f_args, **f_kwargs)\n\n    from quacc import SETTINGS\n\n    wflow_engine = SETTINGS.WORKFLOW_ENGINE\n\n    if _func is None:\n        return functools.partial(job, **kwargs)\n\n    if wflow_engine == \"covalent\":\n        import covalent as ct\n\n        decorated = ct.electron(_func, **kwargs)\n    elif wflow_engine == \"jobflow\":\n        from jobflow import job as jf_job\n\n        decorated = jf_job(_func, **kwargs)\n    elif wflow_engine == \"parsl\":\n        from parsl import python_app\n\n        decorated = python_app(_func, **kwargs)\n    elif wflow_engine == \"redun\":\n        from redun import task as redun_task\n\n        decorated = redun_task(_func, **kwargs)\n    elif wflow_engine == \"prefect\":\n        return _inner\n    else:\n        decorated = _func\n\n    if not hasattr(decorated, \"__wrapped__\"):\n        decorated.__wrapped__ = _func\n\n    return decorated\n</code></pre>"},{"location":"reference/quacc/wflow/decorators.html#quacc.wflow.decorators.subflow","title":"subflow","text":"<pre><code>subflow(_func=None, **kwargs)\n</code></pre> <p>Decorator for (dynamic) sub-workflows. This is a <code>@subflow</code> decorator.</p> Quacc Covalent Parsl Prefect Redun Jobflow <code>subflow</code> <code>ct.electron(ct.lattice)</code> <code>join_app</code> <code>flow</code> <code>task</code> No effect <p>All <code>@subflow</code>-decorated functions are transformed into their corresponding decorator.</p> <pre><code>import random\nfrom quacc import flow, job, subflow\n\n@job\ndef add(a, b):\n    return a + b\n\n@job\ndef make_more(val):\n    return [val] * random.randint(2, 5)\n\n@subflow\ndef add_distributed(vals, c):\n    return [add(val, c) for val in vals]\n\n@flow\ndef workflow(a, b, c):\n    result1 = add(a, b)\n    result2 = make_more(result1)\n    return add_distributed(result2, c)\n\nworkflow(1, 2, 3)\n</code></pre> <p>... is the same as doing</p> Covalent\u2b50Parsl\u2b50PrefectRedunJobflow <pre><code>import random\nimport covalent as ct\n\n@ct.electron\ndef add(a, b):\n    return a + b\n\n@ct.electron\ndef make_more(val):\n    return [val] * random.randint(2, 5)\n\n@ct.electron\n@ct.lattice\ndef add_distributed(vals, c):\n    return [add(val, c) for val in vals]\n\n@ct.lattice\ndef workflow(a, b, c):\n    result1 = add(a, b)\n    result2 = make_more(result1)\n    return add_distributed(result2, c)\n\nworkflow(1, 2, 3)\n</code></pre> <pre><code>import random\nfrom parsl import join_app, python_app\n\n@python_app\ndef add(a, b):\n    return a + b\n\n@python_app\ndef make_more(val):\n    return [val] * random.randint(2, 5)\n\n@join_app\ndef add_distributed(vals, c):\n    return [add(val, c) for val in vals]\n\ndef workflow(a, b, c):\n    result1 = add(a, b)\n    result2 = make_more(result1)\n    return add_distributed(result2, c)\n\nworkflow(1, 2, 3)\n</code></pre> <pre><code>import random\nfrom prefect import flow, task\n\n@task\ndef add(a, b):\n    return a + b\n\n@task\ndef make_more(val):\n    return [val] * random.randint(2, 5)\n\n@flow\ndef add_distributed(vals, c):\n    return [add(val, c) for val in vals]\n\n@flow\ndef workflow(a, b, c):\n    result1 = add.submit(a, b)\n    result2 = make_more.submit(result1)\n    return add_distributed(result2, c)\n\nworkflow(1, 2, 3)\n</code></pre> <pre><code>import random\nfrom redun import task\n\n@task\ndef add(a, b):\n    return a + b\n\n@task\ndef make_more(val):\n    return [val] * random.randint(2, 5)\n\n@task\ndef add_distributed(vals, c):\n    return [add(val, c) for val in vals]\n\n@task\ndef workflow(a, b, c):\n    result1 = add(a, b)\n    result2 = make_more(result1)\n    return add_distributed(result2, c)\n\nworkflow(1, 2, 3)\n</code></pre> <p>Warning</p> <p>This decorator is not meant to be used with Jobflow at this time.</p> <p>Parameters:</p> <ul> <li> <code>_func</code>             (<code>Callable | None</code>, default:                 <code>None</code> )         \u2013          <p>The function to decorate. This is not meant to be supplied by the user.</p> </li> <li> <code>**kwargs</code>         \u2013          <p>Keyword arguments to pass to the decorator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>callable</code>         \u2013          <p>The decorated function.</p> </li> </ul> Source code in <code>quacc/wflow/decorators.py</code> <pre><code>def subflow(_func: Callable | None = None, **kwargs) -&gt; Subflow:\n    \"\"\"\n    Decorator for (dynamic) sub-workflows. This is a `#!Python @subflow` decorator.\n\n    | Quacc     | Covalent                  | Parsl      | Prefect | Redun  | Jobflow   |\n    | --------- | ------------------------- | ---------- | ------- | ------ | --------- |\n    | `subflow` | `ct.electron(ct.lattice)` | `join_app` | `flow`  | `task` | No effect |\n\n    All `#!Python @subflow`-decorated functions are transformed into their corresponding\n    decorator.\n\n    ```python\n    import random\n    from quacc import flow, job, subflow\n\n    @job\n    def add(a, b):\n        return a + b\n\n    @job\n    def make_more(val):\n        return [val] * random.randint(2, 5)\n\n    @subflow\n    def add_distributed(vals, c):\n        return [add(val, c) for val in vals]\n\n    @flow\n    def workflow(a, b, c):\n        result1 = add(a, b)\n        result2 = make_more(result1)\n        return add_distributed(result2, c)\n\n    workflow(1, 2, 3)\n    ```\n\n    ... is the same as doing\n\n    === \"Covalent\u2b50\"\n\n        ```python\n        import random\n        import covalent as ct\n\n        @ct.electron\n        def add(a, b):\n            return a + b\n\n        @ct.electron\n        def make_more(val):\n            return [val] * random.randint(2, 5)\n\n        @ct.electron\n        @ct.lattice\n        def add_distributed(vals, c):\n            return [add(val, c) for val in vals]\n\n        @ct.lattice\n        def workflow(a, b, c):\n            result1 = add(a, b)\n            result2 = make_more(result1)\n            return add_distributed(result2, c)\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Parsl\u2b50\"\n\n        ```python\n        import random\n        from parsl import join_app, python_app\n\n        @python_app\n        def add(a, b):\n            return a + b\n\n        @python_app\n        def make_more(val):\n            return [val] * random.randint(2, 5)\n\n        @join_app\n        def add_distributed(vals, c):\n            return [add(val, c) for val in vals]\n\n        def workflow(a, b, c):\n            result1 = add(a, b)\n            result2 = make_more(result1)\n            return add_distributed(result2, c)\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Prefect\"\n\n        ```python\n        import random\n        from prefect import flow, task\n\n        @task\n        def add(a, b):\n            return a + b\n\n        @task\n        def make_more(val):\n            return [val] * random.randint(2, 5)\n\n        @flow\n        def add_distributed(vals, c):\n            return [add(val, c) for val in vals]\n\n        @flow\n        def workflow(a, b, c):\n            result1 = add.submit(a, b)\n            result2 = make_more.submit(result1)\n            return add_distributed(result2, c)\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Redun\"\n\n        ```python\n        import random\n        from redun import task\n\n        @task\n        def add(a, b):\n            return a + b\n\n        @task\n        def make_more(val):\n            return [val] * random.randint(2, 5)\n\n        @task\n        def add_distributed(vals, c):\n            return [add(val, c) for val in vals]\n\n        @task\n        def workflow(a, b, c):\n            result1 = add(a, b)\n            result2 = make_more(result1)\n            return add_distributed(result2, c)\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Jobflow\"\n\n        !!! Warning\n\n            This decorator is not meant to be used with Jobflow at this time.\n\n    Parameters\n    ----------\n    _func\n        The function to decorate. This is not meant to be supplied by the user.\n    **kwargs\n        Keyword arguments to pass to the decorator.\n\n    Returns\n    -------\n    callable\n        The decorated function.\n    \"\"\"\n\n    from quacc import SETTINGS\n\n    if _func is None:\n        return functools.partial(subflow, **kwargs)\n\n    wflow_engine = SETTINGS.WORKFLOW_ENGINE\n    if wflow_engine == \"covalent\":\n        import covalent as ct\n\n        decorated = ct.electron(ct.lattice(_func, **kwargs))\n    elif wflow_engine == \"parsl\":\n        from parsl import join_app\n\n        decorated = join_app(_func, **kwargs)\n    elif wflow_engine == \"redun\":\n        from redun import task as redun_task\n\n        decorated = redun_task(_func, **kwargs)\n    elif wflow_engine == \"prefect\":\n        from prefect import flow as prefect_flow\n\n        decorated = prefect_flow(_func, **kwargs)\n    else:\n        decorated = _func\n\n    return decorated\n</code></pre>"},{"location":"reference/quacc/wflow/prefect.html","title":"prefect","text":"<p>Utilities for Prefect.</p>"},{"location":"reference/quacc/wflow/prefect.html#quacc.wflow.prefect.make_prefect_runner","title":"make_prefect_runner","text":"<pre><code>make_prefect_runner(\n    cluster_kwargs,\n    cluster_class=None,\n    adapt_kwargs=None,\n    client_kwargs=None,\n    temporary=False,\n)\n</code></pre> <p>Make a <code>DaskTaskRunner</code> for use with Prefect workflows.</p> <p>Parameters:</p> <ul> <li> <code>cluster_kwargs</code>             (<code>dict</code>)         \u2013          <p>Keyword arguments to pass to <code>cluster_class</code>.</p> </li> <li> <code>cluster_class</code>             (<code>Callable | None</code>, default:                 <code>None</code> )         \u2013          <p>The Dask cluster class to use. Defaults to <code>dask_jobqueue.SLURMCluster</code>.</p> </li> <li> <code>adapt_kwargs</code>             (<code>dict[str, int | None] | None</code>, default:                 <code>None</code> )         \u2013          <p>Keyword arguments to pass to <code>cluster.adapt</code> of the form <code>{\"minimum\": int, \"maximum\": int}</code>. If <code>None</code>, no adaptive scaling will be done.</p> </li> <li> <code>client_kwargs</code>             (<code>dict | None</code>, default:                 <code>None</code> )         \u2013          <p>Keyword arguments to pass to <code>dask.distributed.Client</code>.</p> </li> <li> <code>temporary</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to use a temporary cluster. If <code>True</code>, the cluster will be terminated once the <code>Flow</code> is finished. If <code>False</code>, the cluster will run until the walltime is reached and can run multiple <code>Flow</code>s.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DaskTaskRunner</code>         \u2013          <p>A DaskTaskRunner object for use with Prefect workflows.</p> </li> </ul> Source code in <code>quacc/wflow/prefect.py</code> <pre><code>@requires(prefect_deps and dask_deps, \"Need quacc[prefect] dependencies\")\ndef make_prefect_runner(\n    cluster_kwargs: dict,\n    cluster_class: Callable | None = None,\n    adapt_kwargs: dict[str, int | None] | None = None,\n    client_kwargs: dict | None = None,\n    temporary: bool = False,\n) -&gt; DaskTaskRunner:\n    \"\"\"\n    Make a `DaskTaskRunner` for use with Prefect workflows.\n\n    Parameters\n    ----------\n    cluster_kwargs\n        Keyword arguments to pass to `cluster_class`.\n    cluster_class\n        The Dask cluster class to use. Defaults to `dask_jobqueue.SLURMCluster`.\n    adapt_kwargs\n        Keyword arguments to pass to `cluster.adapt` of the form `{\"minimum\": int, \"maximum\": int}`.\n        If `None`, no adaptive scaling will be done.\n    client_kwargs\n        Keyword arguments to pass to `dask.distributed.Client`.\n    temporary\n        Whether to use a temporary cluster. If `True`, the cluster will be\n        terminated once the `Flow` is finished. If `False`, the cluster will\n        run until the walltime is reached and can run multiple `Flow`s.\n\n    Returns\n    -------\n    DaskTaskRunner\n        A DaskTaskRunner object for use with Prefect workflows.\n    \"\"\"\n\n    if cluster_class is None:\n        cluster_class = SLURMCluster\n\n    # Make the one-time-use DaskTaskRunner\n    if temporary:\n        return DaskTaskRunner(\n            cluster_class=cluster_class,\n            cluster_kwargs=cluster_kwargs,\n            adapt_kwargs=adapt_kwargs,\n            client_kwargs=client_kwargs,\n        )\n\n    # Make the Dask cluster\n    cluster = _make_dask_cluster(cluster_class, cluster_kwargs)\n\n    # Set up adaptive scaling\n    if adapt_kwargs and (adapt_kwargs[\"minimum\"] or adapt_kwargs[\"maximum\"]):\n        cluster.adapt(minimum=adapt_kwargs[\"minimum\"], maximum=adapt_kwargs[\"maximum\"])\n\n    # Return the DaskTaskRunner with the cluster address\n    return DaskTaskRunner(address=cluster.scheduler_address)\n</code></pre>"},{"location":"user/advanced/atomate2.html","title":"Quacc + Atomate2","text":"<p>Atomate2 is a computational materials science workflow program that shares many similarities with quacc. If you wish to combine workflows from quacc with those from Atomate2, that is possible through the use of Jobflow.</p> <p>Tip</p> <p>Refer to the Using a Workflow Engine guide for more information on how to use Jobflow with quacc.</p> <p>For instance, consider a toy example where you want to relax a bulk Cu structure using the <code>tblite</code> calculator in quacc, which you then use to run a VASP relaxation and bandstructure workflow in Atomate2. That would look like the following.</p> <pre><code>from ase.build import bulk\nfrom atomate2.vasp.flows.core import RelaxBandStructureMaker\nfrom jobflow import Flow\nfrom quacc.recipes.tblite.core import relax_job\n\natoms = bulk(\"Cu\")\n\njob1 = relax_job(atoms)\nbandstructure_flow = RelaxBandStructureMaker().make_flow(\n    job1.output[\"structure\"]\n)  # (1)!\n\nflow = Flow([job1]) + bandstructure_flow  # (2)!\n</code></pre> <ol> <li> <p>All Atomate2 workflows take a Pymatgen <code>Structure</code> or <code>Molecule</code> object as input. This is one of the properties in the returned output of a quacc recipe, which is why we can do <code>job1.output[\"structure\"]</code>.</p> </li> <li> <p>The <code>+</code> operator can be used to combine two flows into one. We converted the first job into its own <code>Flow</code> definition to enable this.</p> </li> </ol>"},{"location":"user/advanced/database.html","title":"Using a Database","text":"<p>Oftentimes, it is beneficial to store the results in a database for easy querying (like the example below). This is quite simple to do in quacc regardless of the workflow manager you are using by taking advantage of the numerous data store options in maggma. For details on how to set up a Mongo database, refer to the corresponding Maggma tutorial</p> <p></p> General PurposeCovalentJobflow <p>Automated Approach</p> <p>For a given recipe, you can have quacc automatically store the final output summaries in your desired database by defining a Maggma data store in the <code>PRIMARY_STORE</code> quacc setting.</p> <p>For instance, let's pretend you have decided to make a <code>MongoStore</code> be your database of choice. After defining or loading your Maggma store, you would call <code>.to_json()</code> to get a dictionary representation. You can then store this JSON, formatted as a string, in the <code>PRIMARY_STORE</code> global quacc setting.</p> <pre><code>from maggma.stores import MongoStore\n\nstore = MongoStore(\n    \"my_db_name\",\n    \"my_collection_name\",\n    username=\"my_username\",\n    password=\"my_password\",\n    host=\"localhost\",\n    port=27017,\n)\nprint(store.to_json())  # This is the JSON string you would store in PRIMARY_STORE\n</code></pre> ~/.quacc.yaml<pre><code>PRIMARY_STORE: '{\"@module\": \"maggma.stores.mongolike\", \"@class\": \"MongoStore\", \"@version\": \"0.51.19\", \"database\": \"my_db_name\", \"collection_name\": \"my_collection_name\", \"host\": \"localhost\", \"port\": 27017, \"username\": \"my_username\", \"password\": \"my_password\", \"ssh_tunnel\": null, \"safe_update\": false, \"auth_source\": \"my_db_name\", \"mongoclient_kwargs\": {}, \"default_sort\": null}'\n</code></pre> <p>Manual Approach</p> <p>If you would prefer to store results in your database manually (perhaps because you are limited in terms of how much data you can store), you can use the quacc.wflow.db.results_to_db function, as shown in the example below.</p> <pre><code>from maggma.stores import MongoStore\nfrom quacc.wflow.db import results_to_db\n\n# Let `results` be an output (or list of outputs) from quacc recipes\n\n# Define your database details\nstore = MongoStore(\n    \"my_db_name\",\n    \"my_collection_name\",\n    username=\"my_username\",\n    password=\"my_password\",\n    host=\"localhost\",\n    port=27017,\n)\n\n# Store the results\nresults_to_db(store, results)\n</code></pre> <p>Covalent automatically stores all the inputs and outputs in an SQLite database, which you can find at the <code>\"db_path\"</code> when you run <code>covalent config</code>, and the results can be queried using the <code>ct.get_result(&lt;dispatch ID&gt;)</code> syntax. However, if you want to store the results in a different database of your choosing, you can do so quite easily.</p> <p>An example is shown below for storing the results in your custom database via the quacc.wflow.db.covalent_to_db function.</p> <pre><code>from maggma.stores import MongoStore\nfrom quacc.wflow.db import covalent_to_db\n\n# Define your database credentials\nstore = MongoStore(\n    \"my_db_name\",\n    \"my_collection_name\",\n    username=\"my_username\",\n    password=\"my_password\",\n    host=\"localhost\",\n    port=27017,\n)\n\n# Store the results\ncovalent_to_db(store)\n</code></pre> <p>If you are using Jobflow to construct your workflows, it will automatically store the results in the database you defined during the setup process. No additional steps are needed.</p>"},{"location":"user/advanced/file_transfers.html","title":"Transferring Files","text":""},{"location":"user/advanced/file_transfers.html#local-file-transfers","title":"Local File Transfers","text":""},{"location":"user/advanced/file_transfers.html#transfers-from-a-known-file-location","title":"Transfers from a Known File Location","text":"<p>Sometimes, you may want to transfer files between jobs. Every recipe within quacc takes an optional keyword argument <code>copy_files</code> that is a list of absolute filepaths to files you wish to have copied to the directory where the calculation is ultimately run.</p> <p>For instance, if you have a file <code>WAVECAR</code> stored in <code>/path/to/my/file/stage</code>, then you could ensure that is present in the calculation's working directory:</p> <pre><code>from pathlib import Path\nfrom ase.build import bulk\nfrom quacc.recipes.vasp.core import relax_job\n\natoms = bulk(\"Cu\")\nrelax_job(atoms, copy_files=[Path(\"path/to/my/file/stage/WAVECAR\")])\n</code></pre>"},{"location":"user/advanced/file_transfers.html#transfers-between-jobs","title":"Transfers Between Jobs","text":"<p>Sometimes, however, you may not necessarily know a priori where the source file is. For instance, perhaps you want to copy the file <code>WAVECAR</code> from a previous job in your workflow that is stored in a unique directory only determined at runtime. In this scenario, you can still use the <code>copy_files</code> keyword argument, but you will need to fetch the prior job's directory.</p> <pre><code>from pathlib import Path\nfrom ase.build import bulk\nfrom quacc.recipes.vasp.core import relax_job, static_job\n\natoms = bulk(\"Cu\")\nresults1 = relax_job(atoms)\nstatic_job(results1, copy_files=[Path(results1[\"dir_name\"], \"WAVECAR\")])\n</code></pre>"},{"location":"user/advanced/file_transfers.html#non-local-file-transfers","title":"Non-Local File Transfers","text":"<p>If using quacc across distributed computing environments, there may not be a guarantee that the file you wish to transfer is even on the same machine as your current job. In this scenario, the best approach is to create a dedicated file staging area on your machine of choice where you can store files you wish to transfer.</p> <p>For instance, if using a job scheduler like Slurm, you could have a step in your job script that copies files (e.g. via <code>scp</code>) from a remote location to a local staging area. Then, you can use the <code>copy_files</code> keyword argument to copy the files from the staging area to the calculation's working directory.</p> <p>Alternatively, several of the supported workflow managers have built-in options to enable file staging.</p>"},{"location":"user/basics/wflow_overview.html","title":"Workflow Engines Overview","text":"<p>Everyone's computing needs are different, so we ensured that quacc is interoperable with a variety of modern workflow management tools. There are 300+ workflow management tools out there, so we can't possibly support them all. Instead, we have focused on a select few that adopt a similar decorator-based approach to defining workflows with substantial support for HPC systems.</p>"},{"location":"user/basics/wflow_overview.html#summary","title":"Summary","text":"<p>Tip</p> <p>If you are new to workflow engines, we recommend trying either Parsl or Covalent. If you have a need for speed and appreciate flexibility, Parsl is the choice for you. If you are looking for a visual dashboard with an emphasis on distributed compute resources, Covalent may be worth considering.</p> Parsl \u2b50Covalent \u2b50PrefectRedunJobflow <p>Parsl is a workflow management solution out of Argonne National Laboratory, the University of Chicago, and the University of Illinois. It is well-adapted for running on virtually any HPC environment with a job scheduler.</p> <p>Pros:</p> <ul> <li>Extremely configurable and deployable for virtually any HPC environment</li> <li>Quite simple to define the workflows</li> <li>Active community, particularly across academia</li> <li>Well-suited for pilot jobs and advanced queuing schemes</li> <li>Thorough documentation</li> <li>Does not rely on maintaining a centralized server</li> </ul> <p>Cons:</p> <ul> <li>The number of different terms can be slightly overwhelming to those less familiar with HPC</li> <li>Understanding the various configuration options for your HPC setup can be an initial hurdle</li> <li>Monitoring job progress is more challenging and less detailed than other solutions</li> <li>The concept of always returning a \"future\" can be confusing for new users</li> </ul> <p>Covalent is a workflow management solution from the company Agnostiq.</p> <p>Pros:</p> <ul> <li>Best-in-class visual dashboard for job monitoring</li> <li>Easy to use in distributed, heterogeneous compute environments</li> <li>Excellent documentation</li> <li>Automatic and simple database integration</li> <li>The compute nodes do not need to be able to connect to the internet, unlike some of its competitors</li> </ul> <p>Cons:</p> <ul> <li>Not as widely used as other workflow management solutions</li> <li>Only supports standard queuing schemes, limiting throughput</li> <li>It requires a centralized server to be running continuously in order to manage the workflows</li> <li>High-security HPC environments may be difficult to access via SSH with the centralized server approach</li> </ul> <p>Warning</p> <p>Prefect support is currently unavailable until Issue 1013 is closed.</p> <p>Prefect is a workflow management system that is widely adopted in the data science industry.</p> <p>Pros:</p> <ul> <li>Very popular in the data science industry with an active community</li> <li>Has a nice dashboard to monitor job progress</li> <li>Supports a variety of job schedulers via <code>dask-jobqueue</code></li> <li>Uses a directed acyclic graph-free model for increased flexibility in workflow definitions</li> </ul> <p>Cons:</p> <ul> <li>Has limited documentation and features for HPC environments</li> <li>Not practical to use if the compute nodes do not support network connections</li> <li>The dashboard stores data for only a 7 day history by default and does not display the full output of each task</li> <li>Sorting out the details of agents, workers, and queues can be challenging</li> <li>The concept of always returning a \"future\" object can be confusing for new users</li> </ul> <p>Redun is a flexible workflow management program developed by Insitro.</p> <p>Pros:</p> <ul> <li>Extremely simple syntax for defining workflows</li> <li>Has strong support for task/result caching</li> <li>Useful console-based monitoring system</li> </ul> <p>Cons:</p> <ul> <li>Currently lacks support for typical HPC job schedulers and platforms other than AWS</li> <li>No user-friendly GUI for job monitoring</li> <li>Less active user community than some other options</li> </ul> <p>Jobflow is developed and maintained by the Materials Project team at Lawrence Berkeley National Laboratory and serves as a seamless interface to FireWorks for dispatching and monitoring compute jobs.</p> <p>Jobflow</p> <p>Pros:</p> <ul> <li>Native support for a variety of databases</li> <li>Directly compatible with Atomate2</li> <li>Designed with materials science in mind</li> <li>Actively supported by the Materials Project team</li> </ul> <p>Cons:</p> <ul> <li>Is not compatible with the <code>@flow</code> decorator used in some quacc recipes</li> <li>Parsing the output of a workflow is not as intuitive as other solutions</li> <li>Defining dynamic workflows with Jobflow's <code>Response</code> object can be more complex than other solutions</li> <li>Only supports FireWorks for job dispatching at the moment</li> </ul> <p>FireWorks:</p> <p>Pros:</p> <ul> <li>Well-suited for a variety of job management approaches</li> <li>Helpful dashboard for monitoring job progress</li> </ul> <p>Cons:</p> <ul> <li>FireWorks documentation can be difficult to navigate without prior experience</li> <li>FireWorks can have a steep learning curve due to its many configuration options</li> <li>The reliance on MongoDB can be challenging for new users and certain HPC environments</li> <li>New features are not planned</li> </ul>"},{"location":"user/basics/wflow_syntax.html","title":"Workflow Syntax","text":""},{"location":"user/basics/wflow_syntax.html#introduction","title":"Introduction","text":"<p>Here, we provide code snippets for several decorator-based workflow engines. For a comparison of the pros and cons of each approach, refer to the Workflow Engines Overview page. We describe the specifics of how to use each workflow engine in more detail later in the documentation.</p>"},{"location":"user/basics/wflow_syntax.html#background","title":"Background","text":"<p>To help enable interoperability between workflow engines, quacc offers a unified set of decorators: <code>@job</code>, <code>@flow</code>, and <code>@subflow</code>.</p> Parsl \u2b50Covalent \u2b50PrefectRedunJobflow <p>Take a moment to read the Parsl documentation's \"Quick Start\" to get a sense of how Parsl works. Namely, you should understand the concept of a <code>python_app</code> and <code>join_app</code>, which describe individual compute tasks and dynamic job tasks, respectively.</p> <p> Quacc Parsl <code>@job</code> <code>@python_app</code> <code>@flow</code> No effect <code>@subflow</code> <code>@join_app</code> <p></p> <p>Take a moment to learn about the main Covalent Concepts, namely the <code>@ct.electron</code> and <code>@ct.lattice</code> decorators, which describe individual compute tasks and workflows, respectively.</p> <p> Quacc Covalent <code>@job</code> <code>@ct.electron</code> <code>@flow</code> <code>@ct.lattice</code> <code>@subflow</code> <code>@ct.electron</code><code>@ct.lattice</code> <p></p> <p>Take a moment to read the Prefect documentation's to get a sense of how it works. Namely, you should understand the <code>Task</code> and <code>Flow</code> decorators as well as how to interface with the server.</p> <p> Quacc Prefect <code>@job</code> <code>@task</code> <code>@flow</code> <code>@flow</code> <code>@subflow</code> <code>@flow</code> <p></p> <p>Take a moment to read the Redun documentation's Design Overview page to get a sense of how Redun works. Namely, you should understand the <code>Task</code> decorator and how to interface with the <code>Scheduler</code>.</p> <p> Quacc Redun <code>@job</code> <code>@task</code> <code>@flow</code> <code>@task</code> <code>@subflow</code> <code>@task</code> <p></p> <p>Take a moment to read the Jobflow documentation's Quick Start to get a sense of how Jobflow works. Namely, you should understand the <code>Job</code> and <code>Flow</code> definitions, which describe individual compute tasks and workflows, respectively.</p> <p> Quacc Jobflow <code>@job</code> <code>@job</code> <code>@flow</code> N/A <code>@subflow</code> N/A <p></p> <p>Warning</p> <p>Due to the difference in how Jobflow handles workflows compared to other supported workflow engines, any quacc recipes that have been pre-defined with a <code>@flow</code> or <code>@subflow</code> decorator (i.e. have <code>_flow</code> in the name) cannot be run directly with Jobflow.</p> <p>The quacc descriptors are drop-in replacements for the specified workflow engine analogue, which we will use for the remainder of the tutorials. Based on the value for the <code>WORKFLOW_ENGINE</code> global variable in your quacc settings, the appropriate decorator will be automatically selected. If the <code>WORKFLOW_ENGINE</code> setting is set to <code>\"local\"</code>, the decorators will have no effect on the underlying function.</p>"},{"location":"user/basics/wflow_syntax.html#simple-workflow","title":"Simple Workflow","text":"<p>Let's do the following:</p> <ol> <li>Add two numbers (e.g. <code>1 + 2</code>)</li> <li>Multiply the output of Step 1 by a third number (e.g. <code>3 * 3</code>)</li> </ol> <p>In practice, we would want each of the two tasks to be their own compute job.</p> <pre><code>graph LR\n  A[Input] --&gt; B(add) --&gt; C(mult) --&gt; D[Output];</code></pre> Parsl \u2b50Covalent \u2b50PrefectRedunJobflow <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable and load the default Parsl configuration:</p> <pre><code>quacc set WORKFLOW_ENGINE parsl\n</code></pre> python<pre><code>import parsl\n\nparsl.load()  #  (1)!\n</code></pre> <ol> <li>It is necessary to instantiate a Parsl configuration before running Parsl workflows. This command loads the default (local) configuration and only needs to be done once.</li> </ol> <pre><code>from quacc import job\n\n\n@job  #  (1)!\ndef add(a, b):\n    return a + b\n\n\n@job\ndef mult(a, b):\n    return a * b\n\n\ndef workflow(a, b, c):  #  (2)!\n    return mult(add(a, b), c)\n\n\nresult = workflow(1, 2, 3).result()  # 9\nprint(result)\n</code></pre> <ol> <li> <p>The <code>@job</code> decorator will be transformed into <code>@python_app</code>.</p> </li> <li> <p>The <code>@flow</code> decorator doesn't actually do anything when using Parsl, so we chose to not include it here for brevity.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable and start the Covalent server:</p> <pre><code>quacc set WORKFLOW_ENGINE covalent\ncovalent start\n</code></pre> <pre><code>import covalent as ct\nfrom quacc import flow, job\n\n\n@job  #  (1)!\ndef add(a, b):\n    return a + b\n\n\n@job\ndef mult(a, b):\n    return a * b\n\n\n@flow  #  (2)!\ndef workflow(a, b, c):\n    return mult(add(a, b), c)\n\n\ndispatch_id = ct.dispatch(workflow)(1, 2, 3)\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <ol> <li> <p>The <code>@job</code> decorator will be transformed into <code>@ct.electron</code>.</p> </li> <li> <p>The <code>@flow</code> decorator will be transformed into <code>@ct.lattice</code>.</p> </li> <li> <p>This commmand will dispatch the workflow to the Covalent server.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable:</p> <pre><code>quacc set WORKFLOW_ENGINE prefect\n</code></pre> <pre><code>from quacc import flow, job\n\n\n@job  #  (1)!\ndef add(a, b):\n    return a + b\n\n\n@job\ndef mult(a, b):\n    return a * b\n\n\n@flow  #  (2)!\ndef workflow(a, b, c):\n    return mult(add(a, b), c)\n\n\nfuture = workflow(1, 2, 3)\nresult = future.result()\nprint(result)\n</code></pre> <ol> <li> <p>The <code>@job</code> decorator will be transformed into a Prefect <code>@task</code>.</p> </li> <li> <p>The <code>@flow</code> decorator will be transformed into a Prefect-compatible <code>@flow</code>.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable:</p> <pre><code>quacc set WORKFLOW_ENGINE redun\n</code></pre> <pre><code>from redun import Scheduler\nfrom quacc import flow, job\n\nscheduler = Scheduler()  #  (1)!\n\n\n@job  #  (2)!\ndef add(a, b):\n    return a + b\n\n\n@job\ndef mult(a, b):\n    return a * b\n\n\n@flow  #  (3)!\ndef workflow(a, b, c):\n    return mult(add(a, b), c)\n\n\nresult = scheduler.run(workflow(1, 2, 3))\nprint(result)\n</code></pre> <ol> <li> <p>It is necessary to instantiate the scheduler before submitting calculations.</p> </li> <li> <p>The <code>@job</code> decorator will be transformed into a Redun <code>@task</code>.</p> </li> <li> <p>The <code>@flow</code> decorator will also be transformed into a Redun <code>@task</code>. Everything in Redun is a <code>@task</code>, so it doesn't matter what quacc decorator you apply. We chose <code>@flow</code> simply for clarity.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable:</p> <pre><code>quacc set WORKFLOW_ENGINE jobflow\n</code></pre> <pre><code>import jobflow as jf\nfrom quacc import job\n\n\n@job  #  (1)!\ndef add(a, b):\n    return a + b\n\n\n@job\ndef mult(a, b):\n    return a * b\n\n\njob1 = add(1, 2)\njob2 = mult(job1.output, 3)\nflow = jf.Flow([job1, job2])\n\nresponses = jf.run_locally(flow)\nresult = responses[job2.uuid][1].output\nprint(result)\n</code></pre> <ol> <li>The <code>@job</code> decorator will be transformed into <code>@jf.job</code>.</li> </ol>"},{"location":"user/basics/wflow_syntax.html#stripping-the-decorator-from-a-job","title":"Stripping the Decorator from a Job","text":"<p>If you ever want to strip the decorator from a pre-decorated <code>@job</code> for any reason, you can call the <code>.__wrapped__</code> attribute. This returns the original function.</p> <pre><code>from quacc import job\n\n\n@job\ndef add(a, b):\n    return a + b\n\n\nadd.__wrapped__(1, 2)\n</code></pre>"},{"location":"user/basics/wflow_syntax.html#learn-more","title":"Learn More","text":"Parsl \u2b50Covalent \u2b50PrefectRedunJobflow <p>If you want to learn more about Parsl, you can read the Parsl Documentation. Please refer to the Parsl Slack Channel for any Parsl-specific questions.</p> <p>If you want to learn more about Covalent, you can read the Covalent Documentation. Please refer to the Covalent Discussion Board for any Covalent-specific questions.</p> <p>If you want to learn more about Perfect, you can read the Prefect Documentation. Please refer to the Prefect Slack Channel and/or Prefect Community Discourse page for any Prefect-specific questions.</p> <p>If you want to learn more about Redun, you can read the Redun documentation.</p> <p>If you want to learn more about Jobflow, you can read the Jobflow Documentation. Please refer to the Jobflow Discussions Board for Jobflow-specific questions.</p>"},{"location":"user/recipes/recipes_intro.html","title":"Intro to Recipes","text":"<p>In quacc, each code comes with pre-packaged jobs and workflows, which we call recipes for short. This tutorial walks you through how to use these provided recipes to run simple calculations that can be tested out on your local machine.</p>"},{"location":"user/recipes/recipes_intro.html#pre-requisites","title":"Pre-Requisites","text":"<p>If you are not yet familiar with the ASE <code>Atoms</code> object, you should read the ASE tutorial. Additionally, it is worthwhile to be familiar with the basics of an ASE Calculator. The \"Open Science with ASE: Core Tutorials\" is also an excellent resource for learning about the basics of ASE.</p> <p>Note</p> <p>Since we are not using a workflow engine for these examples, run the following in the command line:</p> <pre><code>quacc set WORKFLOW_ENGINE local\n</code></pre>"},{"location":"user/recipes/recipes_intro.html#examples","title":"Examples","text":""},{"location":"user/recipes/recipes_intro.html#a-simple-calculation-with-emt","title":"A Simple Calculation with EMT","text":"<pre><code>graph LR\n  A[Input] --&gt; B(EMT Relax) --&gt; C[Output]</code></pre> <p>Let's start with a simple example. Here, we will use a cheap calculator based on effective medium theory (EMT) to run a structure relaxation on a bulk structure of copper. We are interested in doing a structure relaxation, so we will use the quacc.recipes.emt.core.relax_job recipe, as demonstrated below.</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Run a structure relaxation on the Atoms object\nresult = relax_job(atoms)\nprint(result)\n</code></pre> Info <pre><code>{\n    'atoms': Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]], initial_magmoms=...),\n    'atoms_info': {'_id': 'f8d53f110f524872f30a5cc20e8befb1'},\n    'builder_meta': {\n        'build_date': '2023-09-05 23:41:21.241450',\n        'database_version': None,\n        'emmet_version': '0.67.5',\n        'pull_request': None,\n        'pymatgen_version': '2023.9.2',\n    },\n    'chemsys': 'Cu',\n    'composition': Composition('Cu1'),\n    'composition_reduced': Composition('Cu1'),\n    'density': 8.971719800606017,\n    'density_atomic': 11.761470249999999,\n    'dir_name': '/home/rosen',\n    'elements': [Element Cu],\n    'formula_anonymous': 'A',\n    'formula_pretty': 'Cu',\n    'input_structure': {\n        'atoms': Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]], calculator=SinglePointCalculator(...)),\n        'atoms_info': {},\n        'builder_meta': {\n            'build_date': '2023-09-05 23:41:21.230016',\n            'database_version': None,\n            'emmet_version': '0.67.5',\n            'pull_request': None,\n            'pymatgen_version': '2023.9.2',\n        },\n        'chemsys': 'Cu',\n        'composition': Composition('Cu1'),\n        'composition_reduced': Composition('Cu1'),\n        'density': 8.971719800606017,\n        'density_atomic': 11.761470249999999,\n        'elements': [Element Cu],\n        'formula_anonymous': 'A',\n        'formula_pretty': 'Cu',\n        'nelements': 1,\n        'nsites': 1,\n        'structure': Structure Summary\n        Lattice\n            abc : 2.5526554800834367 2.5526554800834367 2.5526554800834367\n        angles : 60.00000000000001 60.00000000000001 60.00000000000001\n        volume : 11.761470249999999\n            A : 0.0 1.805 1.805\n            B : 1.805 0.0 1.805\n            C : 1.805 1.805 0.0\n            pbc : True True True\n        PeriodicSite: Cu (0.0, 0.0, 0.0) [0.0, 0.0, 0.0],\n        'symmetry': {\n            'crystal_system': &lt;CrystalSystem.cubic: 'Cubic'&gt;,\n            'number': 225,\n            'point_group': 'm-3m',\n            'symbol': 'Fm-3m',\n            'symprec': 0.1,\n            'version': '2.0.2',\n        },\n        'volume': 11.761470249999999,\n    },\n    'name': 'EMT Relax',\n    'nelements': 1,\n    'nid': 'rosen.',\n    'nsites': 1,\n    'parameters': {'asap_cutoff': False},\n    'parameters_opt': {\n        'fmax': 0.01,\n        'max_steps': 1000,\n        'maxstep': 0.2,\n        'optimizer': 'FIRE',\n        'restart': None,\n        'type': 'optimization',\n    },\n    'results': {\n        'converged': True,\n        'energies': array([-0.00568151]),\n        'energy': -0.005681511358588409,\n        'forces': array([[0., 0., 0.]]),\n        'free_energy': -0.005681511358588409,\n        'nsteps': 0,\n    },\n    'structure': Structure Summary\n    Lattice\n        abc : 2.5526554800834367 2.5526554800834367 2.5526554800834367\n    angles : 60.00000000000001 60.00000000000001 60.00000000000001\n    volume : 11.761470249999999\n        A : 0.0 1.805 1.805\n        B : 1.805 0.0 1.805\n        C : 1.805 1.805 0.0\n        pbc : True True True\n    PeriodicSite: Cu (0.0, 0.0, 0.0) [0.0, 0.0, 0.0],\n    'symmetry': {\n        'crystal_system': &lt;CrystalSystem.cubic: 'Cubic'&gt;,\n        'number': 225,\n        'point_group': 'm-3m',\n        'symbol': 'Fm-3m',\n        'symprec': 0.1,\n        'version': '2.0.2',\n    },\n    'trajectory': [\n        {\n            'atoms': Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]], calculator=SinglePointCalculator(...)),\n            'atoms_info': {},\n            'builder_meta': {\n                'build_date': '2023-09-05 23:41:21.227911',\n                'database_version': None,\n                'emmet_version': '0.67.5',\n                'pull_request': None,\n                'pymatgen_version': '2023.9.2',\n            },\n            'chemsys': 'Cu',\n            'composition': Composition('Cu1'),\n            'composition_reduced': Composition('Cu1'),\n            'density': 8.971719800606017,\n            'density_atomic': 11.761470249999999,\n            'elements': [Element Cu],\n            'formula_anonymous': 'A',\n            'formula_pretty': 'Cu',\n            'nelements': 1,\n            'nsites': 1,\n            'structure': Structure Summary\n            Lattice\n                abc : 2.5526554800834367 2.5526554800834367 2.5526554800834367\n            angles : 60.00000000000001 60.00000000000001 60.00000000000001\n            volume : 11.761470249999999\n                A : 0.0 1.805 1.805\n                B : 1.805 0.0 1.805\n                C : 1.805 1.805 0.0\n                pbc : True True True\n            PeriodicSite: Cu (0.0, 0.0, 0.0) [0.0, 0.0, 0.0],\n            'symmetry': {\n                'crystal_system': &lt;CrystalSystem.cubic: 'Cubic'&gt;,\n                'number': 225,\n                'point_group': 'm-3m',\n                'symbol': 'Fm-3m',\n                'symprec': 0.1,\n                'version': '2.0.2',\n            },\n            'volume': 11.761470249999999,\n        },\n    ],\n    'trajectory_results': [\n        {\n            'energies': array([-0.00568151]),\n            'energy': -0.005681511358588409,\n            'forces': array([[0., 0., 0.]]),\n            'free_energy': -0.005681511358588409,\n        },\n    ],\n    'volume': 11.761470249999999,\n}\n</code></pre>"},{"location":"user/recipes/recipes_intro.html#a-simple-mixed-code-workflow","title":"A Simple Mixed-Code Workflow","text":"<pre><code>graph LR\n  A[Input] --&gt; B(EMT Relax) --&gt; C(GFN2-xTB Static) --&gt; D[Output]</code></pre> <p>Now let's return to our bulk Cu example from above and start adding on some complexity. Here, we will use EMT to run a relaxation on the bulk Cu structure and then use the output of this calculation as the input to a static calculation with the semi-empirical quantum mechanics method GFN2-xTB as implemented in quacc.recipes.tblite.core.static_job. This example highlights how there are no restrictions in terms of how many codes you can use in a single workflow.</p> <p>Note</p> <p>Some codes require additional setup, including <code>tblite</code> (which can only be <code>pip</code> installed on Linux). Refer to the Calculator Setup section for details.</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.tblite.core import static_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Run a structure relaxation with EMT\nresult1 = relax_job(atoms)\n\n# Run a static calculation with GFN2-xTB\nresult2 = static_job(result1, method=\"GFN2-xTB\")\nprint(result2)\n</code></pre> Info <pre><code>{\n    'atoms': Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]], initial_magmoms=...),\n    'atoms_info': {\n        '_id': 'f8d53f110f524872f30a5cc20e8befb1',\n        '_old_ids': ['f8d53f110f524872f30a5cc20e8befb1'],\n    },\n    'builder_meta': {\n        'build_date': '2023-09-05 23:42:04.661663',\n        'database_version': None,\n        'emmet_version': '0.67.5',\n        'pull_request': None,\n        'pymatgen_version': '2023.9.2',\n    },\n    'chemsys': 'Cu',\n    'composition': Composition('Cu1'),\n    'composition_reduced': Composition('Cu1'),\n    'density': 8.971719800606017,\n    'density_atomic': 11.761470249999999,\n    'dir_name': '/home/rosen',\n    'elements': [Element Cu],\n    'formula_anonymous': 'A',\n    'formula_pretty': 'Cu',\n    'input_atoms': {\n        'atoms': Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]], initial_magmoms=..., calculator=TBLite(...)),\n        'atoms_info': {'_id': 'f8d53f110f524872f30a5cc20e8befb1'},\n        'builder_meta': {\n            'build_date': '2023-09-05 23:42:04.659582',\n            'database_version': None,\n            'emmet_version': '0.67.5',\n            'pull_request': None,\n            'pymatgen_version': '2023.9.2',\n        },\n        'chemsys': 'Cu',\n        'composition': Composition('Cu1'),\n        'composition_reduced': Composition('Cu1'),\n        'density': 8.971719800606017,\n        'density_atomic': 11.761470249999999,\n        'elements': [Element Cu],\n        'formula_anonymous': 'A',\n        'formula_pretty': 'Cu',\n        'nelements': 1,\n        'nsites': 1,\n        'structure': Structure Summary\n        Lattice\n            abc : 2.5526554800834367 2.5526554800834367 2.5526554800834367\n        angles : 60.00000000000001 60.00000000000001 60.00000000000001\n        volume : 11.761470249999999\n            A : 0.0 1.805 1.805\n            B : 1.805 0.0 1.805\n            C : 1.805 1.805 0.0\n            pbc : True True True\n        PeriodicSite: Cu (0.0, 0.0, 0.0) [0.0, 0.0, 0.0],\n        'symmetry': {\n            'crystal_system': &lt;CrystalSystem.cubic: 'Cubic'&gt;,\n            'number': 225,\n            'point_group': 'm-3m',\n            'symbol': 'Fm-3m',\n            'symprec': 0.1,\n            'version': '2.0.2',\n        },\n        'volume': 11.761470249999999,\n    },\n    'name': 'TBLite Static',\n    'nelements': 1,\n    'nid': 'rosen.',\n    'nsites': 1,\n    'parameters': {\n        'accuracy': 1.0,\n        'cache_api': True,\n        'electronic_temperature': 300.0,\n        'max_iterations': 250,\n        'method': 'GFN2-xTB',\n        'verbosity': 1,\n    },\n    'results': {\n        'charges': array([-4.63948879e-11]),\n        'dipole': array([-7.99564819e-08,  1.96234891e-07, -5.12273395e-08]),\n        'energy': -318.8584605831406,\n        'forces': array([[5.44452313e-20, 5.39007790e-19, 2.45003541e-19]]),\n        'free_energy': -318.8584605831406,\n        'stress': array([14.65181119, 14.65181119, 14.65181119,  1.40704868,  1.01943286,\n                0.63181703]),\n    },\n    'structure': Structure Summary\n    Lattice\n        abc : 2.5526554800834367 2.5526554800834367 2.5526554800834367\n    angles : 60.00000000000001 60.00000000000001 60.00000000000001\n    volume : 11.761470249999999\n        A : 0.0 1.805 1.805\n        B : 1.805 0.0 1.805\n        C : 1.805 1.805 0.0\n        pbc : True True True\n    PeriodicSite: Cu (0.0, 0.0, 0.0) [0.0, 0.0, 0.0],\n    'symmetry': {\n        'crystal_system': &lt;CrystalSystem.cubic: 'Cubic'&gt;,\n        'number': 225,\n        'point_group': 'm-3m',\n        'symbol': 'Fm-3m',\n        'symprec': 0.1,\n        'version': '2.0.2',\n    },\n    'volume': 11.761470249999999,\n}\n</code></pre>"},{"location":"user/recipes/recipes_intro.html#concluding-comments","title":"Concluding Comments","text":"<p>At this point, you now have the basic idea of how quacc recipes work. If you don't care about using a workflow engine, feel free to write simple quacc-based Python scripts and submit them as-is using your favorite computing machine. However, if you are looking to efficiently scale up and monitor large numbers of workflows, continue reading!</p>"},{"location":"user/recipes/recipes_list.html","title":"List of Recipes","text":""},{"location":"user/recipes/recipes_list.html#dftb","title":"DFTB+","text":"<p>Note</p> <p>DFTB+ is especially useful for periodic GFN-xTB calculations and the DFTB+ method based on Slater-Koster parameters.</p> <p> Name Decorator Documentation DFTB+ Static <code>@job</code> quacc.recipes.dftb.core.static_job DFTB+ Relax <code>@job</code> quacc.recipes.dftb.core.relax_job <p></p>"},{"location":"user/recipes/recipes_list.html#emt","title":"EMT","text":"<p>Note</p> <p>Effective medium theory (EMT) is a semi-empirical method for modeling solids that is predominantly used for prototyping workflows. Because it is solely for demonstration purposes, it only supports the following metals: Al, Ni, Cu, Pd, Ag, Pt, and Au.</p> <p> Name Decorator Documentation EMT Static <code>@job</code> quacc.recipes.emt.core.static_job EMT Relax <code>@job</code> quacc.recipes.emt.core.relax_job EMT Bulk to Defects <code>@flow</code> quacc.recipes.emt.defects.bulk_to_defects_flow EMT Bulk to Slabs <code>@flow</code> quacc.recipes.emt.slabs.bulk_to_slabs_flow <p></p>"},{"location":"user/recipes/recipes_list.html#gaussian","title":"Gaussian","text":"<p>Note</p> <p>Gaussian is an extremely popular molecular DFT code that is quite robust and easy to use.</p> <p> Name Decorator Documentation Gaussian Static <code>@job</code> quacc.recipes.gaussian.core.static_job Gaussian Relax <code>@job</code> quacc.recipes.gaussian.core.relax_job <p></p>"},{"location":"user/recipes/recipes_list.html#gulp","title":"GULP","text":"<p>Note</p> <p>GULP is especially useful for periodic GFN-FF calculations and force field methods. GULP can be downloaded and installed here.</p> <p> Name Decorator Documentation GULP Static <code>@job</code> quacc.recipes.gulp.core.static_job GULP Relax <code>@job</code> quacc.recipes.gulp.core.relax_job <p></p>"},{"location":"user/recipes/recipes_list.html#lennard-jones-potential","title":"Lennard-Jones Potential","text":"<p>Note</p> <p>Lennard Jones (LJ) is an empirical potential that is predominantly used for prototyping workflows for molecules.</p> <p> Name Decorator Documentation LJ Static <code>@job</code> quacc.recipes.lj.core.static_job LJ Relax <code>@job</code> quacc.recipes.lj.core.relax_job LJ Frequency <code>@job</code> quacc.recipes.lj.core.freq_job <p></p>"},{"location":"user/recipes/recipes_list.html#newtonnet","title":"NewtonNet","text":"<p>Note</p> <p>NewtonNet is a message passing network for deep learning of interatomic potentials and forces, as described here.</p> <p> Name Decorator Documentation NewtonNet Static <code>@job</code> quacc.recipes.newtonnet.core.static_job NewtonNet Relax <code>@job</code> quacc.recipes.newtonnet.core.relax_job NewtonNet Frequency <code>@job</code> quacc.recipes.newtonnet.core.freq_job NewtonNet TS <code>@job</code> quacc.recipes.newtonnet.ts.ts_job NewtonNet IRC <code>@job</code> quacc.recipes.newtonnet.ts.irc_job NewtonNet Quasi IRC <code>@job</code> quacc.recipes.newtonnet.ts.quasi_irc_job <p></p>"},{"location":"user/recipes/recipes_list.html#orca","title":"ORCA","text":"<p>Note</p> <p>ORCA is a free code that is especially useful for molecular DFT calculations with recently developed methods. ORCA can be downloaded and installed here.</p> <p> Name Decorator Documentation ORCA Static <code>@job</code> quacc.recipes.orca.core.static_job ORCA Relax <code>@job</code> quacc.recipes.orca.core.relax_job <p></p>"},{"location":"user/recipes/recipes_list.html#psi4","title":"Psi4","text":"<p>Note</p> <p>Psi4 is an open-source quantum chemistry electronic structure package.</p> <p> Name Decorator Documentation Psi4 Static <code>@job</code> quacc.recipes.psi4.core.static_job <p></p>"},{"location":"user/recipes/recipes_list.html#q-chem","title":"Q-Chem","text":"<p>Note</p> <p>Q-Chem is a powerful, general-purpose molecular DFT code with a variety of features.</p> <p> Name Decorator Documentation Q-Chem Static <code>@job</code> quacc.recipes.qchem.core.static_job Q-Chem Relax <code>@job</code> quacc.recipes.qchem.core.relax_job Q-Chem Internal Relax <code>@job</code> quacc.recipes.qchem.core.internal_relax_job Q-Chem Frequency <code>@job</code> quacc.recipes.qchem.core.freq_job Q-Chem TS <code>@job</code> quacc.recipes.qchem.ts.ts_job Q-Chem IRC <code>@job</code> quacc.recipes.qchem.ts.irc_job Q-Chem Quasi IRC <code>@job</code> quacc.recipes.qchem.ts.quasi_irc_job <p></p>"},{"location":"user/recipes/recipes_list.html#tblite","title":"TBLite","text":"<p>Note</p> <p>tblite is a code that interfaces with the xtb package for running GFN-xTB calculations.</p> <p> Name Decorator Documentation TBLite Static <code>@job</code> quacc.recipes.tblite.core.static_job TBLite Relax <code>@job</code> quacc.recipes.tblite.core.relax_job TBLite Frequency <code>@job</code> quacc.recipes.tblite.core.freq_job <p></p>"},{"location":"user/recipes/recipes_list.html#vasp","title":"VASP","text":"<p>Note</p> <p>VASP is a very widely used code for plane-wave, periodic DFT calculations. Quacc has built-in support for automatically fixing failed VASP jobs via Custodian.</p> <p> Name Decorator Documentation VASP Static <code>@job</code> quacc.recipes.vasp.core.static_job VASP Relax <code>@job</code> quacc.recipes.vasp.core.relax_job VASP Double Relax <code>@job</code> quacc.recipes.vasp.core.double_relax_job VASP Slab Static <code>@job</code> quacc.recipes.vasp.slabs.slab_static_job VASP Slab Relax <code>@job</code> quacc.recipes.vasp.slabs.slab_relax_job VASP Bulk to Slabs <code>@flow</code> quacc.recipes.vasp.slabs.bulk_to_slabs_flow VASP Slab to Adsorbates <code>@flow</code> quacc.recipes.vasp.slabs.slab_to_ads_flow VASP MP-Prerelax <code>@job</code> quacc.recipes.vasp.mp.mp_relax_job VASP MP-Relax <code>@job</code> quacc.recipes.vasp.mp.mp_relax_job VASP MP Workflow <code>@flow</code> quacc.recipes.vasp.mp.mp_relax_flow VASP QMOF Relax <code>@job</code> quacc.recipes.vasp.qmof.qmof_relax_job <p></p>"},{"location":"user/settings/settings.html","title":"Settings Management","text":"<p>Important</p> <p>The quacc configuration parameters (e.g. YAML file, environment variables) are only active on the machine where they are specified. In other words, each remote machine has its own custom set of configuration parameters.</p>"},{"location":"user/settings/settings.html#modifying-quacc-settings","title":"Modifying Quacc Settings","text":"<p>The default global quacc settings can be found in the <code>settings.py</code> file. If you wish to modify any of the global quacc settings, there are several ways to do so.</p>"},{"location":"user/settings/settings.html#using-a-yaml-file","title":"Using a YAML File","text":"<p>If you are planning to modify a given set of parameters for all of your calculations, the easiest way is to create a YAML file with custom settings. By default, quacc looks for this YAML file at <code>~/.quacc.yaml</code>. If you wish to store the YAML file somewhere else or with a different name, you can define the environment variable <code>QUACC_CONFIG_FILE</code> and point it to the YAML path of your choosing.</p> ~/.quacc.yaml<pre><code>SCRATCH_DIR: /tmp # (1)!\nCREATE_UNIQUE_WORKDIR: true # (2)!\n</code></pre> <ol> <li> <p>This would set the quacc scratch directory to <code>/tmp</code> on whatever machine the calculations are run on.</p> </li> <li> <p>This would ensure that each job in your quacc workflow is run in a unique, isolated working directory. This is often useful when running workflows in parallel, although some workflow engines like Covalent have their own mechanisms for this.</p> </li> </ol> <p>Tip</p> <p>The quacc command-line interface (CLI) lets you update the YAML file from the terminal. You can run <code>quacc set PARAMETER value</code> to set a given parameter in the YAML file to the specified value. Similarly, you can run <code>quacc unset PARAMETER</code> to remove a parameter from the YAML file.</p>"},{"location":"user/settings/settings.html#using-environment-variables","title":"Using Environment Variables","text":"<p>If you want to define quacc settings without writing them to a YAML file, you can instead modify the desired settings by defining individual environment variables with <code>QUACC</code> as the prefix. For instance, to modify the <code>SCRATCH_DIR</code> setting to be <code>/tmp</code>, simply define <code>QUACC_SCRATCH_DIR=/tmp</code> as a new environment variable. This approach is ideal when you want to modify the quacc settings for a subset of jobs, as the environment variable can be included in the job's submission script.</p>"},{"location":"user/settings/settings.html#modifying-the-global-settings-in-a-script","title":"Modifying the Global Settings in a Script","text":"<p>If you want to define quacc settings on-the-fly without writing them to a YAML file or using environment variables, you can do so within your script by modifying the <code>SETTINGS</code> object. This approach is ideal when you want to dynamically change a setting within a given Python process or if you're debugging in a Jupyter Notebook.</p> <pre><code>from quacc import SETTINGS\n\nSETTINGS.CREATE_UNIQUE_WORKDIR = True\n</code></pre> <p>Warning</p> <p>This approach should not be used with the <code>WORKFLOW_ENGINE</code> variable.</p>"},{"location":"user/settings/settings_list.html","title":"List of Quacc Settings","text":"quacc/settings.py<pre><code>    # ---------------------------\n    # Workflow Engine\n    # ---------------------------\n\n    WORKFLOW_ENGINE: Literal[\n        \"covalent\", \"jobflow\", \"parsl\", \"prefect\", \"redun\", \"local\"\n    ] = Field(\n        installed_engine,\n        description=(\n            \"The workflow manager to use.\"\n            \"Options include: 'covalent', 'parsl', 'redun', 'jobflow', 'prefect', or 'local'\"\n        ),\n    )\n\n    # ---------------------------\n    # General Settings\n    # ---------------------------\n\n    RESULTS_DIR: Path = Field(\n        Path.cwd(),\n        description=(\n            \"Directory to store I/O-based calculation results in.\"\n            \"Note that this behavior may be modified by the chosen workflow engine.\"\n            \"For instance, Covalent specifies the base directory as the `workdir` \"\n            \"of a local executor or the `remote_workdir` of a remote executor.\"\n            \"In this case, the `RESULTS_DIR` will be a subdirectory of that directory.\"\n        ),\n    )\n    SCRATCH_DIR: Path = Field(\n        Path(\"~/.scratch\"),\n        description=\"Scratch directory for calculations.\",\n    )\n    CREATE_UNIQUE_WORKDIR: bool = Field(\n        False,\n        description=(\n            \"Whether to have a unique working directory in RESULTS_DIR for each job.\"\n            \"Some workflow engines have an option to do this for you already.\"\n        ),\n    )\n    GZIP_FILES: bool = Field(\n        True, description=\"Whether generated files should be gzip'd.\"\n    )\n    CHECK_CONVERGENCE: bool = Field(\n        True,\n        description=\"Whether to check for convergence in the `summarize_run`-type functions, if supported.\",\n    )\n\n    # ---------------------------\n    # Data Store Settings\n    # ---------------------------\n    PRIMARY_STORE: Optional[Union[str, Store]] = Field(\n        None,\n        description=(\n            \"String-based JSON representation of the primary Maggma data store \"\n            \"where calculation results will be stored.\"\n            \"Taken from the `.to_json()` method of the corresponding Store object.\"\n        ),\n    )\n\n    # ---------------------------\n    # ORCA Settings\n    # ---------------------------\n    ORCA_CMD: Path = Field(\n        Path(\"orca\"),\n        description=(\n            \"Path to the ORCA executable. This must be the full, absolute path \"\n            \"for parallel calculations to work.\"\n        ),\n    )\n\n    # ---------------------------\n    # VASP Settings\n    # ---------------------------\n\n    # VASP Settings: Main\n    VASP_PARALLEL_CMD: str = Field(\n        \"\",\n        description=(\n            \"Parallel command to run VASP with Custodian.\"\n            \"For example: srun -N 2 --ntasks-per-node 48\"\n            \"Note that this does not include the executable name.\"\n        ),\n    )\n    VASP_CMD: str = Field(\n        \"vasp_std\", description=\"Command to run the standard version of VASP.\"\n    )\n    VASP_GAMMA_CMD: str = Field(\n        \"vasp_gam\", description=\"Command to run the gamma-point only version of VASP.\"\n    )\n\n    # VASP Settings: General\n    VASP_INCAR_COPILOT: bool = Field(\n        True,\n        description=(\n            \"Whether co-pilot mode should be used for VASP INCAR handling.\"\n            \"This will modify INCAR flags on-the-fly if they disobey the VASP manual.\"\n            \"A warning will be raised in each case.\"\n        ),\n    )\n    VASP_BADER: bool = Field(\n        bool(which(\"bader\")),\n        description=(\n            \"Whether to run a Bader analysis when summarizing VASP results.\"\n            \"Requires bader to be in PATH.\"\n        ),\n    )\n    VASP_PRESET_MAG_DEFAULT: float = Field(\n        1.0,\n        description=(\n            \"Default initial magmom to use for a given element if a preset \"\n            \"with magmoms is provided but an element is missing from the list\"\n        ),\n    )\n    VASP_MAG_CUTOFF: float = Field(\n        0.05,\n        description=(\n            \"If the absolute value of all magnetic moments are below this value, \"\n            \"they will be set to 0 such that a spin-unpolarized calculation will be performed\"\n        ),\n    )\n    VASP_COPY_MAGMOMS: bool = Field(\n        True,\n        description=(\n            \"If True, any pre-existing atoms.get_magnetic_moments() will be set\"\n            \"in atoms.set_initial_magnetic_moments().\"\n        ),\n    )\n    VASP_PRESET_DIR: Path = Field(\n        resources.files(vasp_defaults),\n        description=\"Path to the VASP preset directory\",\n    )\n\n    # VASP Settings: Custodian\n    VASP_USE_CUSTODIAN: bool = Field(\n        True, description=\"Whether Custodian should be used to run VASP\"\n    )\n    VASP_CUSTODIAN_VTST: bool = Field(\n        False,\n        description=(\n            \"If VTST-related input swaps should be used when running Custodian.\"\n            \"Requires VASP to be compiled with VTST\"\n        ),\n    )\n    VASP_CUSTODIAN_MAX_ERRORS: int = Field(\n        5, description=\"Maximum errors for Custodian\"\n    )\n    VASP_CUSTODIAN_HANDLERS: list[str] = Field(\n        [\n            \"VaspErrorHandler\",\n            \"MeshSymmetryErrorHandler\",\n            \"UnconvergedErrorHandler\",\n            \"NonConvergingErrorHandler\",\n            \"PotimErrorHandler\",\n            \"PositiveEnergyErrorHandler\",\n            \"FrozenJobErrorHandler\",\n            \"StdErrHandler\",\n            \"LargeSigmaHandler\",\n            \"IncorrectSmearingHandler\",\n        ],\n        description=\"Handlers for Custodian\",\n    )\n    VASP_CUSTODIAN_VALIDATORS: list[str] = Field(\n        [\"VasprunXMLValidator\", \"VaspFilesValidator\"],\n        description=\"Validators for Custodian\",\n    )\n    VASP_CUSTODIAN_WALL_TIME: Optional[int] = Field(\n        None,\n        description=(\n            \"After this many seconds, Custodian will stop running \"\n            \"and ensure that VASP writes a STOPCAR\"\n        ),\n    )\n\n    # ---------------------------\n    # Q-Chem Settings\n    # ---------------------------\n\n    # Q-Chem Settings: Main\n    QCHEM_CMD: str = Field(\n        \"qchem\", description=\"Command to run the standard version of Q-Chem.\"\n    )\n\n    QCHEM_LOCAL_SCRATCH: Path = Field(\n        Path(\"/tmp\") if Path(\"/tmp\").exists() else Path.cwd() / \".qchem_scratch\",\n        description=\"Compute-node local scratch directory in which Q-Chem should perform IO.\",\n    )\n\n    # Q-Chem Settings: Custodian\n    QCHEM_USE_ERROR_HANDLERS: bool = Field(\n        True,\n        description=\"Whether Custodian's error handlers should be employed for Q-Chem.\",\n    )\n\n    QCHEM_CUSTODIAN_MAX_ERRORS: int = Field(\n        5, description=\"Maximum errors for Q-Chem Custodian.\"\n    )\n\n    # NBO Settings\n    QCHEM_NBO_EXE: Optional[Path] = Field(\n        None, description=\"Full path to the NBO executable.\"\n    )\n\n    # ---------------------------\n    # NewtonNet Settings\n    # ---------------------------\n    NEWTONNET_MODEL_PATH: Union[Path, list[Path]] = Field(\n        \"best_model_state.tar\", description=\"Path to NewtonNet .tar model\"\n    )\n    NEWTONNET_CONFIG_PATH: Union[Path, list[Path]] = Field(\n        \"config.yml\", description=\"Path to NewtonNet YAML settings file\"\n    )\n</code></pre>"},{"location":"user/wflow_engine/executors1.html","title":"Deploying Calculations","text":"<p>In the previous examples, we have been running calculations on our local machine. However, in practice, you will probably want to run your calculations on one or more HPC machines. This section will describe how to set up your workflows to run on HPC machines using your desired workflow engine to scale up your calculations.</p> Parsl \u2b50Covalent \u2b50PrefectRedunJobflow <p>Out-of-the-box, Parsl will run on your local machine. However, in practice you will probably want to run your Parsl workflows on HPC machines.</p> <p>Note</p> <p>Unlike most other workflow engines, Parsl is built for the pilot job model where the allocated nodes continually pull in new tasks to run. This makes it possible to avoid submitting a large number of small jobs to the scheduler, which can be inefficient from a queuing perspective.</p> <p>Configuring Executors</p> <p>Tip</p> <p>To configure Parsl for the high-performance computing environment of your choice, refer to the executor Configuration page in the Parsl documentation for many examples.</p> <p>Let's imagine a scenario where we want to run a series of compute-intensive DFT calculations. Each DFT calculation requires 2 CPU nodes (each node having 48 cores). We want to run DFT calculations on 4 unique structures, all in parallel. We also want this to be done in a single Slurm allocation, meaning that this allocation must request 8 total nodes.</p> <p>An example <code>HighThroughputExecutor</code> that will orchestrate jobs from the login node of NERSC's Perlmutter machine to carry out the above example is as follows:</p> <pre><code>import parsl\nfrom parsl.config import Config\nfrom parsl.executors import HighThroughputExecutor\nfrom parsl.launchers import SimpleLauncher\nfrom parsl.providers import SlurmProvider\n\nmax_slurm_jobs = 1  # Maximum number of Slurm jobs (blocks) to allocate\nn_calcs_per_job = 4  # Number of calculations to run in parallel (per block)\nn_nodes_per_calc = 2  # Number of nodes to reserve for each calculation\n\nconfig = Config(\n    max_idletime=60,  # (1)!\n    strategy=\"htex_auto_scale\",  # (2)!\n    executors=[\n        HighThroughputExecutor(\n            label=\"quacc_parsl\",  # (3)!\n            max_workers=n_calcs_per_job,  # (4)!\n            cores_per_worker=1e-6,  # (5)!\n            provider=SlurmProvider(\n                account=\"MyAccountName\",\n                scheduler_options=\"#SBATCH -q debug -C cpu\",  # (6)!\n                worker_init=f\"source ~/.bashrc &amp;&amp; conda activate quacc\",  # (7)!\n                walltime=\"00:10:00\",  # (8)!\n                nodes_per_block=n_nodes_per_calc * n_calcs_per_job,  # (9)!\n                init_blocks=0,  # (10)!\n                min_blocks=0,  # (11)!\n                max_blocks=max_slurm_jobs,  # (12)!\n                launcher=SimpleLauncher(),  # (13)!\n                cmd_timeout=120,  # (14)!\n            ),\n        )\n    ],\n)\n\nparsl.load(config)\n</code></pre> <ol> <li> <p>The maximum amount of time (in seconds) to allow the executor to be idle before blocks (i.e. Slurm jobs) can potentially be shut down. Default is 120.</p> </li> <li> <p>Unique to the <code>HighThroughputExecutor</code>, this <code>strategy</code> will automatically scale the number of active blocks (i.e. Slurm jobs) up or down based on the number of tasks remaining. We set <code>max_blocks=1</code> here, so it can't scale up beyond 1 Slurm job, but it can scale down from 1 to 0 since <code>min_blocks=0</code>.</p> </li> <li> <p>This is just an arbitrary label for file I/O.</p> </li> <li> <p>Sets the maximum number of workers per block, which should generally be the number of tasks per block.</p> </li> <li> <p>This prevents the <code>HighThroughputExecutor</code> from reducing the number of workers if you request more workers than cores. It is recommended for codes that run via MPI.</p> </li> <li> <p>Any additional <code>#SBATCH</code> options not captured elsewhere can be included here.</p> </li> <li> <p>Any commands to run before carrying out any of the Parsl tasks. This is useful for setting environment variables, activating a given Conda environment, and loading modules.</p> </li> <li> <p>The walltime for each block (i.e. Slurm job).</p> </li> <li> <p>The number of nodes that each block (i.e. Slurm job) should allocate.</p> </li> <li> <p>Sets the number of blocks (e.g. Slurm jobs) to provision during initialization of the workflow. We set this to a value of 0 so that there isn't a running Slurm job before any tasks have been submitted to Parsl.</p> </li> <li> <p>Sets the minimum number of blocks (e.g. Slurm jobs) to maintain during elastic resource management. We set this to 0 so that Slurm jobs aren't running when there are no remaining tasks.</p> </li> <li> <p>Sets the maximum number of active blocks (e.g. Slurm jobs) during elastic resource management. We set this to 1 here, but it can be increased to have multiple Slurm jobs running simultaneously. Raising <code>max_blocks</code> to a larger value will allow the \"htex_auto_scale\" strategy to upscale resources as needed.</p> </li> <li> <p>The type of Launcher to use. <code>SimpleLauncher()</code> must be used instead of the commonly used <code>SrunLauncher()</code> to allow quacc subprocesses to launch their own <code>srun</code> commands.</p> </li> <li> <p>The maximum time to wait (in seconds) for the job scheduler info to be retrieved/sent.</p> </li> </ol> <p>Practical Deployment</p> <p>For debugging purposes or when running only a small numbers of jobs, it is simple enough to run the Parsl process from an interactive Jupyter Notebook or IPython kernel on the remote machine. However, for practical deployment and to ensure jobs are continually submitted to the queue even when the SSH session is terminated, you can run the Parsl orchestration process on a login node and maintain its state via a program like <code>tmux</code> or <code>screen</code>.</p> <p>For example, running <code>tmux new -s launcher</code> will create a new <code>tmux</code> session named <code>launcher</code>. To exit the <code>tmux</code> session while still preserving any running tasks on the login node, press <code>ctrl+b</code> followed by <code>d</code>. To re-enter the tmux session, run <code>tmux attach -t launcher</code>. Additional <code>tmux</code> commands can be found on the tmux cheatsheet.</p> <p>Multiple Executors</p> <p>Parsl supports tying specific executors to a given <code>PythonApp</code>, as discussed in the Multi-Executor section of the Parsl documentation.</p> <p>By default, Covalent will run all jobs on your local machine using the Dask backend. This is a parameter that you can control. For instance, Covalent offers many executor plugins that can be installed and used to interface with a wide range of HPC, cloud, and quantum devices.</p> <p>Setting the Executor for the Flow</p> <p>If you want to use the same executor for all the jobs in a workflow, you can pass the <code>executor</code> keyword argument to the <code>@flow</code> decorator.</p> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job, static_job\n\n\n@flow(executor=\"local\", workflow_executor=\"local\")  # (1)!\ndef workflow(atoms):\n    result1 = relax_job(atoms)\n    result2 = static_job(result1)\n\n    return result2\n\n\natoms = bulk(\"Cu\")\ndispatch_id = ct.dispatch(workflow)(atoms)\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <ol> <li>This was merely for demonstration purposes. There is never really a need to use the \"local\" executor since the \"dask\" executor runs locally and is faster. Also, until Issue 1024 is resolved, you will also need to directly set the <code>workflow_executor</code> keyword argument in the <code>@flow</code> decorator to the same value as that used for <code>executor</code> otherwise a post-processing error will occur.</li> </ol> <p>Setting Executors for Individual Jobs</p> <p>The individual executor options for each job can be modified after they are imported as well.</p> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job, static_job\n\nrelax_job.electron_object.executor = \"dask\"\nstatic_job.electron_object.executor = \"local\"\n\n\n@flow\ndef workflow(atoms):\n    output1 = relax_job(atoms)\n    output2 = static_job(output1)\n\n    return output2\n\n\natoms = bulk(\"Cu\")\ndispatch_id = ct.dispatch(workflow)(atoms)\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <p>Configuring Executors</p> <p>Tip</p> <p>Refer to the executor plugin documentation for instructions on how to install and use the relevant plugins that allow Covalent to submit jobs on your desired machines.</p> <p>Most users of quacc will probably want to use the <code>HPCExecutor</code>, which is a plugin for Covalent that supports Slurm, PBS, LSF, Flux, and more. For submitting jobs to a Slurm-based job scheduler from your local machine, an example <code>HPCExecutor</code> configuration might look like the following, which has been tested on Perlmutter at NERSC:</p> <pre><code>n_nodes = 2  # Number of nodes to reserve for each calculation\nn_cores_per_node = 48  # Number of CPU cores per node\n\nexecutor = ct.executor.HPCExecutor(\n    # SSH credentials\n    username=\"YourUserName\",\n    address=\"perlmutter-p1.nersc.gov\",\n    ssh_key_file=\"~/.ssh/nersc\",\n    cert_file=\"~/.ssh/nersc-cert.pub\",  # (1)!\n    # PSI/J parameters\n    instance=\"slurm\",\n    resource_spec_kwargs={\n        \"node_count\": n_nodes,\n        \"processes_per_node\": n_cores_per_node,\n    },  # (2)!\n    job_attributes_kwargs={\n        \"duration\": 10,  # minutes\n        \"project_name\": \"YourAccountName\",\n        \"custom_attributes\": {\"slurm.constraint\": \"cpu\", \"slurm.qos\": \"debug\"},\n    },  # (3)!\n    # Remote Python env parameters\n    remote_conda_env=\"quacc\",\n    # Covalent parameters\n    remote_workdir=\"$SCRATCH/quacc\",\n    create_unique_workdir=True,  # (4)!\n    cleanup=False,  # (5)!\n)\n</code></pre> <ol> <li> <p>This a certificate file used to validate your SSH credentials. This is often not needed but is required at NERSC facilities due to the use of <code>sshproxy</code>-based multi-factor authentication.</p> </li> <li> <p>These are the resource specifications for the compute job, which are keyword arguments passed to PSI/J's <code>ResourceSpecV1</code> class.</p> </li> <li> <p>These are the job attributes that the job scheduler needs, which are keyword arguments passed to PSI/J's <code>JobAttributes</code> class.</p> </li> <li> <p>You generally want each quacc job to be run in its own unique working directory to ensure files don't overwrite one another, so  <code>create_unique_workdir</code> should be set to <code>True</code>.</p> </li> <li> <p>For debugging purposes, it can be useful to keep all the temporary files. Once you're confident things work, you can omit the <code>cleanup</code> keyword argument.</p> </li> </ol> Note <p>If you plan to use the dedicated SlurmExecutor developed by Covalent, an analagous example is included below:</p> <pre><code>n_nodes = 2\nn_cores_per_node = 48\n\nexecutor = ct.executor.SlurmExecutor(\n    username=\"YourUserName\",\n    address=\"perlmutter-p1.nersc.gov\",\n    ssh_key_file=\"~/.ssh/nersc\",\n    cert_file=\"~/.ssh/nersc-cert.pub\",\n    remote_workdir=\"$SCRATCH/quacc\",\n    conda_env=\"quacc\",\n    options={\n        \"nodes\": f\"{n_nodes}\",\n        \"qos\": \"debug\",\n        \"constraint\": \"cpu\",\n        \"account\": \"YourAccountName\",\n        \"job-name\": \"quacc\",\n        \"time\": \"00:10:00\",\n    },\n    use_srun=False,  # (1)!\n)\n</code></pre> <ol> <li>The <code>SlurmExecutor</code> must have <code>use_srun=False</code> in order for ASE-based calculators to be launched appropriately.</li> </ol> <p>Out-of-the-box, Prefect will run on your local machine. However, in practice you will probably want to run your Prefect workflows on HPC machines.</p> <p>Defining Task Runners</p> <p>Tip</p> <p>Check out the Task Runner documentation for more information on how Prefect handles task execution.</p> <p>To modify where tasks are run, set the <code>task_runner</code> keyword argument of the corresponding <code>@flow</code> decorator. The jobs in this scenario would be submitted from a login node.</p> <p>An example is shown below for setting up a task runner compatible with the NERSC Perlmutter machine:</p> <pre><code>from quacc.wflow.prefect import make_prefect_runner\n\nn_slurm_jobs = 1  # Number of Slurm jobs to launch in parallel.\nn_nodes_per_calc = 1  # Number of nodes to reserve for each Slurm job.\nn_cores_per_node = 48  # Number of CPU cores per node.\nmem_per_node = \"64 GB\"  # Total memory per node.\n\ncluster_kwargs = {\n    # Dask worker options\n    \"n_workers\": n_slurm_jobs,  # (1)!\n    \"cores\": n_cores_per_node,  # (2)!\n    \"memory\": mem_per_node,  # (3)!\n    # SLURM options\n    \"shebang\": \"#!/bin/bash\",\n    \"account\": \"AccountName\",\n    \"walltime\": \"00:10:00\",\n    \"job_mem\": \"0\",  # (4)!\n    \"job_script_prologue\": [\n        \"source ~/.bashrc\",\n        \"conda activate quacc\",\n    ],  # (5)!\n    \"job_directives_skip\": [\"-n\", \"--cpus-per-task\"],  # (6)!\n    \"job_extra_directives\": [f\"-N {n_nodes_per_calc}\", \"-q debug\", \"-C cpu\"],  # (7)!\n    \"python\": \"python\",  # (8)!\n}\n\nrunner = make_prefect_runner(cluster_kwargs, temporary=True)\n</code></pre> <ol> <li> <p>Number of Slurm jobs to launch.</p> </li> <li> <p>Total number of cores (per Slurm job) for Dask worker.</p> </li> <li> <p>Total memory (per Slurm job) for Dask worker.</p> </li> <li> <p>Request all memory on the node.</p> </li> <li> <p>Commands to run before calculation. This is a good place to include environment variable definitions and modules to load.</p> </li> <li> <p>Slurm directives that are automatically added but that we chose to skip.</p> </li> <li> <p>The number of nodes for each calculation (-N), queue name (-q), and constraint (-c). Oftentimes, the constraint flag is not needed.</p> </li> <li> <p>The Python executable name. This often does not need to be changed.</p> </li> </ol> <p>With this instantiated cluster object, you can set the task runner of the <code>Flow</code>:</p> <pre><code>@flow(task_runner=runner)\ndef workflow(atoms):\n    ...\n</code></pre> <p>When the worklow is run from the login node, it will be submitted to the job scheduling system (Slurm by default), and the results will be sent back to Prefect Cloud once completed.</p> <p>Tip</p> <p>Refer to the Dask-Jobqueue Documentation for the available <code>cluster_kwargs</code> that can be defined and how they relate to a typical job script.</p> <p>To asynchronously spawn a Slurm job that continually pulls in work for the duration of its walltime (rather than starting and terminating over the lifetime of the associated <code>Flow</code>), you can instead use the <code>make_prefect_runner</code> command without a <code>temporary</code> keyword argument:</p> <pre><code>runner = make_prefect_runner(cluster_kwargs)\n</code></pre> <p>This is often more efficient for running large numbers of workflows because you can request a single, large Slurm job that continually pulls in work rather than submitting a large number of small jobs to the scheduler.</p> <p>Additionally, you can have the generated Dask cluster adaptively scale based on the amount of work available by setting <code>adapt_kwargs</code>:</p> <pre><code>runner = make_prefect_runner(cluster_kwargs, adapt_kwargs={\"minimum\": 1, \"maximum\": 5})\n</code></pre> <p>This will ensure that at least one Slurm job is always running, but the number of jobs will scale up to 5 if there is enough work available.</p> <p>Executor Configuration File</p> <p>Speaking of configurations, if you use mostly the same HPC settings for your calculations, it can be annoying to define a large dictionary in every workflow you run. Instead, you can define a configuration file at <code>~/.config/dask/jobqueue.yaml</code> as described in the dask-jobqueue documentation that can be used to define default values common to your HPC setup.</p> <p>Using a Prefect Work Pool and Agent</p> <p>So far, we have dispatched calculations immediately upon calling them. However, in practice, it is often more useful to have a Prefect agent running in the background that will continually poll for work to submit to the task runner. This allows you to submit only a subset of workflows at a time, and the agent will automatically submit more jobs as the resources become available. You will want to run Prefect workflows with an agent on the computing environment where you wish to submit jobs, specifically on a perpetual resource like a login node or dedicated workflow node. Refer to the \"Work Pools, Workers, and Agents\" section of the Prefect documentation for more details.</p> <p>Out-of-the-box, Redun will run on your local machine. However, in practice, you will probably want to specify a dedicated executor.</p> <p>Tip</p> <p>To configure Redun for the high-performance computing environment of your choice, refer to the executors page in the Redun documentation.</p> <p>Out-of-the-box, Jobflow can be used to run on your local machine. You will, however, need a \"manager\" to run your workflows on HPC machines. The currently recommended manager for Jobflow is FireWorks, which is described here.</p> <p>Setting Up Your <code>my_qadapter.yaml</code></p> <p>When you set up Jobflow and FireWorks, you created a <code>my_qadapter.yaml</code> file. It's now time to revisit that file and adjust the <code>pre_rocket</code> command with any modules or environment variables necessary for your calculations to run. Additionally, you will probably want to update the <code>nodes</code>, <code>walltime</code>, and related settings for your scheduler.</p> <p>Converting Between Jobflow and FireWorks</p> <p>The <code>jobflow.managers.fireworks</code> module has all the tools you need to convert your Jobflow workflows to a format that is suitable for FireWorks.</p> <p>Converting a Job to a Firework</p> <p>To convert a <code>Job</code> to a <code>firework</code> and add it to your launch pad:</p> <pre><code>from fireworks import LaunchPad\nfrom jobflow.managers.fireworks import job_to_firework\n\nfw = job_to_firework(job)\nlpad = LaunchPad.auto_load()\nlpad.add_wf(fw)\n</code></pre> <p>Converting a Flow to a Workflow</p> <p>To convert a <code>Flow</code> to a <code>workflow</code> and add it to your launch pad:</p> <pre><code>from fireworks import LaunchPad\nfrom jobflow.managers.fireworks import flow_to_workflow\n\nwf = flow_to_workflow(flow)\nlpad = LaunchPad.auto_load()\nlpad.add_wf(wf)\n</code></pre> <p>Setting Where Jobs are Dispatched</p> <p>The <code>my_qadapter.yaml</code> file you made in the installation instructions specifies how FireWorks will submit jobs added to your launch pad. Additional details can be found in the Jobflow Documentation for how to dynamically set where and how Jobflow <code>Job</code> and <code>Flow</code> objects can be dispatched.</p> <p>Dispatching Calculations</p> <p>With a workflow added to your launch pad, on the desired machine of choice, you can run <code>qlaunch rapidfire --nlaunches &lt;N&gt;</code> (where <code>&lt;N&gt;</code> is the number of jobs to submit) in the command line to submit your workflows to the job scheduler. Running <code>qlaunch rapidfire -m &lt;N&gt;</code> will ensure that <code>&lt;N&gt;</code> jobs are always in the queue or running. To modify the order in which jobs are run, a priority can be set via <code>lpad set_priority &lt;priority&gt; -i &lt;FWID&gt;</code> where <code>&lt;priority&gt;</code> is a number.</p> <p>By default, <code>qlaunch</code> will launch compute jobs that each poll for a single FireWork to run. This means that more Slurm jobs may be submitted than there are jobs to run. To modify the behavior of <code>qlaunch</code> to only submit a Slurm job for each \"READY\" FireWork in the launchpad, use the <code>-r</code> (\"reserved\") flag.</p> <p>Monitoring the Launchpad</p> <p>The easiest way to monitor the state of your launched FireWorks and workflows is through the GUI, which can be viewed with <code>lpad webgui</code>. To get the status of running fireworks from the command line, you can run <code>lpad get_fws -s RUNNING</code>. Other statuses can also be provided as well as individual FireWorks IDs.</p> <p>To rerun a specific FireWork, one can use the <code>rerun_fws</code> command like so: <code>lpad rerun_fws -i &lt;FWID&gt;</code> where <code>&lt;FWID&gt;</code> is the FireWork ID. Similarly, one can rerun all fizzled jobs via <code>lpad rerun_fws -s FIZZLED</code>. More complicated Mongo-style queries can also be carried out. Cancelling a workflow can be done with <code>lpad delete_wflows -i &lt;FWID&gt;</code>.</p> <p>Refer to the <code>lpad -h</code> help menu for more details.</p> <p>Continuous Job Submission</p> <p>To ensure that jobs are continually submitted to the queue, you can use <code>tmux</code> to preserve the job submission process even when the SSH session is terminated. For example, running <code>tmux new -s launcher</code> will create a new <code>tmux</code> session named <code>launcher</code>. To exit the <code>tmux</code> session while still preserving any running tasks on the login node, press <code>ctrl+b</code> followed by <code>d</code>. To re-enter the tmux session, run <code>tmux attach -t launcher</code>. Additional <code>tmux</code> commands can be found on the tmux cheatsheet.</p>"},{"location":"user/wflow_engine/executors2.html","title":"Worked Examples on HPC","text":"<p>In this section, we provide a few examples going through the entire process to deploy recipes remotely on HPC machines that use a job scheduler. The precise configuration details will depend on your given compute setup. Nonetheless, we have provided examples here for Perlmutter at NERSC that you can build from.</p> <p>Tip</p> <p>Before deploying remote calculations for the first time, do <code>quacc set WORKFLOW_ENGINE local</code> on the remote machine and run your recipe as a standard Python script (e.g. by submitting it as a job to the scheduler). This preliminary test will help you identify potential issues early on. When you're done, you can re-set the <code>WORKFLOW_ENGINE</code> variable and continue with deployment via a workflow manager.</p>"},{"location":"user/wflow_engine/executors2.html#pre-requisites","title":"Pre-Requisites","text":"<p>Start with a clean Conda environment if you don't have one already:</p> <pre><code>conda create --name quacc python=3.10\nconda activate quacc\n</code></pre> <p>Then install the necessary dependencies:</p> Parsl \u2b50Covalent \u2b50Jobflow <p>On both the remote machine:</p> <pre><code>pip install --no-cache-dir https://gitlab.com/ase/ase/-/archive/master/ase-master.zip\npip install quacc[parsl]\nquacc set WORKFLOW_ENGINE parsl\nquacc set CREATE_UNIQUE_WORKDIR True\n</code></pre> <p>On both the local and remote machines:</p> <pre><code>pip install --no-cache-dir https://gitlab.com/ase/ase/-/archive/master/ase-master.zip\npip install quacc[covalent]\nquacc set WORKFLOW_ENGINE covalent\n</code></pre> <p>On the local machine:</p> <pre><code>covalent start\n</code></pre> <p>Note</p> <p>If using Perlmutter at NERSC, modify your <code>~/.bashrc</code> on the remote machine as follows since only the <code>$SCRATCH</code> directory supports file locking mechanisms:</p> ~/.bashrc<pre><code>export COVALENT_CONFIG_DIR=\"$SCRATCH/.config/covalent\"\n</code></pre> <p>On both the local and remote machines:</p> <pre><code>pip install --no-cache-dir https://gitlab.com/ase/ase/-/archive/master/ase-master.zip\npip install quacc[jobflow]\nquacc set WORKFLOW_ENGINE jobflow\n</code></pre>"},{"location":"user/wflow_engine/executors2.html#example-1-emt","title":"Example 1: EMT","text":"<p>When deploying calculations for the first time, it's important to start simple, which is why you should try to run a sample EMT workflow first.</p> Parsl \u2b50Covalent \u2b50Jobflow <p>Starting Small</p> <p>From an interactive resource like a Jupyter Notebook or IPython kernel on the remote machine:</p> <pre><code>import parsl\nfrom parsl.config import Config\nfrom parsl.executors import HighThroughputExecutor\nfrom parsl.launchers import SimpleLauncher\nfrom parsl.providers import SlurmProvider\n\naccount = \"MyAccountName\"\n\nconfig = Config(\n    max_idletime=60,\n    strategy=\"htex_auto_scale\",\n    executors=[\n        HighThroughputExecutor(\n            label=\"quacc_parsl\",\n            provider=SlurmProvider(\n                account=account,\n                scheduler_options=\"#SBATCH -q debug -C cpu\",\n                worker_init=\"source ~/.bashrc &amp;&amp; conda activate quacc\",\n                walltime=\"00:10:00\",\n                nodes_per_block=1,\n                init_blocks=0,\n                min_blocks=0,\n                max_blocks=1,\n                launcher=SimpleLauncher(),\n                cmd_timeout=120,\n            ),\n        )\n    ],\n)\n\nparsl.load(config)\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job, static_job\n\n\ndef workflow(atoms):\n    relax_output = relax_job(atoms)\n    return static_job(relax_output)\n\n\natoms = bulk(\"Cu\")\nfuture = workflow(atoms)\nresult = future.result()\nprint(result)\n</code></pre> <p>Scaling Up</p> <p>Now it's time to scale things up and show off Parsl's true power. Let's run a TBLite relaxation and frequency calculation for 162 molecules in the so-called \"g2\" collection of small, neutral molecules.</p> <p>On the remote machine, make sure to run <code>pip install quacc[tblite]</code>. Then run the following example, adjusting the configuration as necessary for your machine.</p> <p>First we initialize a Parsl configuration. For this example, we will request 2 Slurm jobs (blocks), each of which will run tasks over 2 nodes that will be dynamically scaled</p> <pre><code>import parsl\nfrom parsl.config import Config\nfrom parsl.executors import HighThroughputExecutor\nfrom parsl.launchers import SimpleLauncher\nfrom parsl.providers import SlurmProvider\n\naccount = \"MyAccountName\"\n\nconfig = Config(\n    max_idletime=60,\n    strategy=\"htex_auto_scale\",\n    executors=[\n        HighThroughputExecutor(\n            label=\"quacc_parsl\",\n            provider=SlurmProvider(\n                account=account,\n                scheduler_options=\"#SBATCH -q debug -C cpu\",\n                worker_init=\"source ~/.bashrc &amp;&amp; conda activate quacc\",\n                walltime=\"00:10:00\",\n                nodes_per_block=2,\n                init_blocks=0,\n                min_blocks=0,\n                max_blocks=2,\n                launcher=SimpleLauncher(),\n                cmd_timeout=120,\n            ),\n        )\n    ],\n)\nparsl.load(config)\n</code></pre> <p>Now we define the workflow:</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.tblite.core import relax_job, freq_job\n\n\ndef workflow(atoms):\n    relax_output = relax_job(atoms)\n    return freq_job(relax_output)\n</code></pre> <p>We now loop over all molecules in the \"g2\" collection and apply our workflow.</p> <pre><code>from ase.build import molecule\nfrom ase.collections import g2\n\nfutures = []\nfor name in g2.names:\n    atoms = molecule(name)\n    future = workflow(atoms)  #  (1)!\n    futures.append(future)\n</code></pre> <ol> <li>This is where the calculations are asynchronously launched.</li> </ol> <p>We monitor the progress of our calculations and print a few summary values.</p> <pre><code>from tqdm import tqdm\nfrom concurrent.futures import as_completed\n\nfor future in tqdm(as_completed(futures), total=len(futures)):\n    task_doc = future.result()\n    print(\n        task_doc[\"formula_pretty\"],\n        task_doc[\"results\"][\"gibbs_energy\"],\n        task_doc[\"dir_name\"],\n    )\n</code></pre> <p>Run the following code on the local machine:</p> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job, static_job\n\nusername = \"MyUserName\"\naccount = \"MyAccountName\"\n\nexecutor = ct.executor.HPCExecutor(\n    username=username,\n    address=\"perlmutter-p1.nersc.gov\",\n    ssh_key_file=\"~/.ssh/nersc\",\n    cert_file=\"~/.ssh/nersc-cert.pub\",\n    instance=\"slurm\",\n    resource_spec_kwargs={\n        \"node_count\": 1,\n        \"processes_per_node\": 1,\n    },\n    job_attributes_kwargs={\n        \"duration\": 10,\n        \"project_name\": account,\n        \"custom_attributes\": {\"slurm.constraint\": \"cpu\", \"slurm.qos\": \"debug\"},\n    },\n    remote_conda_env=\"quacc\",\n    remote_workdir=\"$SCRATCH/quacc\",\n    create_unique_workdir=True,\n    cleanup=False,\n)\n\n\n@flow(executor=executor, workflow_executor=executor)  # (1)!\ndef workflow(atoms):\n    relax_output = relax_job(atoms)\n    return static_job(relax_output)\n\n\natoms = bulk(\"Cu\")\ndispatch_id = ct.dispatch(workflow)(atoms)\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <ol> <li>Until Issue 1024 is resolved, you need to directly set the <code>workflow_executor</code> keyword argument in the <code>@flow</code> decorator to the same value as that used for <code>executor</code> otherwise a post-processing error will occur.</li> </ol> <p>Hint</p> <p>The most common cause of issues is related to the job scheduler details (i.e. the <code>resource_spec_kwargs</code> and the <code>job_attributes_kwargs</code>). If your job fails on the remote machine, check the files left behind in the working directory as well as the <code>~/.psij</code> directory for a history and various log files associated with your attempted job submissions.</p> <p>From the login node of the remote machine, run the following:</p> <pre><code>import jobflow as jf\nfrom ase.build import bulk\nfrom fireworks import LaunchPad\nfrom jobflow.managers.fireworks import flow_to_workflow\nfrom quacc.recipes.emt.core import relax_job, static_job\n\natoms = bulk(\"Cu\")\njob1 = relax_job(atoms)\njob2 = static_job(job1.output)\nflow = jf.Flow([job1, job2])\n\nwf = flow_to_workflow(flow)\nlpad = LaunchPad.auto_load()\nlpad.add_wf(wf)\n</code></pre> <p>Then run the following on the remote machine:</p> <pre><code>qlaunch rapidfire -m 1\n</code></pre>"},{"location":"user/wflow_engine/executors2.html#example-2-vasp","title":"Example 2: VASP","text":"<p>In this example, we will run a sample VASP recipe that will highlight the use of a more complicated configuration.</p> <p>First, prepare your <code>VASP_PP_PATH</code> environment variable in the <code>~/.bashrc</code> of your remote machine as described in the ASE documentation. When you're done, follow the steps below.</p> Parsl \u2b50Covalent \u2b50Jobflow <p>From an interactive resource like a Jupyter Notebook or IPython kernel on the remote machine:</p> <pre><code>import parsl\nfrom parsl.config import Config\nfrom parsl.executors import HighThroughputExecutor\nfrom parsl.launchers import SimpleLauncher\nfrom parsl.providers import SlurmProvider\n\naccount = \"MyAccountName\"\nmax_slurm_jobs = 1\nn_calcs_per_job = 2\nn_nodes_per_calc = 1\nn_cores_per_node = 128\n\nconfig = Config(\n    strategy=\"htex_auto_scale\",\n    executors=[\n        HighThroughputExecutor(\n            label=\"quacc_parsl\",\n            max_workers=n_calcs_per_job,\n            cores_per_worker=1e-6,\n            provider=SlurmProvider(\n                account=account,\n                scheduler_options=\"#SBATCH -q debug -C cpu\",\n                worker_init=f\"source ~/.bashrc &amp;&amp; conda activate quacc &amp;&amp; module load vasp/6.4.1-cpu &amp;&amp; export QUACC_VASP_PARALLEL_CMD='srun -N {n_nodes_per_calc} --ntasks-per-node={n_cores_per_node} --cpu_bind=cores'\",\n                walltime=\"00:10:00\",\n                nodes_per_block=n_nodes_per_calc * n_calcs_per_job,\n                init_blocks=0,\n                min_blocks=0,\n                max_blocks=max_slurm_jobs,\n                launcher=SimpleLauncher(),\n                cmd_timeout=120,\n            ),\n        )\n    ],\n)\n\nparsl.load(config)\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc.recipes.vasp.core import relax_job, static_job\n\n\ndef workflow(atoms):\n    relax_output = relax_job(atoms, calc_swaps={\"kpts\": [3, 3, 3]})\n    return static_job(relax_output, calc_swaps={\"kpts\": [3, 3, 3]})\n\n\nfuture1 = workflow(bulk(\"C\"))\nfuture2 = workflow(bulk(\"Cu\"))\nprint(future1.result(), future2.result())\n</code></pre> <p>Run the following code on the local machine:</p> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.vasp.core import relax_job, static_job\n\nusername = \"MyUserName\"\naccount = \"MyAccountName\"\nn_nodes = 1\nn_cores_per_node = 128\n\nexecutor = ct.executor.HPCExecutor(\n    username=username,\n    address=\"perlmutter-p1.nersc.gov\",\n    ssh_key_file=\"~/.ssh/nersc\",\n    cert_file=\"~/.ssh/nersc-cert.pub\",\n    instance=\"slurm\",\n    resource_spec_kwargs={\n        \"node_count\": n_nodes,\n        \"processes_per_node\": n_cores_per_node,\n    },\n    job_attributes_kwargs={\n        \"duration\": 30,\n        \"project_name\": account,\n        \"custom_attributes\": {\"slurm.constraint\": \"cpu\", \"slurm.qos\": \"debug\"},\n    },\n    pre_launch_cmds=[\n        f\"export QUACC_VASP_PARALLEL_CMD='srun -N {n_nodes} --ntasks-per-node={n_cores_per_node} --cpu_bind=cores'\",\n        \"module load vasp/6.4.1-cpu\",\n    ],  # (1)!\n    remote_conda_env=\"quacc\",\n    remote_workdir=\"$SCRATCH/quacc\",\n    create_unique_workdir=True,\n    cleanup=False,\n)\n\n\n@flow(executor=executor, workflow_executor=executor)  # (2)!\ndef workflow(atoms):\n    relax_output = relax_job(atoms)\n    return static_job(relax_output)\n\n\natoms = bulk(\"C\")\ndispatch_id = ct.dispatch(workflow)(atoms)\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <ol> <li> <p>Until this issue is resolved, environment variables should be specified in <code>pre_launch_cmds</code>. Once it's resolved, it can be specified as <code>environment={\"QUACC_VASP_PARALLEL_CMD\": f\"srun -N {n_nodes} --ntasks-per-node={n_cores_per_node} --cpu_bind=cores\"}</code> instead.</p> </li> <li> <p>Until Issue 1024 is resolved, you need to directly set the <code>workflow_executor</code> keyword argument in the <code>@flow</code> decorator to the same value as that used for <code>executor</code> otherwise a post-processing error will occur.</p> </li> </ol> <p>You will need to update your <code>my_qadapter.yaml</code> file that you made when setting up FireWorks. Specifically, ensure that the following parameters are set:</p> my_qadapter.yaml<pre><code>_fw_name: CommonAdapter\n_fw_q_type: SLURM\nrocket_launch: rlaunch -w /path/to/fw_config/my_fworker.yaml singleshot\nnodes: 1\nwalltime: 00:30:00\naccount: MyAccountName\njob_name: quacc_firework\nqos: debug\npre_rocket: |\nmodule load vasp/6.4.1-cpu\nexport QUACC_VASP_PARALLEL_CMD=\"srun -N 1 --ntasks-per-node=128 --cpu_bind=cores\"\n</code></pre> <p>From the login node of the remote machine, then run the following:</p> <pre><code>import jobflow as jf\nfrom ase.build import bulk\nfrom fireworks import LaunchPad\nfrom jobflow.managers.fireworks import flow_to_workflow\nfrom quacc.recipes.vasp.core import relax_job, static_job\n\natoms = bulk(\"C\")\njob1 = relax_job(atoms, calc_swaps={\"kpts\": [3, 3, 3]})\njob2 = static_job(job1.output, calc_swaps={\"kpts\": [3, 3, 3]})\nflow = jf.Flow([job1, job2])\n\nwf = flow_to_workflow(flow)\nlpad = LaunchPad.auto_load()\nlpad.add_wf(wf)\n</code></pre> <p>Then run the following on the remote machine:</p> <pre><code>qlaunch rapidfire -m 1\n</code></pre>"},{"location":"user/wflow_engine/wflow_engines1.html","title":"Pre-Defined Recipes","text":"<p>Here, we will show how to use quacc with one of a variety of workflow engines to construct, dispatch, and monitor your calculations. In quacc, there are two types of recipes:</p> <ol> <li>Individual compute jobs with the suffix <code>_job</code> that have been pre-defined with a <code>@job</code> decorator.</li> <li>Multi-step workflows with the suffix <code>_flow</code> that have been pre-defined with a <code>@flow</code> decorator.</li> </ol>"},{"location":"user/wflow_engine/wflow_engines1.html#running-a-pre-defined-job","title":"Running a Pre-Defined Job","text":"<p>We will now try running a job where we relax a bulk Cu structure using EMT, which is pre-defined in quacc as quacc.recipes.emt.core.relax_job.</p> <pre><code>graph LR\n  A[Input] --&gt; B(Relax) --&gt; C[Output];</code></pre> Parsl \u2b50Covalent \u2b50PrefectRedunJobflow <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable and load the default Parsl configuration:</p> terminal<pre><code>quacc set WORKFLOW_ENGINE parsl\n</code></pre> python<pre><code>import parsl\n\nparsl.load()\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Call the PythonApp\nfuture = relax_job(atoms)  # (1)!\n\n# Print result\nprint(future.result())  # (2)!\n</code></pre> <ol> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here. We also did not need to use a <code>@flow</code> decorator because Parsl does not have an analogous decorator.</p> </li> <li> <p>The use of <code>.result()</code> serves to block any further calculations from running until it is resolved. Calling <code>.result()</code> also returns the function output as opposed to the <code>AppFuture</code> object.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable and start the Covalent server:</p> <pre><code>quacc set WORKFLOW_ENGINE covalent\ncovalent start\n</code></pre> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Define the workflow\nworkflow = flow(relax_job)  # (1)!\n\n# Dispatch the workflow to the Covalent server\n# with the bulk Cu Atoms object as the input\ndispatch_id = ct.dispatch(workflow)(atoms)  # (2)!\n\n# Fetch the result from the server\nresult = ct.get_result(dispatch_id, wait=True)  # (3)!\nprint(result)\n</code></pre> <ol> <li> <p>This is shorthand for the following:</p> <pre><code>@flow\ndef workflow(atoms):\n    return relax_job(atoms)\n</code></pre> <p>Also note that the <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here.</p> </li> <li> <p>This will dispatch the workflow to the Covalent server.</p> </li> <li> <p>The <code>ct.get_result</code> function is used to fetch the workflow status and results from the server. You don't need to set <code>wait=True</code> in practice. Once you dispatch the workflow, it will begin running (if the resources are available).</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable:</p> <pre><code>quacc set WORKFLOW_ENGINE prefect\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n\n# Define the workflow\n@flow\ndef workflow(atoms):\n    return relax_job(atoms)  # (1)!\n\n\n# Dispatch the workflow\nfuture = workflow(atoms)\n\n# Fetch the result\nresult = future.result()  # (2)!\nprint(result)\n</code></pre> <ol> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here.</p> </li> <li> <p>Calling <code>.result()</code> will resolve the future and return the calculation result.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable:</p> <pre><code>quacc set WORKFLOW_ENGINE redun\n</code></pre> <pre><code>from ase.build import bulk\nfrom redun import Scheduler\nfrom quacc.recipes.emt.core import relax_job\n\n# Instantiate the scheduler\nscheduler = Scheduler()\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow\nresult = scheduler.run(relax_job(atoms))  # (1)!\nprint(result)\n</code></pre> <ol> <li>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here.</li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable:</p> <pre><code>quacc set WORKFLOW_ENGINE jobflow\n</code></pre> <pre><code>import jobflow as jf\nfrom ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Define the Job\njob = relax_job(atoms)  # (1)!\n\n# Run the job locally\nresponses = jf.run_locally(job, create_folders=True)  # (2)!\n\n# Get the result\nresult = responses[job.uuid][1].output\nprint(result)\n</code></pre> <ol> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here.</p> </li> <li> <p>We chose to run the job locally, but other workflow managers supported by Jobflow can be imported and used.</p> </li> </ol>"},{"location":"user/wflow_engine/wflow_engines1.html#running-a-pre-defined-workflow","title":"Running a Pre-Defined Workflow","text":"<p>We will now try running a pre-defined workflow where we carve all possible slabs from a given structure, run a new relaxation calculation on each slab, and then a static calculation for each relaxed slab. This is implemented in quacc.recipes.emt.slabs.bulk_to_slabs_flow.</p> <pre><code>graph LR\n  A[Input] --&gt; B(Make Slabs)\n  B --&gt; C(Slab Relax) --&gt; G(Slab Static) --&gt; K[Output]\n  B --&gt; D(Slab Relax) --&gt; H(Slab Static) --&gt; K[Output]\n  B --&gt; E(Slab Relax) --&gt; I(Slab Static) --&gt; K[Output]\n  B --&gt; F(Slab Relax) --&gt; J(Slab Static) --&gt; K[Output];</code></pre> Parsl \u2b50Covalent \u2b50PrefectRedunJobflow <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Define the workflow\nfuture = bulk_to_slabs_flow(atoms)  # (1)!\n\n# Print the results\nprint(future.result())\n</code></pre> <ol> <li>We didn't need to wrap <code>bulk_to_slabs_flow</code> with a decorator because it is already pre-decorated with a <code>@flow</code> decorator.</li> </ol> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow\ndispatch_id = ct.dispatch(bulk_to_slabs_flow)(atoms)  # (1)!\n\n# Print the results\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <ol> <li>We didn't need to wrap <code>bulk_to_slabs_flow</code> with a decorator because it is already pre-decorated with a <code>@flow</code> decorator.</li> </ol> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow\nfutures = bulk_to_slabs_flow(atoms)  # (1)!\n\n# Print the results\nresults = [future.result() for future in futures]\nprint(results)\n</code></pre> <ol> <li>We didn't need to wrap <code>bulk_to_slabs_flow</code> with a decorator because it is already pre-decorated with a <code>@flow</code> decorator.</li> </ol> <pre><code>from ase.build import bulk\nfrom redun import Scheduler\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n# Instantiate the scheduler\nscheduler = Scheduler()\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Define the workflow\nresult = scheduler.run(bulk_to_slabs_flow(atoms))  # (1)!\n\n# Print the results\nprint(result)\n</code></pre> <ol> <li>We didn't need to wrap <code>bulk_to_slabs_flow</code> with a decorator because it is already pre-decorated with a <code>@flow</code> decorator.</li> </ol> <p>Warning</p> <p>Due to the difference in how Jobflow handles workflows (particularly dynamic ones) compared to other supported workflow engines, any quacc recipes that have been pre-defined with a <code>@flow</code> decorator (i.e. have <code>_flow</code> in the name) cannot be run directly with Jobflow. Rather, a Jobflow-specific <code>Flow</code> needs to be constructed by the user.</p>"},{"location":"user/wflow_engine/wflow_engines2.html","title":"Combining Recipes","text":"<p>Here, we will show how to use combine quacc jobs and workflows into your own custom workflows that can be run with your chosen workflow engine.</p>"},{"location":"user/wflow_engine/wflow_engines2.html#running-a-user-constructed-serial-workflow","title":"Running a User-Constructed Serial Workflow","text":"<p>We will now try running a simple workflow where we relax a bulk Cu structure using EMT and take the output of that calculation as the input to a follow-up static calculation with EMT.</p> <pre><code>graph LR\n  A[Input] --&gt; B(Relax) --&gt; C(Static) --&gt; D[Output];</code></pre> Parsl \u2b50Covalent \u2b50PrefectRedunJobflow <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable and load the default Parsl configuration:</p> terminal<pre><code>quacc set WORKFLOW_ENGINE parsl\n</code></pre> python<pre><code>import parsl\n\nparsl.load()\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job, static_job\n\n\n# Define the workflow\ndef workflow(atoms):\n    # Define Job 1\n    future1 = relax_job(atoms)  # (1)!\n\n    # Define Job 2, which takes the output of Job 1 as input\n    future2 = static_job(future1)\n\n    return future2\n\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow\nfuture = workflow(atoms)\n\n# Fetch the result\nresult = future.result()  # (2)!\nprint(result)\n</code></pre> <ol> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here.</p> </li> <li> <p>The use of <code>.result()</code> serves to block any further calculations from running until it is resolved. Calling <code>.result()</code> also returns the function output as opposed to the <code>AppFuture</code> object.</p> </li> </ol> <p>Note</p> <p>Parsl <code>PythonApp</code> objects will implicitly know to call <code>.result()</code> on any <code>AppFuture</code> it receives, and it is good to rely on this fact to avoid unecessary blocking.</p> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable and start the Covalent server:</p> <pre><code>quacc set WORKFLOW_ENGINE covalent\ncovalent start\n</code></pre> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job, static_job\n\n\n# Define the workflow\n@flow  # (1)!\ndef workflow(atoms):\n    # Define Job 1\n    result1 = relax_job(atoms)  # (2)!\n\n    # Define Job 2, which takes the output of Job 1 as input\n    result2 = static_job(result1)\n\n    return result2\n\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow to the Covalent server\n# with the bulk Cu Atoms object as the input\ndispatch_id = ct.dispatch(workflow)(atoms)  # (3)!\n\n# Fetch the result from the server\nresult = ct.get_result(dispatch_id, wait=True)  # (4)!\nprint(result)\n</code></pre> <ol> <li> <p>The <code>@flow</code> decorator defines the workflow that will be executed. It is the same as calling <code>ct.lattice</code> in Covalent.</p> </li> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here.</p> </li> <li> <p>Because the workflow was defined with a <code>@flow</code> decorator, it will be sent to the Covalent server and a dispatch ID will be returned.</p> </li> <li> <p>You don't need to set <code>wait=True</code> in practice. Once you dispatch the workflow, it will begin running (if the resources are available). The <code>ct.get_result</code> function is used to fetch the workflow status and results from the server.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable:</p> <pre><code>quacc set WORKFLOW_ENGINE prefect\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job, static_job\n\n\n# Define the workflow\n@flow  # (1)!\ndef workflow(atoms):\n    # Define Job 1\n    result1 = relax_job(atoms)  # (2)!\n\n    # Define Job 2, which takes the output of Job 1 as input\n    result2 = static_job(result1)\n\n    return result2\n\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow\nfuture = workflow(atoms)  # (3)!\n\n# Fetch the result\nresult = future.result()  # (4)!\nprint(result)\n</code></pre> <ol> <li> <p>The <code>@flow</code> decorator defines the workflow that will be executed.</p> </li> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here.</p> </li> <li> <p>Because the workflow was defined with a <code>@flow</code> decorator, it will be sent to the Prefect server and a future will be returned.</p> </li> <li> <p>Calling <code>.result()</code> resolves the future.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable:</p> <pre><code>quacc set WORKFLOW_ENGINE redun\n</code></pre> <pre><code>from ase.build import bulk\nfrom redun import Scheduler\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job, static_job\n\n# Instantiate the scheduler\nscheduler = Scheduler()\n\n\n# Define the workflow\n@flow  # (1)!\ndef workflow(atoms):\n    # Define Job 1\n    result1 = relax_job(atoms)  # (2)!\n\n    # Define Job 2, which takes the output of Job 1 as input\n    result2 = static_job(result1)\n\n    return result2\n\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow\nresult = scheduler.run(workflow(atoms))\nprint(result)\n</code></pre> <ol> <li> <p>The <code>@flow</code> decorator defines the workflow that will be executed. It is the same as the <code>@task</code> decorator in Redun.</p> </li> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable:</p> <pre><code>quacc set WORKFLOW_ENGINE jobflow\n</code></pre> <pre><code>import jobflow as jf\nfrom ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job, static_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Define Job 1\njob1 = relax_job(atoms)  # (1)!\n\n# Define Job 2, which takes the output of Job 1 as input\njob2 = static_job(job1.output)  # (2)!\n\n# Define the workflow\nworkflow = jf.Flow([job1, job2])  # (3)!\n\n# Run the workflow locally\nresponses = jf.run_locally(workflow, create_folders=True)  # (4)!\n\n# Get the result\nresult = responses[job2.uuid][1].output\nprint(result)\n</code></pre> <ol> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here.</p> </li> <li> <p>In Jobflow, each <code>Job</code> is only a reference and so the <code>.output</code> must be explicitly passed between jobs.</p> </li> <li> <p>We must stitch the individual <code>Job</code> objects together into a <code>jf.Flow</code>, which can be easily achieved by passing them as a list to the <code>jf.Flow()</code> constructor.</p> </li> <li> <p>We chose to run the job locally, but other workflow managers supported by Jobflow can be imported and used.</p> </li> </ol>"},{"location":"user/wflow_engine/wflow_engines2.html#running-a-user-constructed-parallel-workflow","title":"Running a User-Constructed Parallel Workflow","text":"<p>Now we will define a workflow where we will carry out two EMT structure relaxations, but the two jobs are not dependent on one another. In this example, the workflow manager will know that it can run the two jobs separately, and even if Job 1 were to fail, Job 2 would still progress.</p> <pre><code>graph LR\n  A[Input] --&gt; B(Relax) --&gt; D[Output]\n  A[Input] --&gt; C(Relax) --&gt; D[Output];</code></pre> Parsl \u2b50Covalent \u2b50PrefectRedunJobflow <pre><code>from ase.build import bulk, molecule\nfrom quacc.recipes.emt.core import relax_job\n\n\n# Define workflow\ndef workflow(atoms1, atoms2):\n    # Define two independent relaxation jobs\n    result1 = relax_job(atoms1)\n    result2 = relax_job(atoms2)\n\n    return {\"result1\": result1, \"result2\": result2}\n\n\n# Define two Atoms objects\natoms1 = bulk(\"Cu\")\natoms2 = molecule(\"N2\")\n\n# Define two independent relaxation jobs\nfutures = workflow(atoms1, atoms2)\n\n# Fetch the results\nresult1 = futures[\"result1\"].result()\nresult2 = futures[\"result2\"].result()\nprint(result1, result2)\n</code></pre> <pre><code>from ase.build import bulk, molecule\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\n\n\n# Define workflow\n@flow\ndef workflow(atoms1, atoms2):\n    # Define two independent relaxation jobs\n    result1 = relax_job(atoms1)\n    result2 = relax_job(atoms2)\n\n    return {\"result1\": result1, \"result2\": result2}\n\n\n# Define two Atoms objects\natoms1 = bulk(\"Cu\")\natoms2 = molecule(\"N2\")\n\n# Dispatch the workflow to the Covalent server\ndispatch_id = ct.dispatch(workflow)(atoms1, atoms2)\n\n# Fetch the results from the server\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <pre><code>from ase.build import bulk, molecule\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\n\n\n# Define workflow\n@flow\ndef workflow(atoms1, atoms2):\n    # Define two independent relaxation jobs\n    result1 = relax_job(atoms1)\n    result2 = relax_job(atoms2)\n\n    return {\"result1\": result1, \"result2\": result2}\n\n\n# Define two Atoms objects\natoms1 = bulk(\"Cu\")\natoms2 = molecule(\"N2\")\n\n# Dispatch the workflow\nfutures = workflow(atoms1, atoms2)\n\n# Fetch the results\nresult1 = futures[\"result1\"].result()\nresult2 = futures[\"result2\"].result()\nprint(result1, result2)\n</code></pre> <pre><code>from ase.build import bulk, molecule\nfrom redun import Scheduler\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\n\n# Instantiate the scheduler\nscheduler = Scheduler()\n\n\n# Define workflow\n@flow\ndef workflow(atoms1, atoms2):\n    # Define two independent relaxation jobs\n    result1 = relax_job(atoms1)\n    result2 = relax_job(atoms2)\n\n    return {\"result1\": result1, \"result2\": result2}\n\n\n# Define two Atoms objects\natoms1 = bulk(\"Cu\")\natoms2 = molecule(\"N2\")\n\n# Dispatch the workflow\nresult = scheduler.run(workflow(atoms1, atoms2))\nprint(result)\n</code></pre> <pre><code>import jobflow as jf\nfrom ase.build import bulk, molecule\nfrom quacc.recipes.emt.core import relax_job\n\n# Define two Atoms objects\natoms1 = bulk(\"Cu\")\natoms2 = molecule(\"N2\")\n\n# Define two independent relaxation jobs\njob1 = relax_job(atoms1)\njob2 = relax_job(atoms2)\n\n# Define the workflow\nworkflow = jf.Flow([job1, job2])\n\n# Run the workflow locally\nresponses = jf.run_locally(workflow, create_folders=True)\n\n# Get the result\nresult = responses[job2.uuid][1].output\nprint(result)\n</code></pre>"},{"location":"user/wflow_engine/wflow_engines2.html#running-a-user-constructed-dynamic-workflow","title":"Running a User-Constructed Dynamic Workflow","text":"<p>For this example, let's consider a toy scenario where we wish to relax a bulk Cu structure, carve all possible slabs, and then run a new relaxation calculation on each slab (with no static calculation at the end).</p> <pre><code>graph LR\n  A[Input] --&gt; B(Relax) --&gt; C(Make Slabs)\n  C(Make Slabs) --&gt; D(Slab Relax) --&gt; H[Output]\n  C(Make Slabs) --&gt; E(Slab Relax) --&gt; H[Output]\n  C(Make Slabs) --&gt; F(Slab Relax) --&gt; H[Output]\n  C(Make Slabs) --&gt; G(Slab Relax) --&gt; H[Output];</code></pre> Parsl \u2b50Covalent \u2b50PrefectRedunJobflow <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n\n# Define the workflow\ndef workflow(atoms):\n    relaxed_bulk = relax_job(atoms)\n    relaxed_slabs = bulk_to_slabs_flow(relaxed_bulk, run_static=False)  # (1)!\n\n    return relaxed_slabs\n\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow\nfuture = workflow(atoms)\n\n# Fetch the results\nresult = future.result()\nprint(result)\n</code></pre> <ol> <li>We didn't need to wrap <code>bulk_to_slabs_flow</code> with a decorator because it is already pre-decorated with a <code>@flow</code> decorator. We also chose to set <code>run_static=False</code> here to disable the static calculation that is normally carried out in this workflow.</li> </ol> <pre><code>import covalent as ct\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n\n# Define the workflow\n@flow\ndef workflow(atoms):\n    relaxed_bulk = relax_job(atoms)\n    relaxed_slabs = bulk_to_slabs_flow(relaxed_bulk, run_static=False)  # (1)!\n\n    return relaxed_slabs\n\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow and retrieve result\ndispatch_id = ct.dispatch(workflow)(atoms)\nresult = ct.get_result(dispatch_id, wait=True)\nprint(result)\n</code></pre> <ol> <li>We didn't need to wrap <code>bulk_to_slabs_flow</code> with a decorator because it is already pre-decorated with a <code>@flow</code> decorator. We also chose to set <code>run_static=False</code> here to disable the static calculation that is normally carried out in this workflow.</li> </ol> <pre><code>from ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n\n# Define the workflow\n@flow\ndef workflow(atoms):\n    relaxed_bulk = relax_job(atoms)\n    relaxed_slabs = bulk_to_slabs_flow(relaxed_bulk, run_static=False)  # (1)!\n\n    return relaxed_slabs\n\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow and retrieve result\nfutures = workflow(atoms)\nresults = [future.result() for future in futures]\nprint(results)\n</code></pre> <ol> <li>We didn't need to wrap <code>bulk_to_slabs_flow</code> with a decorator because it is already pre-decorated with a <code>@flow</code> decorator. We also chose to set <code>run_static=False</code> here to disable the static calculation that is normally carried out in this workflow.</li> </ol> <pre><code>from ase.build import bulk\nfrom redun import Scheduler\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\nscheduler = Scheduler()\n\n\n# Define the workflow\n@flow\ndef workflow(atoms):\n    relaxed_bulk = relax_job(atoms)\n    relaxed_slabs = bulk_to_slabs_flow(relaxed_bulk, run_static=False)  # (1)!\n\n    return relaxed_slabs\n\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Run the workflow\nresult = scheduler.run(workflow(atoms))\nprint(result)\n</code></pre> <ol> <li>We didn't need to wrap <code>bulk_to_slabs_flow</code> with a decorator because it is already pre-decorated with a <code>@flow</code> decorator. We also chose to set <code>run_static=False</code> here to disable the static calculation that is normally carried out in this workflow.</li> </ol> <p>Warning</p> <p>Due to the difference in how Jobflow handles workflows (particularly dynamic ones) compared to other supported workflow engines, any quacc recipes that have been pre-defined with a <code>@flow</code> decorator (i.e. have <code>_flow</code> in the name) cannot be run directly with Jobflow. Rather, a Jobflow-specific <code>Flow</code> needs to be constructed by the user.</p>"}]}